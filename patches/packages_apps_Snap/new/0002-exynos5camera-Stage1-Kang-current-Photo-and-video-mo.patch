From b399fd5ad54b0079fd5d42437a408f23341e1eac Mon Sep 17 00:00:00 2001
From: maniacx <macs18max@gmail.com>
Date: Mon, 16 Jul 2018 17:48:20 +0400
Subject: [PATCH 2/2] exynos5camera: Stage1: Kang current Photo and video
 modules as seperate module for samsung devices. So that we don't pollute much
 of qcom's modules. Samsung devices will have to activate using
 "persist.snap.exynos5camera" prop in thier device tree.

Obviously this wont compile

Change-Id: I22ebd3a48c43b24e44794cc287728f7bcfafa62d
---
 proguard.flags                                     |    5 +
 src/com/android/camera/BestpictureActivity.java    |  104 +-
 src/com/android/camera/CameraActivity.java         |  127 +-
 src/com/android/camera/MediaSaveService.java       |    7 +-
 src/com/android/camera/PanoCaptureModule.java      |    3 +-
 src/com/android/camera/PreviewGestures.java        |   57 +
 src/com/android/camera/SPhotoMenu.java             | 1237 ++++++
 src/com/android/camera/SPhotoModule.java           | 3922 ++++++++++++++++++++
 src/com/android/camera/SPhotoUI.java               | 1337 +++++++
 src/com/android/camera/SVideoMenu.java             |  922 +++++
 src/com/android/camera/SVideoModule.java           | 3284 ++++++++++++++++
 src/com/android/camera/SVideoUI.java               | 1268 +++++++
 .../android/camera/WideAnglePanoramaModule.java    |    4 +-
 .../camera/imageprocessor/PostProcessor.java       |  111 +-
 .../imageprocessor/filter/BestpictureFilter.java   |   97 +-
 .../camera/tinyplanet/TinyPlanetFragment.java      |    6 +-
 src/com/android/camera/ui/FaceView.java            |    4 +-
 src/com/android/camera/ui/FilmStripView.java       |  157 +-
 src/com/android/camera/ui/ModuleSwitcher.java      |   17 +-
 src/com/android/camera/util/CameraUtil.java        |    4 +
 20 files changed, 12509 insertions(+), 164 deletions(-)
 create mode 100644 src/com/android/camera/SPhotoMenu.java
 create mode 100644 src/com/android/camera/SPhotoModule.java
 create mode 100644 src/com/android/camera/SPhotoUI.java
 create mode 100644 src/com/android/camera/SVideoMenu.java
 create mode 100644 src/com/android/camera/SVideoModule.java
 create mode 100755 src/com/android/camera/SVideoUI.java

diff --git a/proguard.flags b/proguard.flags
index 522c664..195abe3 100755
--- a/proguard.flags
+++ b/proguard.flags
@@ -25,6 +25,11 @@
   public void onProtectiveCurtainClick(...);
 }
 
+-keep class com.android.camera.SVideoModule {
+  public void onCancelBgTraining(...);
+  public void onProtectiveCurtainClick(...);
+}
+
 -keep class * extends android.app.Activity {
   @com.android.camera.OnClickAttr <methods>;
 }
diff --git a/src/com/android/camera/BestpictureActivity.java b/src/com/android/camera/BestpictureActivity.java
index e4c1ca0..7bf14be 100644
--- a/src/com/android/camera/BestpictureActivity.java
+++ b/src/com/android/camera/BestpictureActivity.java
@@ -98,6 +98,7 @@ public class BestpictureActivity extends FragmentActivity {
     private ImageItems mImageItems;
     private ImageLoadingThread mLoadingThread;
     private PhotoModule.NamedImages mNamedImages;
+    private SPhotoModule.SNamedImages mSNamedImages;
     private Uri mPlaceHolderUri;
     private Dialog mDialog;
     private AlertDialog.Builder mBuilder;
@@ -188,8 +189,11 @@ public class BestpictureActivity extends FragmentActivity {
         display.getSize(size);
         mWidth = size.x/4;
         mHeight = size.y/4;
-        mNamedImages = new PhotoModule.NamedImages();
-
+        if(CameraUtil.HAS_EXYNOS5CAMERA) {
+            mSNamedImages = new SPhotoModule.SNamedImages();
+        } else {
+            mNamedImages = new PhotoModule.NamedImages();
+        }
         mImageItems = new ImageItems(mActivity);
         mDotsView = (DotsView) findViewById(R.id.dots_view);
         mDotsView.setItems(mImageItems);
@@ -613,34 +617,31 @@ public class BestpictureActivity extends FragmentActivity {
 
     private void saveForground(String path) {
         long captureStartTime = System.currentTimeMillis();
-        mNamedImages.nameNewImage(captureStartTime);
-        PhotoModule.NamedImages.NamedEntity name = mNamedImages.getNextNameEntity();
-        String title = (name == null) ? null : name.title;
-        String outPath = mPlaceHolderUri.getPath();
-        try {
-            FileOutputStream out = new FileOutputStream(outPath);
-            FileInputStream in = new FileInputStream(path);
-            byte[] buf = new byte[4096];
-            int len;
-            while ((len = in.read(buf)) > 0) {
-                out.write(buf, 0, len);
-            }
-            in.close();
-            out.close();
-        } catch (Exception e) {
-        }
-    }
-
-    private class SaveImageTask extends AsyncTask<String, Void, Void> {
-        protected Void doInBackground(String... path) {
-            long captureStartTime = System.currentTimeMillis();
+        if(CameraUtil.HAS_EXYNOS5CAMERA) {
+            mSNamedImages.nameNewImage(captureStartTime);
+            SPhotoModule.SNamedImages.SNamedEntity name = mSNamedImages.getNextNameEntity();
+            String title = (name == null) ? null : name.title;
+            String outPath = mPlaceHolderUri.getPath();
+            try {
+                FileOutputStream out = new FileOutputStream(outPath);
+                FileInputStream in = new FileInputStream(path);
+                byte[] buf = new byte[4096];
+                int len;
+                while ((len = in.read(buf)) > 0) {
+                    out.write(buf, 0, len);
+                }
+                in.close();
+                out.close();
+            } catch (Exception e) {
+            }
+        } else {
             mNamedImages.nameNewImage(captureStartTime);
             PhotoModule.NamedImages.NamedEntity name = mNamedImages.getNextNameEntity();
             String title = (name == null) ? null : name.title;
-            String outPath = Storage.generateFilepath(title, "jpeg");
+            String outPath = mPlaceHolderUri.getPath();
             try {
                 FileOutputStream out = new FileOutputStream(outPath);
-                FileInputStream in = new FileInputStream(path[0]);
+                FileInputStream in = new FileInputStream(path);
                 byte[] buf = new byte[4096];
                 int len;
                 while ((len = in.read(buf)) > 0) {
@@ -650,10 +651,55 @@ public class BestpictureActivity extends FragmentActivity {
                 out.close();
             } catch (Exception e) {
             }
-            Uri uri = Uri.fromFile(new File(outPath));
-            Intent intent = new Intent(Intent.ACTION_MEDIA_SCANNER_SCAN_FILE, uri);
-            sendBroadcast(intent);
-            return null;
+        }
+    }
+
+    private class SaveImageTask extends AsyncTask<String, Void, Void> {
+        protected Void doInBackground(String... path) {
+            long captureStartTime = System.currentTimeMillis();
+            if(CameraUtil.HAS_EXYNOS5CAMERA) {
+                mSNamedImages.nameNewImage(captureStartTime);
+                SPhotoModule.SNamedImages.SNamedEntity name = mSNamedImages.getNextNameEntity();
+                String title = (name == null) ? null : name.title;
+                String outPath = Storage.generateFilepath(title, "jpeg");
+                try {
+                    FileOutputStream out = new FileOutputStream(outPath);
+                    FileInputStream in = new FileInputStream(path[0]);
+                    byte[] buf = new byte[4096];
+                    int len;
+                    while ((len = in.read(buf)) > 0) {
+                        out.write(buf, 0, len);
+                    }
+                    in.close();
+                    out.close();
+                } catch (Exception e) {
+                }
+                Uri uri = Uri.fromFile(new File(outPath));
+                Intent intent = new Intent(Intent.ACTION_MEDIA_SCANNER_SCAN_FILE, uri);
+                sendBroadcast(intent);
+                return null;
+            } else {
+                mNamedImages.nameNewImage(captureStartTime);
+                PhotoModule.NamedImages.NamedEntity name = mNamedImages.getNextNameEntity();
+                String title = (name == null) ? null : name.title;
+                String outPath = Storage.generateFilepath(title, "jpeg");
+                try {
+                    FileOutputStream out = new FileOutputStream(outPath);
+                    FileInputStream in = new FileInputStream(path[0]);
+                    byte[] buf = new byte[4096];
+                    int len;
+                    while ((len = in.read(buf)) > 0) {
+                        out.write(buf, 0, len);
+                    }
+                    in.close();
+                    out.close();
+                } catch (Exception e) {
+                }
+                Uri uri = Uri.fromFile(new File(outPath));
+                Intent intent = new Intent(Intent.ACTION_MEDIA_SCANNER_SCAN_FILE, uri);
+                sendBroadcast(intent);
+                return null;
+            }
         }
 
         protected void onPostExecute(Void v) {
diff --git a/src/com/android/camera/CameraActivity.java b/src/com/android/camera/CameraActivity.java
index 29a5cdb..c113804 100644
--- a/src/com/android/camera/CameraActivity.java
+++ b/src/com/android/camera/CameraActivity.java
@@ -209,6 +209,8 @@ public class CameraActivity extends Activity
     private CameraModule mCurrentModule;
     private PhotoModule mPhotoModule;
     private VideoModule mVideoModule;
+    private SPhotoModule mSPhotoModule;
+    private SVideoModule mSVideoModule;
     private WideAnglePanoramaModule mPanoModule;
     private CaptureModule mCaptureModule;
     private PanoCaptureModule mPano2Module;
@@ -818,7 +820,7 @@ public class CameraActivity extends Activity
     public void updateThumbnail(boolean videoOnly) {
         // Only handle OnDataInserted if it's video.
         // Photo and Panorama have their own way of updating thumbnail.
-        if (!videoOnly || (mCurrentModule instanceof VideoModule) ||
+        if (!videoOnly || (mCurrentModule instanceof VideoModule) || (mCurrentModule instanceof SVideoModule) ||
                 ((mCurrentModule instanceof CaptureModule) && videoOnly)) {
             (new UpdateThumbnailTask(null, true)).execute();
         }
@@ -1545,11 +1547,13 @@ public class CameraActivity extends Activity
         int moduleIndex = -1;
         if (MediaStore.INTENT_ACTION_VIDEO_CAMERA.equals(getIntent().getAction())
                 || MediaStore.ACTION_VIDEO_CAPTURE.equals(getIntent().getAction())) {
-            moduleIndex = ModuleSwitcher.VIDEO_MODULE_INDEX;
+            moduleIndex = CameraUtil.HAS_EXYNOS5CAMERA ? ModuleSwitcher.SVIDEO_MODULE_INDEX
+                            : ModuleSwitcher.VIDEO_MODULE_INDEX;
         } else if (MediaStore.INTENT_ACTION_STILL_IMAGE_CAMERA.equals(getIntent().getAction())
                 || MediaStore.INTENT_ACTION_STILL_IMAGE_CAMERA_SECURE.equals(getIntent()
                 .getAction())) {
-            moduleIndex = ModuleSwitcher.PHOTO_MODULE_INDEX;
+            moduleIndex = CameraUtil.HAS_EXYNOS5CAMERA ? ModuleSwitcher.SPHOTO_MODULE_INDEX
+                            : ModuleSwitcher.PHOTO_MODULE_INDEX;
             SharedPreferences prefs = PreferenceManager.getDefaultSharedPreferences(this);
             if (prefs.getInt(CameraSettings.KEY_STARTUP_MODULE_INDEX, -1)
                     == ModuleSwitcher.GCAM_MODULE_INDEX && GcamHelper.hasGcamCapture()) {
@@ -1557,7 +1561,8 @@ public class CameraActivity extends Activity
             }
         } else if (MediaStore.ACTION_IMAGE_CAPTURE.equals(getIntent().getAction())
                 || MediaStore.ACTION_IMAGE_CAPTURE_SECURE.equals(getIntent().getAction())) {
-            moduleIndex = ModuleSwitcher.PHOTO_MODULE_INDEX;
+            moduleIndex = CameraUtil.HAS_EXYNOS5CAMERA ? ModuleSwitcher.SPHOTO_MODULE_INDEX
+                            : ModuleSwitcher.PHOTO_MODULE_INDEX;
         } else {
             // If the activity has not been started using an explicit intent,
             // read the module index from the last time the user changed modes
@@ -1565,7 +1570,8 @@ public class CameraActivity extends Activity
             moduleIndex = prefs.getInt(CameraSettings.KEY_STARTUP_MODULE_INDEX, -1);
             if ((moduleIndex == ModuleSwitcher.GCAM_MODULE_INDEX &&
                     !GcamHelper.hasGcamCapture()) || moduleIndex < 0) {
-                moduleIndex = ModuleSwitcher.PHOTO_MODULE_INDEX;
+            moduleIndex = CameraUtil.HAS_EXYNOS5CAMERA ? ModuleSwitcher.SPHOTO_MODULE_INDEX
+                            : ModuleSwitcher.PHOTO_MODULE_INDEX;
             }
         }
 
@@ -2198,6 +2204,17 @@ public class CameraActivity extends Activity
                 mCameraVideoModuleRootView.setVisibility(View.VISIBLE);
                 break;
 
+            case ModuleSwitcher.SVIDEO_MODULE_INDEX:
+                if(mSVideoModule == null) {
+                    mSVideoModule = new SVideoModule();
+                    mSVideoModule.init(this, mCameraVideoModuleRootView);
+                } else {
+                    mSVideoModule.reinit();
+                }
+                mCurrentModule = mSVideoModule;
+                mCameraVideoModuleRootView.setVisibility(View.VISIBLE);
+                break;
+
             case ModuleSwitcher.PHOTO_MODULE_INDEX:
                 if(mPhotoModule == null) {
                     mPhotoModule = new PhotoModule();
@@ -2209,6 +2226,17 @@ public class CameraActivity extends Activity
                 mCameraPhotoModuleRootView.setVisibility(View.VISIBLE);
                 break;
 
+            case ModuleSwitcher.SPHOTO_MODULE_INDEX:
+                if(mSPhotoModule == null) {
+                    mSPhotoModule = new SPhotoModule();
+                    mSPhotoModule.init(this, mCameraPhotoModuleRootView);
+                } else {
+                    mSPhotoModule.reinit();
+                }
+                mCurrentModule = mSPhotoModule;
+                mCameraPhotoModuleRootView.setVisibility(View.VISIBLE);
+                break;
+
             case ModuleSwitcher.WIDE_ANGLE_PANO_MODULE_INDEX:
                 if(mPanoModule == null) {
                     mPanoModule = new WideAnglePanoramaModule();
@@ -2237,7 +2265,8 @@ public class CameraActivity extends Activity
                             RotateTextToast.makeText(activity, "Panocapture library is missing", Toast.LENGTH_SHORT).show();
                         }
                     });
-                    mCurrentModuleIndex = ModuleSwitcher.PHOTO_MODULE_INDEX;
+                    mCurrentModuleIndex = CameraUtil.HAS_EXYNOS5CAMERA ? ModuleSwitcher.SPHOTO_MODULE_INDEX
+                            : ModuleSwitcher.PHOTO_MODULE_INDEX;
                     //Let it fall through to photo module
                 } else {
                     if (mPano2Module == null) {
@@ -2252,14 +2281,25 @@ public class CameraActivity extends Activity
             case ModuleSwitcher.GCAM_MODULE_INDEX:  //Unused module for now
             default:
                 // Fall back to photo mode.
-                if(mPhotoModule == null) {
-                    mPhotoModule = new PhotoModule();
-                    mPhotoModule.init(this, mCameraPhotoModuleRootView);
+                if(CameraUtil.HAS_EXYNOS5CAMERA) {
+                    if(mSPhotoModule == null) {
+                        mSPhotoModule = new SPhotoModule();
+                        mSPhotoModule.init(this, mCameraPhotoModuleRootView);
+                    } else {
+                        mSPhotoModule.reinit();
+                    }
+                    mCurrentModule = mSPhotoModule;
+                    mCameraPhotoModuleRootView.setVisibility(View.VISIBLE);
                 } else {
-                    mPhotoModule.reinit();
+                    if(mPhotoModule == null) {
+                        mPhotoModule = new PhotoModule();
+                        mPhotoModule.init(this, mCameraPhotoModuleRootView);
+                    } else {
+                        mPhotoModule.reinit();
+                    }
+                    mCurrentModule = mPhotoModule;
+                    mCameraPhotoModuleRootView.setVisibility(View.VISIBLE);
                 }
-                mCurrentModule = mPhotoModule;
-                mCameraPhotoModuleRootView.setVisibility(View.VISIBLE);
                 break;
         }
     }
@@ -2444,38 +2484,73 @@ public class CameraActivity extends Activity
 
     // Accessor methods for getting latency times used in performance testing
     public long getAutoFocusTime() {
-        return (mCurrentModule instanceof PhotoModule) ?
-                ((PhotoModule) mCurrentModule).mAutoFocusTime : -1;
+        if(CameraUtil.HAS_EXYNOS5CAMERA) {
+            return (mCurrentModule instanceof SPhotoModule) ?
+                    ((SPhotoModule) mCurrentModule).mAutoFocusTime : -1;
+        } else {
+            return (mCurrentModule instanceof PhotoModule) ?
+                    ((PhotoModule) mCurrentModule).mAutoFocusTime : -1;
+        }
     }
 
     public long getShutterLag() {
-        return (mCurrentModule instanceof PhotoModule) ?
-                ((PhotoModule) mCurrentModule).mShutterLag : -1;
+        if(CameraUtil.HAS_EXYNOS5CAMERA) {
+            return (mCurrentModule instanceof SPhotoModule) ?
+                    ((SPhotoModule) mCurrentModule).mShutterLag : -1;
+        } else {
+            return (mCurrentModule instanceof PhotoModule) ?
+                    ((PhotoModule) mCurrentModule).mShutterLag : -1;
+        }
     }
 
     public long getShutterToPictureDisplayedTime() {
-        return (mCurrentModule instanceof PhotoModule) ?
-                ((PhotoModule) mCurrentModule).mShutterToPictureDisplayedTime : -1;
+        if(CameraUtil.HAS_EXYNOS5CAMERA) {
+            return (mCurrentModule instanceof SPhotoModule) ?
+                    ((SPhotoModule) mCurrentModule).mShutterToPictureDisplayedTime : -1;
+        } else {
+            return (mCurrentModule instanceof PhotoModule) ?
+                    ((PhotoModule) mCurrentModule).mShutterToPictureDisplayedTime : -1;
+        }
     }
 
     public long getPictureDisplayedToJpegCallbackTime() {
-        return (mCurrentModule instanceof PhotoModule) ?
-                ((PhotoModule) mCurrentModule).mPictureDisplayedToJpegCallbackTime : -1;
+        if(CameraUtil.HAS_EXYNOS5CAMERA) {
+            return (mCurrentModule instanceof SPhotoModule) ?
+                    ((SPhotoModule) mCurrentModule).mPictureDisplayedToJpegCallbackTime : -1;
+        } else {
+            return (mCurrentModule instanceof PhotoModule) ?
+                    ((PhotoModule) mCurrentModule).mPictureDisplayedToJpegCallbackTime : -1;
+        }
     }
 
     public long getJpegCallbackFinishTime() {
-        return (mCurrentModule instanceof PhotoModule) ?
-                ((PhotoModule) mCurrentModule).mJpegCallbackFinishTime : -1;
+        if(CameraUtil.HAS_EXYNOS5CAMERA) {
+            return (mCurrentModule instanceof PhotoModule) ?
+                    ((PhotoModule) mCurrentModule).mJpegCallbackFinishTime : -1;
+        } else {
+            return (mCurrentModule instanceof PhotoModule) ?
+                    ((PhotoModule) mCurrentModule).mJpegCallbackFinishTime : -1;
+        }
     }
 
     public long getCaptureStartTime() {
-        return (mCurrentModule instanceof PhotoModule) ?
-                ((PhotoModule) mCurrentModule).mCaptureStartTime : -1;
+        if(CameraUtil.HAS_EXYNOS5CAMERA) {
+            return (mCurrentModule instanceof PhotoModule) ?
+                    ((SPhotoModule) mCurrentModule).mCaptureStartTime : -1;
+        } else {
+            return (mCurrentModule instanceof PhotoModule) ?
+                    ((SPhotoModule) mCurrentModule).mCaptureStartTime : -1;
+        }
     }
 
     public boolean isRecording() {
-        return (mCurrentModule instanceof VideoModule) ?
-                ((VideoModule) mCurrentModule).isRecording() : false;
+        if(CameraUtil.HAS_EXYNOS5CAMERA) {
+            return (mCurrentModule instanceof SVideoModule) ?
+                    ((SVideoModule) mCurrentModule).isRecording() : false;
+        } else {
+            return (mCurrentModule instanceof VideoModule) ?
+                    ((VideoModule) mCurrentModule).isRecording() : false;
+        }
     }
 
     public CameraOpenErrorCallback getCameraOpenErrorCallback() {
diff --git a/src/com/android/camera/MediaSaveService.java b/src/com/android/camera/MediaSaveService.java
index dd9a136..e12c142 100755
--- a/src/com/android/camera/MediaSaveService.java
+++ b/src/com/android/camera/MediaSaveService.java
@@ -43,6 +43,7 @@ import com.android.camera.mpo.MpoImageData;
 import com.android.camera.mpo.MpoInterface;
 import com.android.camera.util.PersistUtil;
 import com.android.camera.util.XmpUtil;
+import com.android.camera.util.CameraUtil;
 
 import org.codeaurora.snapcam.filter.GDepth;
 import org.codeaurora.snapcam.filter.GImage;
@@ -188,13 +189,15 @@ public class MediaSaveService extends Service {
         // When dimensions are unknown, pass 0 as width and height,
         // and decode image for width and height later in a background thread
         addImage(data, title, date, loc, 0, 0, orientation, exif, l, resolver,
-                 PhotoModule.PIXEL_FORMAT_JPEG);
+                 CameraUtil.HAS_EXYNOS5CAMERA ? SPhotoModule.PIXEL_FORMAT_JPEG
+                         :PhotoModule.PIXEL_FORMAT_JPEG);
     }
     public void addImage(final byte[] data, String title, Location loc,
             int width, int height, int orientation, ExifInterface exif,
             OnMediaSavedListener l, ContentResolver resolver) {
         addImage(data, title, System.currentTimeMillis(), loc, width, height,
-                orientation, exif, l, resolver,PhotoModule.PIXEL_FORMAT_JPEG);
+                orientation, exif, l, resolver,CameraUtil.HAS_EXYNOS5CAMERA ? 
+                SPhotoModule.PIXEL_FORMAT_JPEG : PhotoModule.PIXEL_FORMAT_JPEG);
     }
 
     public void addVideo(String path, long duration, ContentValues values,
diff --git a/src/com/android/camera/PanoCaptureModule.java b/src/com/android/camera/PanoCaptureModule.java
index f4c7624..b0bf78a 100644
--- a/src/com/android/camera/PanoCaptureModule.java
+++ b/src/com/android/camera/PanoCaptureModule.java
@@ -470,7 +470,8 @@ public class PanoCaptureModule implements CameraModule, PhotoController {
             String filename = PanoUtil.createName(
                     mActivity.getResources().getString(R.string.pano_file_name_format), timeTaken);
             String filepath = Storage.generateFilepath(filename,
-                    PhotoModule.PIXEL_FORMAT_JPEG);
+                    CameraUtil.HAS_EXYNOS5CAMERA ? SPhotoModule.PIXEL_FORMAT_JPEG
+                         :PhotoModule.PIXEL_FORMAT_JPEG);
 
             Location loc = mLocationManager.getCurrentLocation();
             ExifInterface exif = new ExifInterface();
diff --git a/src/com/android/camera/PreviewGestures.java b/src/com/android/camera/PreviewGestures.java
index 5d3547d..f0ea778 100644
--- a/src/com/android/camera/PreviewGestures.java
+++ b/src/com/android/camera/PreviewGestures.java
@@ -59,6 +59,8 @@ public class PreviewGestures
     private CaptureUI mCaptureUI;
     private PhotoMenu mPhotoMenu;
     private VideoMenu mVideoMenu;
+    private SPhotoMenu mSPhotoMenu;
+    private SVideoMenu mSVideoMenu;
     private boolean waitUntilNextDown;
     private boolean setToFalse;
 
@@ -98,6 +100,10 @@ public class PreviewGestures
                 orientation = mVideoMenu.getOrientation();
             else if (mCaptureUI != null)
                 orientation = mCaptureUI.getOrientation();
+            else if (mSPhotoMenu != null)
+                orientation = mSPhotoMenu.getOrientation();
+            else if (mSVideoMenu != null)
+                orientation = mSVideoMenu.getOrientation();
 
             if (isLeftSwipe(orientation, deltaX, deltaY)) {
                 waitUntilNextDown = true;
@@ -107,6 +113,10 @@ public class PreviewGestures
                     mVideoMenu.openFirstLevel();
                 else if (mCaptureUI != null)
                     mCaptureUI.openSettingsMenu();
+                else if (mSPhotoMenu != null && !mSPhotoMenu.isMenuBeingShown())
+                    mPhotoMenu.openFirstLevel();
+                else if (mSVideoMenu != null && !mSVideoMenu.isMenuBeingShown())
+                    mSVideoMenu.openFirstLevel();
                 return true;
             }
 
@@ -183,6 +193,22 @@ public class PreviewGestures
         return mVideoMenu;
     }
 
+    public void setSPhotoMenu(SPhotoMenu menu) {
+        mSPhotoMenu = menu;
+    }
+
+    public void setSVideoMenu(SVideoMenu menu) {
+        mSVideoMenu = menu;
+    }
+
+    public SPhotoMenu getSPhotoMenu() {
+        return mSPhotoMenu;
+    }
+
+    public SVideoMenu getSVideoMenu() {
+        return mSVideoMenu;
+    }
+
     public boolean dispatchTouch(MotionEvent m) {
         if (setToFalse) {
             waitUntilNextDown = false;
@@ -254,6 +280,37 @@ public class PreviewGestures
             }
         }
 
+        if (mSPhotoMenu != null) {
+            if (mSPhotoMenu.isMenuBeingShown()) {
+                if (!mSPhotoMenu.isMenuBeingAnimated()) {
+                    waitUntilNextDown = true;
+                    mSPhotoMenu.closeView();
+                }
+                return true;
+            }
+            if (mSPhotoMenu.isPreviewMenuBeingShown()) {
+                waitUntilNextDown = true;
+                mSPhotoMenu.animateSlideOutPreviewMenu();
+                return true;
+            }
+        }
+
+        if (mSVideoMenu != null) {
+            if (mSVideoMenu.isMenuBeingShown()) {
+                if (!mSVideoMenu.isMenuBeingAnimated()) {
+                    waitUntilNextDown = true;
+                    mSVideoMenu.closeView();
+                }
+                return true;
+            }
+
+            if (mSVideoMenu.isPreviewMenuBeingShown()) {
+                waitUntilNextDown = true;
+                mSVideoMenu.animateSlideOutPreviewMenu();
+                return true;
+            }
+        }
+
         // If pie is not open, send touch events to gesture detector and scale
         // listener to recognize the gesture.
         mGestureDetector.onTouchEvent(m);
diff --git a/src/com/android/camera/SPhotoMenu.java b/src/com/android/camera/SPhotoMenu.java
new file mode 100644
index 0000000..0e373d5
--- /dev/null
+++ b/src/com/android/camera/SPhotoMenu.java
@@ -0,0 +1,1237 @@
+/*
+ * Copyright (C) 2012 The Android Open Source Project
+ * Copyright (C) 2013-2015 The CyanogenMod Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.camera;
+
+import java.util.HashSet;
+import java.util.Locale;
+
+import android.animation.Animator;
+import android.animation.Animator.AnimatorListener;
+import android.app.Activity;
+import android.app.AlertDialog;
+import android.content.Context;
+import android.content.DialogInterface;
+import android.content.SharedPreferences;
+import android.content.res.Resources;
+import android.hardware.Camera.Parameters;
+import android.graphics.Rect;
+import android.os.Handler;
+import android.os.Message;
+import android.preference.Preference;
+import android.preference.PreferenceManager;
+import android.text.TextUtils;
+import android.util.Log;
+import android.view.LayoutInflater;
+import android.view.MotionEvent;
+import android.view.View;
+import android.view.View.OnClickListener;
+import android.view.ViewPropertyAnimator;
+import android.widget.ListView;
+import android.widget.Toast;
+import android.widget.TextView;
+import android.widget.GridView;
+import android.widget.ImageView;
+import android.widget.LinearLayout;
+import android.widget.FrameLayout;
+import android.widget.FrameLayout.LayoutParams;
+
+import com.android.camera.CameraPreference.OnPreferenceChangedListener;
+import com.android.camera.app.CameraApp;
+import com.android.camera.ui.CameraControls;
+import com.android.camera.ui.CountdownTimerPopup;
+import com.android.camera.ui.ListSubMenu;
+import com.android.camera.ui.ListMenu;
+import com.android.camera.ui.ModuleSwitcher;
+import com.android.camera.ui.RotateLayout;
+import com.android.camera.ui.RotateImageView;
+import com.android.camera.ui.RotateTextToast;
+import android.widget.HorizontalScrollView;
+import android.view.ViewGroup;
+import android.view.WindowManager;
+import android.view.Display;
+import com.android.camera.util.CameraUtil;
+import java.util.Locale;
+
+import org.codeaurora.snapcam.R;
+import org.codeaurora.snapcam.wrapper.ParametersWrapper;
+
+public class SPhotoMenu extends MenuController
+        implements ListMenu.Listener,
+        CountdownTimerPopup.Listener,
+        ListSubMenu.Listener {
+    private static String TAG = "SPhotoMenu";
+
+    private final String mSettingOff;
+    private final String mSettingOn;
+
+    private String[] mOtherKeys1;
+    private String[] mOtherKeys2;
+    private ListMenu mListMenu;
+    private View mPreviewMenu;
+    private static final int POPUP_NONE = 0;
+    private static final int POPUP_FIRST_LEVEL = 1;
+    private static final int POPUP_SECOND_LEVEL = 2;
+    private static final int POPUP_IN_ANIMATION_SLIDE = 3;
+    private static final int POPUP_IN_ANIMATION_FADE = 4;
+    private static final int PREVIEW_MENU_NONE = 0;
+    private static final int PREVIEW_MENU_IN_ANIMATION = 1;
+    private static final int PREVIEW_MENU_ON = 2;
+    private static final int MODE_SCENE = 0;
+    private static final int MODE_FILTER = 1;
+    private static final int DEVELOPER_MENU_TOUCH_COUNT = 7;
+    private int mSceneStatus;
+    private View mHdrSwitcher;
+    private View mBokehSwitcher;
+    private View mFrontBackSwitcher;
+    private View mSceneModeSwitcher;
+    private View mFilterModeSwitcher;
+    private View mCameraSwitcher;
+    private View mSettingMenu;
+    private View mPreviewThumbnail;
+    private SPhotoUI mUI;
+    private int mPopupStatus;
+    private int mPreviewMenuStatus;
+    private ListSubMenu mListSubMenu;
+    private CameraActivity mActivity;
+    private int mPrivateCounter = 0;
+    private static final int ANIMATION_DURATION = 300;
+    private static final int CLICK_THRESHOLD = 200;
+    private int previewMenuSize;
+    private HashSet<View> mWasVisibleSet = new HashSet<View>();
+
+    public SPhotoMenu(CameraActivity activity, SPhotoUI ui) {
+        super(activity);
+        mUI = ui;
+        mSettingOff = activity.getString(R.string.setting_off_value);
+        mSettingOn = activity.getString(R.string.setting_on_value);
+        mActivity = activity;
+        mFrontBackSwitcher = ui.getRootView().findViewById(R.id.front_back_switcher);
+        mHdrSwitcher = ui.getRootView().findViewById(R.id.hdr_switcher);
+        mSceneModeSwitcher = ui.getRootView().findViewById(R.id.scene_mode_switcher);
+        mBokehSwitcher = ui.getRootView().findViewById(R.id.bokeh_switcher);
+        mFilterModeSwitcher = ui.getRootView().findViewById(R.id.filter_mode_switcher);
+        mSettingMenu = ui.getRootView().findViewById(R.id.menu);
+        mCameraSwitcher = ui.getRootView().findViewById(R.id.camera_switcher);
+        mPreviewThumbnail = ui.getRootView().findViewById(R.id.preview_thumb);
+    }
+
+    public void initialize(PreferenceGroup group) {
+        super.initialize(group);
+        mListSubMenu = null;
+        mListMenu = null;
+        mPopupStatus = POPUP_NONE;
+        mPreviewMenuStatus = POPUP_NONE;
+        final Resources res = mActivity.getResources();
+        Locale locale = res.getConfiguration().locale;
+        // The order is from left to right in the menu.
+
+        initSceneModeButton(mSceneModeSwitcher);
+        initFilterModeButton(mFilterModeSwitcher);
+        initBokehModeButton(mBokehSwitcher);
+
+        mFrontBackSwitcher.setVisibility(View.INVISIBLE);
+
+        if (group.findPreference(CameraSettings.KEY_CAMERA_HDR) != null) {
+            mHdrSwitcher.setVisibility(View.VISIBLE);
+            initSwitchItem(CameraSettings.KEY_CAMERA_HDR, mHdrSwitcher);
+        } else {
+            mHdrSwitcher.setVisibility(View.INVISIBLE);
+        }
+
+        mOtherKeys1 = new String[] {
+                CameraSettings.KEY_SELFIE_FLASH,
+                CameraSettings.KEY_FLASH_MODE,
+                CameraSettings.KEY_RECORD_LOCATION,
+                CameraSettings.KEY_PICTURE_SIZE,
+                CameraSettings.KEY_JPEG_QUALITY,
+                CameraSettings.KEY_TIMER,
+                CameraSettings.KEY_CAMERA_SAVEPATH,
+                CameraSettings.KEY_LONGSHOT,
+                CameraSettings.KEY_FACE_DETECTION,
+                CameraSettings.KEY_FOCUS_TIME,
+                CameraSettings.KEY_SELFIE_MIRROR,
+                CameraSettings.KEY_SHUTTER_SOUND,
+                CameraSettings.KEY_POWER_SHUTTER,
+                CameraSettings.KEY_SATURATION,
+                CameraSettings.KEY_SHARPNESS,
+                CameraSettings.KEY_ANTIBANDING,
+        };
+
+        mOtherKeys2 = new String[] {
+                CameraSettings.KEY_SELFIE_FLASH,
+                CameraSettings.KEY_FLASH_MODE,
+                CameraSettings.KEY_RECORD_LOCATION,
+                CameraSettings.KEY_PICTURE_SIZE,
+                CameraSettings.KEY_JPEG_QUALITY,
+                CameraSettings.KEY_TIMER,
+                CameraSettings.KEY_CAMERA_SAVEPATH,
+                CameraSettings.KEY_LONGSHOT,
+                CameraSettings.KEY_FACE_DETECTION,
+                CameraSettings.KEY_FOCUS_MODE,
+                CameraSettings.KEY_FOCUS_TIME,
+                CameraSettings.KEY_POWER_SHUTTER,
+                CameraSettings.KEY_MAX_BRIGHTNESS,
+                CameraSettings.KEY_SATURATION,
+                CameraSettings.KEY_SHARPNESS,
+                CameraSettings.KEY_ANTIBANDING,
+                CameraSettings.KEY_TIMER_SOUND_EFFECTS,
+                CameraSettings.KEY_FACE_RECOGNITION,
+                CameraSettings.KEY_PICTURE_FORMAT,
+                CameraSettings.KEY_SELFIE_MIRROR,
+                CameraSettings.KEY_SHUTTER_SOUND,
+                CameraSettings.KEY_ZOOM
+        };
+
+        initSwitchItem(CameraSettings.KEY_CAMERA_ID, mFrontBackSwitcher);
+    }
+
+    @Override
+    // Hit when an item in a popup gets selected
+    public void onListPrefChanged(ListPreference pref) {
+        onSettingChanged(pref);
+        closeView();
+    }
+
+    public boolean handleBackKey() {
+        if (mPreviewMenuStatus == PREVIEW_MENU_ON) {
+            animateSlideOut(mPreviewMenu);
+            return true;
+        }
+        if (mPopupStatus == POPUP_NONE)
+            return false;
+        if (mPopupStatus == POPUP_FIRST_LEVEL) {
+            animateSlideOut(mListMenu, 1);
+        } else if (mPopupStatus == POPUP_SECOND_LEVEL) {
+            animateFadeOut(mListSubMenu, 2);
+            ((ListMenu) mListMenu).resetHighlight();
+        }
+        return true;
+    }
+
+    public void closeSceneMode() {
+        mUI.removeSceneModeMenu();
+    }
+
+    public void tryToCloseSubList() {
+        if (mListMenu != null)
+            ((ListMenu) mListMenu).resetHighlight();
+
+        if (mPopupStatus == POPUP_SECOND_LEVEL) {
+            mUI.dismissLevel2();
+            mPopupStatus = POPUP_FIRST_LEVEL;
+        }
+    }
+
+    private void animateFadeOut(final ListView v, final int level) {
+        if (v == null || mPopupStatus == POPUP_IN_ANIMATION_FADE)
+            return;
+        mPopupStatus = POPUP_IN_ANIMATION_FADE;
+
+        ViewPropertyAnimator vp = v.animate();
+        vp.alpha(0f).setDuration(ANIMATION_DURATION);
+        vp.setListener(new AnimatorListener() {
+            @Override
+            public void onAnimationStart(Animator animation) {
+            }
+
+            @Override
+            public void onAnimationRepeat(Animator animation) {
+
+            }
+
+            @Override
+            public void onAnimationEnd(Animator animation) {
+                if (level == 1) {
+                    mUI.dismissLevel1();
+                    initializePopup();
+                    mPopupStatus = POPUP_NONE;
+                    mUI.cleanupListview();
+                }
+                else if (level == 2) {
+                    mUI.dismissLevel2();
+                    mPopupStatus = POPUP_FIRST_LEVEL;
+                }
+            }
+
+            @Override
+            public void onAnimationCancel(Animator animation) {
+                if (level == 1) {
+                    mUI.dismissLevel1();
+                    initializePopup();
+                    mPopupStatus = POPUP_NONE;
+                    mUI.cleanupListview();
+                }
+                else if (level == 2) {
+                    mUI.dismissLevel2();
+                    mPopupStatus = POPUP_FIRST_LEVEL;
+                }
+
+            }
+        });
+        vp.start();
+    }
+
+    private void animateSlideOut(final ListView v, final int level) {
+        if (v == null || mPopupStatus == POPUP_IN_ANIMATION_SLIDE)
+            return;
+        mPopupStatus = POPUP_IN_ANIMATION_SLIDE;
+
+        ViewPropertyAnimator vp = v.animate();
+        if (View.LAYOUT_DIRECTION_RTL == TextUtils
+                .getLayoutDirectionFromLocale(Locale.getDefault())) {
+            switch (mUI.getOrientation()) {
+                case 0:
+                    vp.translationXBy(v.getWidth());
+                    break;
+                case 90:
+                    vp.translationYBy(-2 * v.getHeight());
+                    break;
+                case 180:
+                    vp.translationXBy(-2 * v.getWidth());
+                    break;
+                case 270:
+                    vp.translationYBy(v.getHeight());
+                    break;
+            }
+        } else {
+            switch (mUI.getOrientation()) {
+                case 0:
+                    vp.translationXBy(-v.getWidth());
+                    break;
+                case 90:
+                    vp.translationYBy(2 * v.getHeight());
+                    break;
+                case 180:
+                    vp.translationXBy(2 * v.getWidth());
+                    break;
+                case 270:
+                    vp.translationYBy(-v.getHeight());
+                    break;
+            }
+        }
+        vp.setListener(new AnimatorListener() {
+            @Override
+            public void onAnimationStart(Animator animation) {
+            }
+
+            @Override
+            public void onAnimationRepeat(Animator animation) {
+
+            }
+
+            @Override
+            public void onAnimationEnd(Animator animation) {
+                if (level == 1) {
+                    mUI.dismissLevel1();
+                    initializePopup();
+                    mPopupStatus = POPUP_NONE;
+                    mUI.cleanupListview();
+                } else if (level == 2) {
+                    mUI.dismissLevel2();
+                    mPopupStatus = POPUP_FIRST_LEVEL;
+                }
+            }
+
+            @Override
+            public void onAnimationCancel(Animator animation) {
+                if (level == 1) {
+                    mUI.dismissLevel1();
+                    initializePopup();
+                    mPopupStatus = POPUP_NONE;
+                    mUI.cleanupListview();
+                } else if (level == 2) {
+                    mUI.dismissLevel2();
+                    mPopupStatus = POPUP_FIRST_LEVEL;
+                }
+
+            }
+        });
+        vp.setDuration(ANIMATION_DURATION).start();
+    }
+
+    public void animateFadeIn(final ListView v) {
+        ViewPropertyAnimator vp = v.animate();
+        vp.alpha(1f).setDuration(ANIMATION_DURATION);
+        vp.start();
+    }
+
+    public void animateSlideIn(final View v, int delta, boolean forcePortrait) {
+        int orientation = mUI.getOrientation();
+        if (!forcePortrait)
+            orientation = 0;
+
+        ViewPropertyAnimator vp = v.animate();
+        float dest;
+        if (View.LAYOUT_DIRECTION_RTL == TextUtils
+                .getLayoutDirectionFromLocale(Locale.getDefault())) {
+            switch (orientation) {
+                case 0:
+                    dest = v.getX();
+                    v.setX(-(dest - delta));
+                    vp.translationX(dest);
+                    break;
+                case 90:
+                    dest = v.getY();
+                    v.setY(-(dest + delta));
+                    vp.translationY(dest);
+                    break;
+                case 180:
+                    dest = v.getX();
+                    v.setX(-(dest + delta));
+                    vp.translationX(dest);
+                    break;
+                case 270:
+                    dest = v.getY();
+                    v.setY(-(dest - delta));
+                    vp.translationY(dest);
+                    break;
+            }
+        } else {
+            switch (orientation) {
+                case 0:
+                    dest = v.getX();
+                    v.setX(dest - delta);
+                    vp.translationX(dest);
+                    break;
+                case 90:
+                    dest = v.getY();
+                    v.setY(dest + delta);
+                    vp.translationY(dest);
+                    break;
+                case 180:
+                    dest = v.getX();
+                    v.setX(dest + delta);
+                    vp.translationX(dest);
+                    break;
+                case 270:
+                    dest = v.getY();
+                    v.setY(dest - delta);
+                    vp.translationY(dest);
+                    break;
+            }
+        }
+        vp.setDuration(ANIMATION_DURATION).start();
+    }
+
+    public void animateSlideOutPreviewMenu() {
+        if (mPreviewMenu == null)
+            return;
+        animateSlideOut(mPreviewMenu);
+    }
+
+    private void animateSlideOut(final View v) {
+        if (v == null || mPreviewMenuStatus == PREVIEW_MENU_IN_ANIMATION)
+            return;
+        mPreviewMenuStatus = PREVIEW_MENU_IN_ANIMATION;
+
+        ViewPropertyAnimator vp = v.animate();
+        if (View.LAYOUT_DIRECTION_RTL == TextUtils
+                .getLayoutDirectionFromLocale(Locale.getDefault())) {
+            vp.translationXBy(v.getWidth()).setDuration(ANIMATION_DURATION);
+        } else {
+            vp.translationXBy(-v.getWidth()).setDuration(ANIMATION_DURATION);
+        }
+        vp.setListener(new AnimatorListener() {
+            @Override
+            public void onAnimationStart(Animator animation) {
+            }
+
+            @Override
+            public void onAnimationRepeat(Animator animation) {
+
+            }
+
+            @Override
+            public void onAnimationEnd(Animator animation) {
+                closeSceneMode();
+                mPreviewMenuStatus = PREVIEW_MENU_NONE;
+            }
+
+            @Override
+            public void onAnimationCancel(Animator animation) {
+                closeSceneMode();
+                mPreviewMenuStatus = PREVIEW_MENU_NONE;
+
+            }
+        });
+        vp.start();
+    }
+
+    private void buttonSetEnabled(View v, boolean enable) {
+        v.setEnabled(enable);
+        if (v instanceof ViewGroup) {
+            View v2 = ((ViewGroup) v).getChildAt(0);
+            if (v2 != null)
+                v2.setEnabled(enable);
+        }
+    }
+
+    public boolean isOverMenu(MotionEvent ev) {
+        if (mPopupStatus == POPUP_NONE
+                || mPopupStatus == POPUP_IN_ANIMATION_SLIDE
+                || mPopupStatus == POPUP_IN_ANIMATION_FADE)
+            return false;
+        if (mUI.getMenuLayout() == null)
+            return false;
+        Rect rec = new Rect();
+        mUI.getMenuLayout().getChildAt(0).getHitRect(rec);
+        return rec.contains((int) ev.getX(), (int) ev.getY());
+    }
+
+    public boolean isOverPreviewMenu(MotionEvent ev) {
+        if (mPreviewMenuStatus != PREVIEW_MENU_ON)
+            return false;
+        if (mUI.getPreviewMenuLayout() == null)
+            return false;
+        Rect rec = new Rect();
+        mUI.getPreviewMenuLayout().getChildAt(0).getHitRect(rec);
+        if (View.LAYOUT_DIRECTION_RTL == TextUtils
+                .getLayoutDirectionFromLocale(Locale.getDefault())) {
+            rec.left = mUI.getRootView().getWidth() - (rec.right-rec.left);
+            rec.right = mUI.getRootView().getWidth();
+        }
+        rec.top += (int) mUI.getPreviewMenuLayout().getY();
+        rec.bottom += (int) mUI.getPreviewMenuLayout().getY();
+        return rec.contains((int) ev.getX(), (int) ev.getY());
+    }
+
+    public boolean isMenuBeingShown() {
+        return mPopupStatus != POPUP_NONE;
+    }
+
+    public boolean isMenuBeingAnimated() {
+        return mPopupStatus == POPUP_IN_ANIMATION_SLIDE || mPopupStatus == POPUP_IN_ANIMATION_FADE;
+    }
+
+    public boolean isPreviewMenuBeingShown() {
+        return mPreviewMenuStatus == PREVIEW_MENU_ON;
+    }
+
+    public boolean isPreviewMenuBeingAnimated() {
+        return mPreviewMenuStatus == PREVIEW_MENU_IN_ANIMATION;
+    }
+
+    public boolean sendTouchToPreviewMenu(MotionEvent ev) {
+        return mUI.sendTouchToPreviewMenu(ev);
+    }
+
+    public boolean sendTouchToMenu(MotionEvent ev) {
+        return mUI.sendTouchToMenu(ev);
+    }
+
+    @Override
+    public void overrideSettings(final String... keyvalues) {
+        for (int i = 0; i < keyvalues.length; i += 2) {
+            if (keyvalues[i].equals(CameraSettings.KEY_SCENE_MODE)) {
+                buttonSetEnabled(mSceneModeSwitcher, keyvalues[i + 1] == null);
+            }
+        }
+        super.overrideSettings(keyvalues);
+        if ((mListMenu == null))
+            initializePopup();
+        mListMenu.overrideSettings(keyvalues);
+    }
+
+    protected void initializePopup() {
+        LayoutInflater inflater = (LayoutInflater) mActivity.getSystemService(
+                Context.LAYOUT_INFLATER_SERVICE);
+        ListMenu popup1 = (ListMenu) inflater.inflate(
+                R.layout.list_menu, null, false);
+
+        popup1.setSettingChangedListener(this);
+
+        String[] keys = mOtherKeys1;
+        if (mActivity.isDeveloperMenuEnabled())
+            keys = mOtherKeys2;
+        popup1.initialize(mPreferenceGroup, keys);
+        if (mActivity.isSecureCamera()) {
+            // Prevent location preference from getting changed in secure camera
+            // mode
+            popup1.setPreferenceEnabled(CameraSettings.KEY_RECORD_LOCATION, false);
+        }
+        mListMenu = popup1;
+
+        ListPreference pref = mPreferenceGroup.findPreference(
+                CameraSettings.KEY_SCENE_MODE);
+        updateFilterModeIcon(pref, mPreferenceGroup.findPreference(CameraSettings.KEY_CAMERA_HDR));
+        String sceneMode = (pref != null) ? pref.getValue() : null;
+        pref = mPreferenceGroup.findPreference(CameraSettings.KEY_FACE_DETECTION);
+        String faceDetection = (pref != null) ? pref.getValue() : null;
+        if ((sceneMode != null) && !Parameters.SCENE_MODE_AUTO.equals(sceneMode)) {
+            popup1.setPreferenceEnabled(CameraSettings.KEY_FOCUS_MODE, false);
+            popup1.setPreferenceEnabled(CameraSettings.KEY_SATURATION, false);
+            popup1.setPreferenceEnabled(CameraSettings.KEY_SHARPNESS, false);
+            popup1.setPreferenceEnabled(CameraSettings.KEY_COLOR_EFFECT, false);
+            popup1.setPreferenceEnabled(CameraSettings.KEY_FLASH_MODE, false);
+        }
+
+        if ((faceDetection != null) && !ParametersWrapper.FACE_DETECTION_ON.equals(faceDetection)) {
+            popup1.setPreferenceEnabled(CameraSettings.KEY_FACE_RECOGNITION, false);
+        }
+
+        if (mHdrSwitcher.getVisibility() == View.VISIBLE) {
+            buttonSetEnabled(mHdrSwitcher, true);
+        }
+
+        mHdrSwitcher.setVisibility(View.VISIBLE);
+
+        pref = mPreferenceGroup.findPreference(CameraSettings.KEY_BOKEH_MODE);
+        String bokeh = (pref != null) ? pref.getValue() : null;
+        if ("1".equals(bokeh)) {
+            buttonSetEnabled(mHdrSwitcher,false);
+            buttonSetEnabled(mSceneModeSwitcher,false);
+            buttonSetEnabled(mFilterModeSwitcher,false);
+            popup1.setPreferenceEnabled(CameraSettings.KEY_SCENE_MODE,false);
+            popup1.setPreferenceEnabled(CameraSettings.KEY_CAMERA_HDR,false);
+            popup1.setPreferenceEnabled(CameraSettings.KEY_FLASH_MODE,false);
+            popup1.setPreferenceEnabled(CameraSettings.KEY_LONGSHOT,false);
+            popup1.setPreferenceEnabled(CameraSettings.KEY_COLOR_EFFECT,false);
+            popup1.setPreferenceEnabled(CameraSettings.KEY_PICTURE_SIZE,false);
+
+            setPreference(CameraSettings.KEY_SCENE_MODE,
+                    mActivity.getString(R.string.pref_camera_scenemode_default));
+            setPreference(CameraSettings.KEY_CAMERA_HDR,"off");
+            setPreference(CameraSettings.KEY_FLASH_MODE, "off");
+            setPreference(CameraSettings.KEY_LONGSHOT, "off");
+            setPreference(CameraSettings.KEY_COLOR_EFFECT,"none");
+            ListPreference picSize =
+                    mPreferenceGroup.findPreference(CameraSettings.KEY_PICTURE_SIZE);
+            CharSequence maxSize = picSize.getEntryValues()[0];
+            if (maxSize != null) {
+                setPreference(CameraSettings.KEY_PICTURE_SIZE,maxSize.toString());
+            }
+        }
+
+        if (mListener != null) {
+            mListener.onSharedPreferenceChanged();
+        }
+    }
+
+    private void updateFilterModeIcon(ListPreference scenePref, ListPreference hdrPref) {
+        if (scenePref == null || hdrPref == null) return;
+        if ((notSame(scenePref, CameraSettings.KEY_SCENE_MODE, Parameters.SCENE_MODE_AUTO))
+                || (notSame(hdrPref, CameraSettings.KEY_CAMERA_HDR, mSettingOff))) {
+            buttonSetEnabled(mFilterModeSwitcher, false);
+            changeFilterModeControlIcon("none");
+        } else if (same(scenePref, CameraSettings.KEY_SCENE_MODE, Parameters.SCENE_MODE_AUTO)
+                && (same(hdrPref, CameraSettings.KEY_CAMERA_HDR, mSettingOff)
+                    || !hdrPref.getKey().equals(CameraSettings.KEY_CAMERA_HDR))) {
+            //mFilterModeSwitcher can be enabled only when scene mode is set to auto
+            // and HDR is set to off,
+            buttonSetEnabled(mFilterModeSwitcher, true);
+        }
+    }
+
+    public void initSwitchItem(final String prefKey, View switcher) {
+        final IconListPreference pref =
+                (IconListPreference) mPreferenceGroup.findPreference(prefKey);
+        if (pref == null)
+            return;
+
+        int[] iconIds = pref.getLargeIconIds();
+        int resid = -1;
+        int index = pref.findIndexOfValue(pref.getValue());
+        if (!pref.getUseSingleIcon() && iconIds != null) {
+            // Each entry has a corresponding icon.
+            index = index % iconIds.length;
+            resid = iconIds[index];
+        } else {
+            // The preference only has a single icon to represent it.
+            resid = pref.getSingleIcon();
+        }
+        ((ImageView) switcher).setImageResource(resid);
+        switcher.setVisibility(View.VISIBLE);
+        mPreferences.add(pref);
+        mPreferenceMap.put(pref, switcher);
+        switcher.setOnClickListener(new OnClickListener() {
+            @Override
+            public void onClick(View v) {
+                IconListPreference pref = (IconListPreference) mPreferenceGroup
+                        .findPreference(prefKey);
+                if (pref == null)
+                    return;
+                if (prefKey.equals(CameraSettings.KEY_CAMERA_ID)) {
+                    // Hide the camera control while switching the camera.
+                    // The camera control will be added back when
+                    // onCameraPickerClicked is completed
+                    mUI.hideUI();
+                }
+                int index = pref.findIndexOfValue(pref.getValue());
+                CharSequence[] values = pref.getEntryValues();
+                index = (index + 1) % values.length;
+                pref.setValueIndex(index);
+                int iconListLength = ((IconListPreference) pref).getLargeIconIds().length;
+                ((ImageView) v).setImageResource(
+                        ((IconListPreference) pref).getLargeIconIds()[index % iconListLength]);
+                if (prefKey.equals(CameraSettings.KEY_CAMERA_ID))
+                    mListener.onCameraPickerClicked(index);
+                reloadPreference(pref);
+                onSettingChanged(pref);
+            }
+        });
+    }
+
+    public void initBokehModeButton(View button) {
+        button.setVisibility(View.INVISIBLE);
+        final IconListPreference pref = (IconListPreference) mPreferenceGroup.findPreference(
+                CameraSettings.KEY_BOKEH_MODE);
+        if (pref == null) {
+            button.setVisibility(View.GONE);
+            return;
+        }
+
+        int[] iconIds = pref.getLargeIconIds();
+        int resid = -1;
+        int index = pref.findIndexOfValue(pref.getValue());
+        if (!pref.getUseSingleIcon() && iconIds != null) {
+            resid = iconIds[index];
+        } else {
+            resid = pref.getSingleIcon();
+        }
+        ImageView iv = (ImageView) button;
+        iv.setImageResource(resid);
+
+        button.setVisibility(View.VISIBLE);
+
+        button.setOnClickListener(new OnClickListener() {
+            @Override
+            public void onClick(View v) {
+                ListPreference bokehPref =
+                        mPreferenceGroup.findPreference(CameraSettings.KEY_BOKEH_MODE);
+                String bokeh = (bokehPref != null) ? bokehPref.getValue() : null;
+                if (bokeh != null) {
+                    CharSequence[] values = bokehPref.getEntryValues();
+                    int index = (bokehPref.getCurrentIndex() + 1) % values.length;
+                    bokehPref.setValueIndex(index);
+                    ((ImageView) v).setImageResource(
+                            ((IconListPreference) pref).getLargeIconIds()[index]);
+                    reloadPreference(pref);
+                    initializePopup();
+                    onSettingChanged(bokehPref);
+                } else {
+
+                }
+            }
+        });
+    }
+
+    public void initSceneModeButton(View button) {
+        button.setVisibility(View.INVISIBLE);
+        final IconListPreference pref = (IconListPreference) mPreferenceGroup
+                .findPreference(CameraSettings.KEY_SCENE_MODE);
+        if (pref == null)
+            return;
+        updateSceneModeIcon(pref);
+        button.setVisibility(View.VISIBLE);
+        button.setOnClickListener(new OnClickListener() {
+            @Override
+            public void onClick(View v) {
+                addSceneMode();
+                ViewGroup menuLayout = mUI.getPreviewMenuLayout();
+                if (menuLayout != null) {
+                    View view = menuLayout.getChildAt(0);
+                    mUI.adjustOrientation();
+                    animateSlideIn(view, previewMenuSize, false);
+                }
+            }
+        });
+    }
+
+    public void addModeBack() {
+        if (mSceneStatus == MODE_SCENE) {
+            addSceneMode();
+        }
+        if (mSceneStatus == MODE_FILTER) {
+            addFilterMode();
+        }
+    }
+
+    public void addSceneMode() {
+        final IconListPreference pref = (IconListPreference) mPreferenceGroup
+                .findPreference(CameraSettings.KEY_SCENE_MODE);
+        if (pref == null)
+            return;
+
+        int rotation = CameraUtil.getDisplayRotation(mActivity);
+        boolean mIsDefaultToPortrait = CameraUtil.isDefaultToPortrait(mActivity);
+        if (!mIsDefaultToPortrait) {
+            rotation = (rotation + 90) % 360;
+        }
+        WindowManager wm = (WindowManager) mActivity.getSystemService(Context.WINDOW_SERVICE);
+        Display display = wm.getDefaultDisplay();
+
+        CharSequence[] entries = pref.getEntries();
+        CharSequence[] entryValues = pref.getEntryValues();
+
+        int[] thumbnails = pref.getThumbnailIds();
+
+        Resources r = mActivity.getResources();
+        int height = (int) (r.getDimension(R.dimen.scene_mode_height) + 2
+                * r.getDimension(R.dimen.scene_mode_padding) + 1);
+        int width = (int) (r.getDimension(R.dimen.scene_mode_width) + 2
+                * r.getDimension(R.dimen.scene_mode_padding) + 1);
+
+        int gridRes = 0;
+        boolean portrait = (rotation == 0) || (rotation == 180);
+        int size = height;
+        if (portrait) {
+            gridRes = R.layout.vertical_grid;
+            size = width;
+        } else {
+            gridRes = R.layout.horiz_grid;
+        }
+        previewMenuSize = size;
+        mUI.hideUI();
+        mPreviewMenuStatus = PREVIEW_MENU_ON;
+        mSceneStatus = MODE_SCENE;
+
+        LayoutInflater inflater = (LayoutInflater) mActivity.getSystemService(
+                Context.LAYOUT_INFLATER_SERVICE);
+        FrameLayout basic = (FrameLayout) inflater.inflate(
+                gridRes, null, false);
+
+        mUI.dismissSceneModeMenu();
+        LinearLayout previewMenuLayout = new LinearLayout(mActivity);
+        mUI.setPreviewMenuLayout(previewMenuLayout);
+        ViewGroup.LayoutParams params = null;
+        if (portrait) {
+            params = new ViewGroup.LayoutParams(size, LayoutParams.MATCH_PARENT);
+            previewMenuLayout.setLayoutParams(params);
+            ((ViewGroup) mUI.getRootView()).addView(previewMenuLayout);
+        } else {
+            params = new ViewGroup.LayoutParams(LayoutParams.MATCH_PARENT, size);
+            previewMenuLayout.setLayoutParams(params);
+            ((ViewGroup) mUI.getRootView()).addView(previewMenuLayout);
+            previewMenuLayout.setY(display.getHeight() - size);
+        }
+        basic.setLayoutParams(new FrameLayout.LayoutParams(LayoutParams.MATCH_PARENT,
+                LayoutParams.MATCH_PARENT));
+        LinearLayout layout = (LinearLayout) basic.findViewById(R.id.layout);
+
+        final View[] views = new View[entries.length];
+        int init = pref.getCurrentIndex();
+        for (int i = 0; i < entries.length; i++) {
+            RotateLayout layout2 = (RotateLayout) inflater.inflate(
+                    R.layout.scene_mode_view, null, false);
+
+            ImageView imageView = (ImageView) layout2.findViewById(R.id.image);
+            TextView label = (TextView) layout2.findViewById(R.id.label);
+            final int j = i;
+
+            layout2.setOnTouchListener(new View.OnTouchListener() {
+                private long startTime;
+
+                @Override
+                public boolean onTouch(View v, MotionEvent event) {
+                    if (event.getAction() == MotionEvent.ACTION_DOWN) {
+                        startTime = System.currentTimeMillis();
+                    } else if (event.getAction() == MotionEvent.ACTION_UP) {
+                        if (System.currentTimeMillis() - startTime < CLICK_THRESHOLD) {
+                            pref.setValueIndex(j);
+                            onSettingChanged(pref);
+                            updateSceneModeIcon(pref);
+                            for (View v1 : views) {
+                                v1.setActivated(v1 == v);
+                            }
+                        }
+
+                    }
+                    return true;
+                }
+            });
+
+            views[j] = layout2;
+            layout2.setActivated(i == init);
+            imageView.setImageResource(thumbnails[i]);
+            label.setText(entries[i]);
+            layout.addView(layout2);
+        }
+        previewMenuLayout.addView(basic);
+        mPreviewMenu = basic;
+    }
+
+    public void updateSceneModeIcon(IconListPreference pref) {
+        int[] thumbnails = pref.getThumbnailIds();
+        int ind = pref.getCurrentIndex();
+        if (ind == -1)
+            ind = 0;
+        ((ImageView) mSceneModeSwitcher).setImageResource(thumbnails[ind]);
+    }
+
+    public void initFilterModeButton(View button) {
+        button.setVisibility(View.INVISIBLE);
+        final IconListPreference pref = (IconListPreference) mPreferenceGroup
+                .findPreference(CameraSettings.KEY_COLOR_EFFECT);
+        if (pref == null || pref.getValue() == null)
+            return;
+        changeFilterModeControlIcon(pref.getValue());
+        button.setVisibility(View.VISIBLE);
+        button.setOnClickListener(new OnClickListener() {
+            @Override
+            public void onClick(View v) {
+                addFilterMode();
+                ViewGroup menuLayout = mUI.getPreviewMenuLayout();
+                if (menuLayout != null) {
+                    View view = mUI.getPreviewMenuLayout().getChildAt(0);
+                    mUI.adjustOrientation();
+                    animateSlideIn(view, previewMenuSize, false);
+                }
+            }
+        });
+    }
+
+    public void addFilterMode() {
+        final IconListPreference pref = (IconListPreference) mPreferenceGroup
+                .findPreference(CameraSettings.KEY_COLOR_EFFECT);
+        if (pref == null)
+            return;
+
+        int rotation = CameraUtil.getDisplayRotation(mActivity);
+        boolean mIsDefaultToPortrait = CameraUtil.isDefaultToPortrait(mActivity);
+        if (!mIsDefaultToPortrait) {
+            rotation = (rotation + 90) % 360;
+        }
+        WindowManager wm = (WindowManager) mActivity.getSystemService(Context.WINDOW_SERVICE);
+        Display display = wm.getDefaultDisplay();
+        CharSequence[] entries = pref.getEntries();
+
+        Resources r = mActivity.getResources();
+        int height = (int) (r.getDimension(R.dimen.filter_mode_height) + 2
+                * r.getDimension(R.dimen.filter_mode_padding) + 1);
+        int width = (int) (r.getDimension(R.dimen.filter_mode_width) + 2
+                * r.getDimension(R.dimen.filter_mode_padding) + 1);
+
+        int gridRes = 0;
+        boolean portrait = (rotation == 0) || (rotation == 180);
+        int size = height;
+        if (portrait) {
+            gridRes = R.layout.vertical_grid;
+            size = width;
+        } else {
+            gridRes = R.layout.horiz_grid;
+        }
+        previewMenuSize = size;
+        mUI.hideUI();
+        mPreviewMenuStatus = PREVIEW_MENU_ON;
+        mSceneStatus = MODE_FILTER;
+
+        int[] thumbnails = pref.getThumbnailIds();
+
+        LayoutInflater inflater = (LayoutInflater) mActivity.getSystemService(
+                Context.LAYOUT_INFLATER_SERVICE);
+        FrameLayout basic = (FrameLayout) inflater.inflate(
+                gridRes, null, false);
+
+        mUI.dismissSceneModeMenu();
+        LinearLayout previewMenuLayout = new LinearLayout(mActivity);
+        mUI.setPreviewMenuLayout(previewMenuLayout);
+        ViewGroup.LayoutParams params = null;
+        if (portrait) {
+            params = new ViewGroup.LayoutParams(size, LayoutParams.MATCH_PARENT);
+            previewMenuLayout.setLayoutParams(params);
+            ((ViewGroup) mUI.getRootView()).addView(previewMenuLayout);
+        } else {
+            params = new ViewGroup.LayoutParams(LayoutParams.MATCH_PARENT, size);
+            previewMenuLayout.setLayoutParams(params);
+            ((ViewGroup) mUI.getRootView()).addView(previewMenuLayout);
+            previewMenuLayout.setY(display.getHeight() - size);
+        }
+        basic.setLayoutParams(new FrameLayout.LayoutParams(LayoutParams.MATCH_PARENT,
+                LayoutParams.MATCH_PARENT));
+        LinearLayout layout = (LinearLayout) basic.findViewById(R.id.layout);
+        final View[] views = new View[entries.length];
+        int init = pref.getCurrentIndex();
+        for (int i = 0; i < entries.length; i++) {
+            RotateLayout layout2 = (RotateLayout) inflater.inflate(
+                    R.layout.filter_mode_view, null, false);
+            ImageView imageView = (ImageView) layout2.findViewById(R.id.image);
+            final int j = i;
+
+            layout2.setOnTouchListener(new View.OnTouchListener() {
+                private long startTime;
+
+                @Override
+                public boolean onTouch(View v, MotionEvent event) {
+                    if (event.getAction() == MotionEvent.ACTION_DOWN) {
+                        startTime = System.currentTimeMillis();
+                    } else if (event.getAction() == MotionEvent.ACTION_UP) {
+                        if (System.currentTimeMillis() - startTime < CLICK_THRESHOLD) {
+                            pref.setValueIndex(j);
+                            changeFilterModeControlIcon(pref.getValue());
+                            onSettingChanged(pref);
+                            for (View v1 : views) {
+                                v1.setActivated(v1 == v);
+                            }
+                        }
+                    }
+                    return true;
+                }
+            });
+
+            views[j] = layout2;
+            layout2.setActivated(i == init);
+            TextView label = (TextView) layout2.findViewById(R.id.label);
+            imageView.setImageResource(thumbnails[i]);
+            label.setText(entries[i]);
+            layout.addView(layout2);
+        }
+        previewMenuLayout.addView(basic);
+        mPreviewMenu = basic;
+    }
+
+    private void changeFilterModeControlIcon(String value) {
+        if(!value.equals("")) {
+            if(value.equalsIgnoreCase("none")) {
+                value = "Off";
+            } else {
+                value = "On";
+            }
+            final IconListPreference pref = (IconListPreference) mPreferenceGroup
+                    .findPreference(CameraSettings.KEY_FILTER_MODE);
+            pref.setValue(value);
+            int index = pref.getCurrentIndex();
+            ImageView iv = (ImageView) mFilterModeSwitcher;
+            iv.setImageResource(((IconListPreference) pref).getLargeIconIds()[index]);
+        }
+    }
+
+    public void openFirstLevel() {
+        if (isMenuBeingShown() || CameraControls.isAnimating()) {
+            return;
+        }
+        if (mListMenu == null || mPopupStatus != POPUP_FIRST_LEVEL) {
+            initializePopup();
+            mPopupStatus = POPUP_FIRST_LEVEL;
+        }
+        mUI.showPopup(mListMenu, 1, true);
+    }
+
+    public void popupDismissed(boolean dismissAll) {
+        if (!dismissAll && mPopupStatus == POPUP_SECOND_LEVEL) {
+            initializePopup();
+            mPopupStatus = POPUP_FIRST_LEVEL;
+            mUI.showPopup(mListMenu, 1, false);
+            if (mListMenu != null)
+                mListMenu = null;
+
+        } else {
+            initializePopup();
+        }
+
+    }
+
+    @Override
+    // Hit when an item in the first-level popup gets selected, then bring up
+    // the second-level popup
+    public void onPreferenceClicked(ListPreference pref) {
+        onPreferenceClicked(pref, 0);
+    }
+
+    public void onPreferenceClicked(ListPreference pref, int y) {
+        LayoutInflater inflater = (LayoutInflater) mActivity.getSystemService(
+                Context.LAYOUT_INFLATER_SERVICE);
+        ListSubMenu basic = (ListSubMenu) inflater.inflate(
+                R.layout.list_sub_menu, null, false);
+        basic.initialize(pref, y);
+        basic.setSettingChangedListener(this);
+        basic.setAlpha(0f);
+        mListSubMenu = basic;
+        mUI.removeLevel2();
+        if (mPopupStatus == POPUP_SECOND_LEVEL) {
+            mUI.showPopup(mListSubMenu, 2, false);
+        } else {
+            mUI.showPopup(mListSubMenu, 2, true);
+        }
+        mPopupStatus = POPUP_SECOND_LEVEL;
+
+        // Developer menu
+        if (pref.getKey().equals(CameraSettings.KEY_MAX_BRIGHTNESS)) {
+            mPrivateCounter++;
+            if (mPrivateCounter >= DEVELOPER_MENU_TOUCH_COUNT) {
+                SharedPreferences prefs = PreferenceManager
+                        .getDefaultSharedPreferences(mActivity);
+                if (!mActivity.isDeveloperMenuEnabled()) {
+                    mActivity.enableDeveloperMenu();
+                    prefs.edit().putBoolean(CameraSettings.KEY_DEVELOPER_MENU, true).apply();
+                    closeAllView();
+                    RotateTextToast.makeText(mActivity,
+                            R.string.developer_menu_enabled, Toast.LENGTH_SHORT).show();
+                } else {
+                    mActivity.disableDeveloperMenu();
+                    prefs.edit().putBoolean(CameraSettings.KEY_DEVELOPER_MENU, false).apply();
+                    closeAllView();
+                    RotateTextToast.makeText(mActivity,
+                            R.string.developer_menu_disabled, Toast.LENGTH_SHORT).show();
+                }
+                mPrivateCounter = 0;
+            }
+        } else {
+            mPrivateCounter = 0;
+        }
+    }
+
+    public void onListMenuTouched() {
+        mUI.removeLevel2();
+        mPopupStatus = POPUP_FIRST_LEVEL;
+    }
+
+    public void removeAllView() {
+        if (mUI != null)
+            mUI.removeLevel2();
+
+        if (mListMenu != null) {
+            mUI.dismissLevel1();
+            mPopupStatus = POPUP_NONE;
+        }
+        closeSceneMode();
+        mPreviewMenuStatus = PREVIEW_MENU_NONE;
+    }
+
+    public void closeAllView() {
+        if (mUI != null)
+            mUI.removeLevel2();
+
+        if (mListMenu != null) {
+            animateSlideOut(mListMenu, 1);
+        }
+        animateSlideOutPreviewMenu();
+    }
+
+    public void closeView() {
+        if (mUI != null)
+            mUI.removeLevel2();
+
+        if (mListMenu != null && mPopupStatus != POPUP_NONE)
+            animateSlideOut(mListMenu, 1);
+    }
+
+    // Return true if the preference has the specified key but not the value.
+    private static boolean notSame(ListPreference pref, String key, String value) {
+        return (key.equals(pref.getKey()) && !value.equals(pref.getValue()));
+    }
+
+    // Return true if the preference has the specified key and the value.
+    private static boolean same(ListPreference pref, String key, String value) {
+        return (key.equals(pref.getKey()) && value.equals(pref.getValue()));
+    }
+
+    public void setPreference(String key, String value) {
+        ListPreference pref = mPreferenceGroup.findPreference(key);
+        if (pref != null && !value.equals(pref.getValue())) {
+            pref.setValue(value);
+            reloadPreferences();
+        }
+    }
+
+    @Override
+    public void onSettingChanged(ListPreference pref) {
+        // Reset the scene mode if HDR is set to on. Reset HDR if scene mode is
+        // set to non-auto.
+        if (same(pref, CameraSettings.KEY_SCENE_MODE, Parameters.SCENE_MODE_HDR)) {
+            ListPreference hdrPref =
+                    mPreferenceGroup.findPreference(CameraSettings.KEY_CAMERA_HDR);
+            if (hdrPref != null && same(hdrPref, CameraSettings.KEY_CAMERA_HDR, mSettingOff)) {
+                setPreference(CameraSettings.KEY_CAMERA_HDR, mSettingOn);
+            }
+        } else if (notSame(pref, CameraSettings.KEY_SCENE_MODE, Parameters.SCENE_MODE_HDR)) {
+            ListPreference hdrPref =
+                    mPreferenceGroup.findPreference(CameraSettings.KEY_CAMERA_HDR);
+            if (hdrPref != null && notSame(hdrPref, CameraSettings.KEY_CAMERA_HDR, mSettingOff)) {
+                setPreference(CameraSettings.KEY_CAMERA_HDR, mSettingOff);
+            }
+        } else if (same(pref, CameraSettings.KEY_CAMERA_HDR, mSettingOff)) {
+            ListPreference scenePref =
+                    mPreferenceGroup.findPreference(CameraSettings.KEY_SCENE_MODE);
+            if (scenePref != null && notSame(scenePref, CameraSettings.KEY_SCENE_MODE, Parameters.SCENE_MODE_AUTO)) {
+                setPreference(CameraSettings.KEY_SCENE_MODE, Parameters.SCENE_MODE_AUTO);
+            }
+            updateSceneModeIcon((IconListPreference) scenePref);
+            updateFilterModeIcon(scenePref, pref);
+        } else if (same(pref, CameraSettings.KEY_CAMERA_HDR, mSettingOn)) {
+            ListPreference scenePref =
+                    mPreferenceGroup.findPreference(CameraSettings.KEY_SCENE_MODE);
+            if (scenePref != null && notSame(scenePref, CameraSettings.KEY_SCENE_MODE, Parameters.SCENE_MODE_HDR)) {
+                setPreference(CameraSettings.KEY_SCENE_MODE, Parameters.SCENE_MODE_HDR);
+            }
+            updateSceneModeIcon((IconListPreference) scenePref);
+        }
+
+        if (notSame(pref, CameraSettings.KEY_SCENE_MODE, "auto")) {
+            setPreference(CameraSettings.KEY_COLOR_EFFECT,
+                    mActivity.getString(R.string.pref_camera_coloreffect_default));
+        }
+
+        mHdrSwitcher.setVisibility(View.VISIBLE);
+
+        ListPreference hdrPref = mPreferenceGroup.findPreference(CameraSettings.KEY_CAMERA_HDR);
+        ListPreference scenePref = mPreferenceGroup.findPreference(CameraSettings.KEY_SCENE_MODE);
+        updateFilterModeIcon(scenePref, hdrPref);
+
+        if (same(pref, CameraSettings.KEY_RECORD_LOCATION, "on")) {
+            mActivity.requestLocationPermission();
+        }
+
+        if (same(pref, CameraSettings.KEY_BOKEH_MODE, "1")) {
+            ListPreference scene =
+                    mPreferenceGroup.findPreference(CameraSettings.KEY_SCENE_MODE);
+            updateSceneModeIcon((IconListPreference)scene);
+            changeFilterModeControlIcon("none");
+            buttonSetEnabled(mHdrSwitcher,false);
+            buttonSetEnabled(mSceneModeSwitcher,false);
+            buttonSetEnabled(mFilterModeSwitcher,false);
+        }
+        super.onSettingChanged(pref);
+    }
+
+    public int getOrientation() {
+        return mUI == null ? 0 : mUI.getOrientation();
+    }
+
+    public void hideTopMenu(boolean hide) {
+        if (hide) {
+            mSceneModeSwitcher.setVisibility(View.GONE);
+            mFilterModeSwitcher.setVisibility(View.GONE);
+            mFrontBackSwitcher.setVisibility(View.GONE);
+        } else {
+            mSceneModeSwitcher.setVisibility(View.VISIBLE);
+            mFilterModeSwitcher.setVisibility(View.VISIBLE);
+            mFrontBackSwitcher.setVisibility(View.VISIBLE);
+        }
+    }
+
+    public void hideCameraControls(boolean hide) {
+        final int status = (hide) ? View.INVISIBLE : View.VISIBLE;
+        mSettingMenu.setVisibility(status);
+        mFrontBackSwitcher.setVisibility(status);
+        mHdrSwitcher.setVisibility(status);
+        mSceneModeSwitcher.setVisibility(status);
+        mFilterModeSwitcher.setVisibility(status);
+        if(status == View.INVISIBLE) {
+            if(mCameraSwitcher.getVisibility() == View.VISIBLE) {
+                mWasVisibleSet.add(mCameraSwitcher);
+            }
+            mCameraSwitcher.setVisibility(status);
+        } else {
+            if(mWasVisibleSet.contains(mCameraSwitcher)) {
+                mCameraSwitcher.setVisibility(status);
+                mWasVisibleSet.remove(mCameraSwitcher);
+            }
+        }
+        mPreviewThumbnail.setVisibility(status);
+    }
+}
diff --git a/src/com/android/camera/SPhotoModule.java b/src/com/android/camera/SPhotoModule.java
new file mode 100644
index 0000000..b586028
--- /dev/null
+++ b/src/com/android/camera/SPhotoModule.java
@@ -0,0 +1,3922 @@
+/*
+ * Copyright (C) 2012 The Android Open Source Project
+ * Copyright (C) 2013-2015 The CyanogenMod Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.camera;
+
+import android.Manifest;
+import android.annotation.TargetApi;
+import android.app.Activity;
+import android.content.ContentResolver;
+import android.content.Context;
+import android.content.Intent;
+import android.content.SharedPreferences;
+import android.content.SharedPreferences.Editor;
+import android.content.pm.PackageManager;
+import android.content.res.Configuration;
+import android.graphics.Bitmap;
+import android.graphics.BitmapFactory;
+import android.graphics.Matrix;
+import android.graphics.Point;
+import android.graphics.Rect;
+import android.graphics.drawable.BitmapDrawable;
+import android.hardware.Camera.CameraInfo;
+import android.hardware.Camera.Parameters;
+import android.hardware.Camera.Size;
+import android.hardware.Camera;
+import android.hardware.Sensor;
+import android.hardware.SensorEvent;
+import android.hardware.SensorEventListener;
+import android.hardware.SensorManager;
+import android.location.Location;
+import android.media.AudioManager;
+import android.media.CameraProfile;
+import android.media.SoundPool;
+import android.net.Uri;
+import android.os.Build;
+import android.os.Bundle;
+import android.os.Debug;
+import android.os.Handler;
+import android.os.Looper;
+import android.os.Message;
+import android.os.MessageQueue;
+import android.os.SystemClock;
+import android.preference.Preference;
+import android.preference.PreferenceManager;
+import android.provider.MediaStore;
+import android.util.DisplayMetrics;
+import android.util.Log;
+import android.view.KeyEvent;
+import android.view.OrientationEventListener;
+import android.view.SurfaceHolder;
+import android.view.View;
+import android.view.WindowManager;
+import android.widget.Toast;
+import android.widget.SeekBar;
+import android.widget.SeekBar.OnSeekBarChangeListener;
+import android.widget.LinearLayout;
+import android.widget.TextView;
+
+import com.android.camera.app.CameraApp;
+import com.android.camera.CameraManager.CameraAFCallback;
+import com.android.camera.CameraManager.CameraAFMoveCallback;
+import com.android.camera.CameraManager.CameraPictureCallback;
+import com.android.camera.CameraManager.CameraProxy;
+import com.android.camera.CameraManager.CameraShutterCallback;
+import com.android.camera.SPhotoModule.SNamedImages.SNamedEntity;
+import com.android.camera.exif.ExifInterface;
+import com.android.camera.exif.ExifTag;
+import com.android.camera.exif.Rational;
+import com.android.camera.ui.CountDownView.OnCountDownFinishedListener;
+import com.android.camera.ui.ModuleSwitcher;
+import com.android.camera.ui.RotateTextToast;
+import com.android.camera.util.ApiHelper;
+import com.android.camera.util.CameraUtil;
+import com.android.camera.util.GcamHelper;
+import com.android.camera.util.PersistUtil;
+import com.android.camera.util.UsageStatistics;
+import org.codeaurora.snapcam.R;
+import org.codeaurora.snapcam.wrapper.ParametersWrapper;
+import org.codeaurora.snapcam.wrapper.CameraInfoWrapper;
+import org.codeaurora.snapcam.filter.GDepth;
+import org.codeaurora.snapcam.filter.GImage;
+
+import android.widget.EditText;
+import android.app.AlertDialog;
+import android.content.DialogInterface;
+import android.text.InputType;
+import android.text.TextUtils;
+
+import com.android.internal.util.MemInfoReader;
+import android.app.ActivityManager;
+
+import java.io.ByteArrayOutputStream;
+import java.io.File;
+import java.io.FileNotFoundException;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.io.OutputStream;
+import java.util.Arrays;
+import java.lang.NumberFormatException;
+import java.util.List;
+import java.util.Vector;
+import java.util.HashMap;
+import android.util.AttributeSet;
+import android.graphics.Canvas;
+import android.graphics.Color;
+import android.graphics.Paint;
+import android.os.SystemProperties;
+
+public class SPhotoModule
+        implements CameraModule,
+        PhotoController,
+        FocusOverlayManager.Listener,
+        CameraPreference.OnPreferenceChangedListener,
+        ShutterButton.OnShutterButtonListener,
+        MediaSaveService.Listener,
+        OnCountDownFinishedListener,
+        LocationManager.Listener,
+        SensorEventListener {
+
+    private static final String TAG = "CAM_SPhotoModule";
+
+   //QCom data members
+    private static final int MAX_SHARPNESS_LEVEL = 6;
+    private boolean mRestartPreview = false;
+    private int mSnapshotMode;
+    private int mBurstSnapNum = 1;
+    private int mReceivedSnapNum = 0;
+    private int mLongshotSnapNum = 0;
+    public boolean mFaceDetectionEnabled = false;
+    private SCameraGraphView mGraphView;
+    private static final int STATS_DATA = 257;
+    public static int statsdata[] = new int[STATS_DATA];
+    // We number the request code from 1000 to avoid collision with Gallery.
+    private static final int REQUEST_CROP = 1000;
+
+    private static final int SETUP_PREVIEW = 1;
+    private static final int FIRST_TIME_INIT = 2;
+    private static final int CLEAR_SCREEN_DELAY = 3;
+    private static final int SET_CAMERA_PARAMETERS_WHEN_IDLE = 4;
+    private static final int SHOW_TAP_TO_FOCUS_TOAST = 5;
+    private static final int SWITCH_CAMERA = 6;
+    private static final int SWITCH_CAMERA_START_ANIMATION = 7;
+    private static final int CAMERA_OPEN_DONE = 8;
+    private static final int OPEN_CAMERA_FAIL = 9;
+    private static final int CAMERA_DISABLED = 10;
+    private static final int SET_PHOTO_UI_PARAMS = 11;
+    private static final int SWITCH_TO_GCAM_MODULE = 12;
+    private static final int ON_PREVIEW_STARTED = 13;
+    private static final int INSTANT_CAPTURE = 14;
+    private static final int UNLOCK_CAM_SHUTTER = 15;
+    private static final int SET_FOCUS_RATIO = 16;
+
+    private static final int NO_DEPTH_EFFECT = 0;
+    private static final int DEPTH_EFFECT_SUCCESS = 1;
+    private static final int TOO_NEAR = 2;
+    private static final int TOO_FAR = 3;
+    private static final int LOW_LIGHT = 4;
+    private static final int SUBJECT_NOT_FOUND = 5;
+    private static final int TOUCH_TO_FOCUS = 6;
+
+    // The subset of parameters we need to update in setCameraParameters().
+    private static final int UPDATE_PARAM_INITIALIZE = 1;
+    private static final int UPDATE_PARAM_ZOOM = 2;
+    private static final int UPDATE_PARAM_PREFERENCE = 4;
+    private static final int UPDATE_PARAM_ALL = -1;
+
+    // This is the delay before we execute onResume tasks when coming
+    // from the lock screen, to allow time for onPause to execute.
+    private static final int ON_RESUME_TASKS_DELAY_MSEC = 20;
+
+    private static final String DEBUG_IMAGE_PREFIX = "DEBUG_";
+
+    // copied from Camera hierarchy
+    private CameraActivity mActivity;
+    private CameraProxy mCameraDevice;
+    private int mCameraId;
+    private Parameters mParameters;
+    private boolean mPaused;
+    private View mRootView;
+
+    private SPhotoUI mUI;
+
+    // The activity is going to switch to the specified camera id. This is
+    // needed because texture copy is done in GL thread. -1 means camera is not
+    // switching.
+    protected int mPendingSwitchCameraId = -1;
+    private boolean mOpenCameraFail;
+    private boolean mCameraDisabled;
+
+    // When setCameraParametersWhenIdle() is called, we accumulate the subsets
+    // needed to be updated in mUpdateSet.
+    private int mUpdateSet;
+
+    private static final int SCREEN_DELAY = 2 * 60 * 1000;
+
+    private int mZoomValue;  // The current zoom value.
+
+    private Parameters mInitialParams;
+    private boolean mFocusAreaSupported;
+    private boolean mMeteringAreaSupported;
+    private boolean mAeLockSupported;
+    private boolean mAwbLockSupported;
+    private boolean mContinuousFocusSupported;
+    private boolean mLongshotSave = false;
+    private int mLongShotCaptureCount;
+    private int mLongShotCaptureCountLimit;
+
+    // The degrees of the device rotated clockwise from its natural orientation.
+    private int mOrientation = OrientationEventListener.ORIENTATION_UNKNOWN;
+    private ComboPreferences mPreferences;
+
+    private static final String sTempCropFilename = "crop-temp";
+
+    private boolean mFaceDetectionStarted = false;
+
+    private static final boolean PERSIST_SKIP_MEM_CHECK = PersistUtil.isSkipMemoryCheckEnabled();
+
+    private static final String PERSISI_BOKEH_DEBUG = "persist.camera.bokeh.debug";
+    private static final boolean PERSIST_BOKEH_DEBUG_CHECK =
+            android.os.SystemProperties.getBoolean(PERSISI_BOKEH_DEBUG, false);
+    private static final String PERSIST_LONGSHOT_MAX_SNAP = "persist.camera.longshot.max";
+    private static int mLongShotMaxSnap = -1;
+
+    // Constant from android.hardware.Camera.Parameters
+    private static final String KEY_PICTURE_FORMAT = "picture-format";
+    private static final String KEY_QC_RAW_PICUTRE_SIZE = "raw-size";
+    public static final String PIXEL_FORMAT_JPEG = "jpeg";
+
+    private static final int MIN_SCE_FACTOR = -10;
+    private static final int MAX_SCE_FACTOR = +10;
+    private int SCE_FACTOR_STEP = 10;
+
+    private boolean mPreviewRestartSupport = false;
+
+    // mCropValue and mSaveUri are used only if isImageCaptureIntent() is true.
+    private String mCropValue;
+    private Uri mSaveUri;
+
+    private Uri mDebugUri;
+
+    // Used for check memory status for longshot mode
+    // Currently, this cancel threshold selection is based on test experiments,
+    // we can change it based on memory status or other requirements.
+    private static final int LONGSHOT_CANCEL_THRESHOLD = 40 * 1024 * 1024;
+    private long SECONDARY_SERVER_MEM;
+    private boolean mLongshotActive = false;
+
+    // We use a queue to generated names of the images to be used later
+    // when the image is ready to be saved.
+    private SNamedImages mSNamedImages;
+
+    private byte[] mLastJpegData;
+    private int mLastJpegOrientation = 0;
+
+    private static Context mApplicationContext = null;
+
+    private boolean mIsBokehMode = false;
+    private TextView mBokehTipText;
+    private boolean mDepthSuccess = false;
+    private boolean mSaveBokehXmp = false;
+
+    private class OpenCameraThread extends Thread {
+        @Override
+        public void run() {
+            openCamera();
+            startPreview();
+        }
+    }
+
+    private OpenCameraThread mOpenCameraThread = null;
+    /**
+     * An unpublished intent flag requesting to return as soon as capturing
+     * is completed.
+     *
+     * TODO: consider publishing by moving into MediaStore.
+     */
+    private static final String EXTRA_QUICK_CAPTURE =
+            "android.intent.extra.quickCapture";
+
+    // The display rotation in degrees. This is only valid when mCameraState is
+    // not PREVIEW_STOPPED.
+    private int mDisplayRotation;
+    // The value for android.hardware.Camera.setDisplayOrientation.
+    private int mCameraDisplayOrientation;
+    // The value for UI components like indicators.
+    private int mDisplayOrientation;
+    // The value for android.hardware.Camera.Parameters.setRotation.
+    private int mJpegRotation;
+    // Indicates whether we are using front camera
+    private boolean mMirror;
+    private boolean mFirstTimeInitialized;
+    private boolean mIsImageCaptureIntent;
+    private int mOrientationOffset;
+
+    private int mCameraState = INIT;
+    private boolean mSnapshotOnIdle = false;
+
+    private ContentResolver mContentResolver;
+
+    private LocationManager mLocationManager;
+    private boolean mLocationPromptTriggered = false;
+
+    private final PostViewPictureCallback mPostViewPictureCallback =
+            new PostViewPictureCallback();
+    private final RawPictureCallback mRawPictureCallback =
+            new RawPictureCallback();
+    private final AutoFocusCallback mAutoFocusCallback =
+            new AutoFocusCallback();
+    private final Object mAutoFocusMoveCallback =
+            ApiHelper.HAS_AUTO_FOCUS_MOVE_CALLBACK
+                    ? new AutoFocusMoveCallback()
+                    : null;
+
+    private final CameraErrorCallback mErrorCallback = new CameraErrorCallback();
+    private final StatsCallback mStatsCallback = new StatsCallback();
+    private final MetaDataCallback mMetaDataCallback = new MetaDataCallback();
+    private long mFocusStartTime;
+    private long mShutterCallbackTime;
+    private long mPostViewPictureCallbackTime;
+    private long mRawPictureCallbackTime;
+    private long mJpegPictureCallbackTime;
+    private long mOnResumeTime;
+    private byte[] mJpegImageData;
+
+    // These latency time are for the CameraLatency test.
+    public long mAutoFocusTime;
+    public long mShutterLag;
+    public long mShutterToPictureDisplayedTime;
+    public long mPictureDisplayedToJpegCallbackTime;
+    public long mJpegCallbackFinishTime;
+    public long mCaptureStartTime;
+
+    // This handles everything about focus.
+    private FocusOverlayManager mFocusManager;
+
+    private String mSceneMode;
+    private String mSavedFlashMode = null;
+
+    private final Handler mHandler = new MainHandler();
+    private MessageQueue.IdleHandler mIdleHandler = null;
+
+    private PreferenceGroup mPreferenceGroup;
+
+    private boolean mQuickCapture;
+    private SensorManager mSensorManager;
+    private float[] mGData = new float[3];
+    private float[] mMData = new float[3];
+    private float[] mR = new float[16];
+    private int mHeading = -1;
+
+    private static final int MAX_ZOOM = 10;
+    private int[] mZoomIdxTbl = {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1};
+    // True if all the parameters needed to start preview is ready.
+    private boolean mCameraPreviewParamsReady = false;
+
+    private boolean mAnimateCapture = true;
+
+    private int mJpegFileSizeEstimation = 0;
+    private int mRemainingPhotos = -1;
+    private static final int SELFIE_FLASH_DURATION = 680;
+
+    private class SelfieThread extends Thread {
+        public void run() {
+            try {
+                Thread.sleep(SELFIE_FLASH_DURATION);
+                mActivity.runOnUiThread(new Runnable() {
+                    public void run() {
+                        mFocusManager.doSnap();
+                    }
+                });
+            } catch(InterruptedException e) {
+            }
+            selfieThread = null;
+        }
+    }
+    private SelfieThread selfieThread;
+
+    private class MediaSaveNotifyThread extends Thread
+    {
+        private Uri uri;
+        public MediaSaveNotifyThread(Uri uri)
+        {
+            this.uri = uri;
+        }
+        public void setUri(Uri uri)
+        {
+            this.uri = uri;
+        }
+        public void run()
+        {
+            while(mLongshotActive) {
+                try {
+                    Thread.sleep(10);
+                } catch(InterruptedException e) {
+                }
+            }
+            mActivity.runOnUiThread(new Runnable() {
+                public void run() {
+                    if (uri != null)
+                        mActivity.notifyNewMedia(uri);
+                    mActivity.updateStorageSpaceAndHint();
+                    updateRemainingPhotos();
+                }
+            });
+            mediaSaveNotifyThread = null;
+        }
+    }
+
+    private MediaSaveNotifyThread mediaSaveNotifyThread;
+    private MediaSaveService.OnMediaSavedListener mOnMediaSavedListener =
+            new MediaSaveService.OnMediaSavedListener() {
+                @Override
+                public void onMediaSaved(Uri uri) {
+                    if(mLongshotActive) {
+                        if(mediaSaveNotifyThread == null) {
+                            mediaSaveNotifyThread = new MediaSaveNotifyThread(uri);
+                            mediaSaveNotifyThread.start();
+                        }
+                        else
+                            mediaSaveNotifyThread.setUri(uri);
+                    } else {
+                        if (uri != null) {
+                            mActivity.notifyNewMedia(uri);
+                        }
+                    }
+                }
+            };
+
+    private void checkDisplayRotation() {
+        // Set the display orientation if display rotation has changed.
+        // Sometimes this happens when the device is held upside
+        // down and camera app is opened. Rotation animation will
+        // take some time and the rotation value we have got may be
+        // wrong. Framework does not have a callback for this now.
+        if (CameraUtil.getDisplayRotation(mActivity) != mDisplayRotation) {
+            setDisplayOrientation();
+        }
+        if (SystemClock.uptimeMillis() - mOnResumeTime < 5000) {
+            mHandler.postDelayed(new Runnable() {
+                @Override
+                public void run() {
+                    checkDisplayRotation();
+                }
+            }, 100);
+        }
+    }
+
+    public Parameters getParameters()
+    {
+        return mParameters;
+    }
+
+    /**
+     * This Handler is used to post message back onto the main thread of the
+     * application
+     */
+    private class MainHandler extends Handler {
+        public MainHandler() {
+            super(Looper.getMainLooper());
+        }
+
+        @Override
+        public void handleMessage(Message msg) {
+            switch (msg.what) {
+                case SETUP_PREVIEW: {
+                    setupPreview();
+                    break;
+                }
+
+                case CLEAR_SCREEN_DELAY: {
+                    mActivity.getWindow().clearFlags(
+                            WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON);
+                    break;
+                }
+
+                case FIRST_TIME_INIT: {
+                    initializeFirstTime();
+                    break;
+                }
+
+                case SET_CAMERA_PARAMETERS_WHEN_IDLE: {
+                    setCameraParametersWhenIdle(0);
+                    break;
+                }
+
+                case SHOW_TAP_TO_FOCUS_TOAST: {
+                    showTapToFocusToast();
+                    break;
+                }
+
+                case SWITCH_CAMERA: {
+                    switchCamera();
+                    break;
+                }
+
+                case SWITCH_CAMERA_START_ANIMATION: {
+                    // TODO: Need to revisit
+                    // ((CameraScreenNail) mActivity.mCameraScreenNail).animateSwitchCamera();
+                    break;
+                }
+
+                case CAMERA_OPEN_DONE: {
+                    onCameraOpened();
+                    break;
+                }
+
+                case OPEN_CAMERA_FAIL: {
+                    mOpenCameraFail = true;
+                    CameraUtil.showErrorAndFinish(mActivity,
+                            R.string.cannot_connect_camera);
+                    break;
+                }
+
+                case CAMERA_DISABLED: {
+                    mCameraDisabled = true;
+                    CameraUtil.showErrorAndFinish(mActivity,
+                            R.string.camera_disabled);
+                    break;
+                }
+
+               case SET_PHOTO_UI_PARAMS: {
+                    setCameraParametersWhenIdle(UPDATE_PARAM_PREFERENCE);
+                    break;
+               }
+
+                case SWITCH_TO_GCAM_MODULE: {
+                    mActivity.onModuleSelected(ModuleSwitcher.GCAM_MODULE_INDEX);
+                    break;
+                }
+
+                case ON_PREVIEW_STARTED: {
+                    onPreviewStarted();
+                    break;
+                }
+
+                case INSTANT_CAPTURE: {
+                    onShutterButtonClick();
+                    break;
+                }
+
+                case UNLOCK_CAM_SHUTTER: {
+                    mUI.enableShutter(true);
+                    break;
+                }
+
+                case SET_FOCUS_RATIO: {
+                    mUI.getFocusRing().setRadiusRatio((Float)msg.obj);
+                    break;
+                }
+            }
+        }
+    }
+
+    public void reinit() {
+        mPreferences = ComboPreferences.get(mActivity);
+        if (mPreferences == null) {
+            mPreferences = new ComboPreferences(mActivity);
+        }
+        CameraSettings.upgradeGlobalPreferences(mPreferences.getGlobal(), mActivity);
+        mCameraId = getPreferredCameraId(mPreferences);
+        mPreferences.setLocalId(mActivity, mCameraId);
+        CameraSettings.upgradeLocalPreferences(mPreferences.getLocal());
+    }
+
+    @Override
+    public void init(CameraActivity activity, View parent) {
+        mActivity = activity;
+        mRootView = parent;
+        mOrientationOffset = CameraUtil.isDefaultToPortrait(mActivity) ? 0 : 90;
+        mPreferences = ComboPreferences.get(mActivity);
+        if (mPreferences == null) {
+            mPreferences = new ComboPreferences(mActivity);
+        }
+
+        CameraSettings.upgradeGlobalPreferences(mPreferences.getGlobal(), activity);
+        mCameraId = getPreferredCameraId(mPreferences);
+        mContentResolver = mActivity.getContentResolver();
+        mApplicationContext = CameraApp.getContext();
+
+        // Surface texture is from camera screen nail and startPreview needs it.
+        // This must be done before startPreview.
+        mIsImageCaptureIntent = isImageCaptureIntent();
+
+        mPreferences.setLocalId(mActivity, mCameraId);
+        CameraSettings.upgradeLocalPreferences(mPreferences.getLocal());
+
+        mUI = new SPhotoUI(activity, this, parent);
+
+        // Power shutter
+        mActivity.initPowerShutter(mPreferences);
+
+        // Max brightness
+        mActivity.initMaxBrightness(mPreferences);
+
+        if (mOpenCameraThread == null) {
+            mOpenCameraThread = new OpenCameraThread();
+            mOpenCameraThread.start();
+        }
+        initializeControlByIntent();
+        mQuickCapture = mActivity.getIntent().getBooleanExtra(EXTRA_QUICK_CAPTURE, false);
+        mLocationManager = new LocationManager(mActivity, this);
+        mSensorManager = (SensorManager)(mActivity.getSystemService(Context.SENSOR_SERVICE));
+
+        mBokehTipText = (TextView) mRootView.findViewById(R.id.bokeh_tip_text);
+
+        Storage.setSaveSDCard(
+            mPreferences.getString(CameraSettings.KEY_CAMERA_SAVEPATH, "0").equals("1"));
+    }
+
+    private void initializeControlByIntent() {
+        mUI.initializeControlByIntent();
+        if (mIsImageCaptureIntent) {
+            setupCaptureParams();
+        }
+    }
+
+    private void onPreviewStarted() {
+        if (mCameraState == SNAPSHOT_IN_PROGRESS) {
+            return;
+        }
+        setCameraState(IDLE);
+        mFocusManager.onPreviewStarted();
+        startFaceDetection();
+        locationFirstRun();
+        mUI.enableShutter(true);
+    }
+
+    // Prompt the user to pick to record location for the very first run of
+    // camera only
+    private void locationFirstRun() {
+        boolean enableRecordingLocation = false;
+        if (mActivity.checkSelfPermission(Manifest.permission.ACCESS_FINE_LOCATION)
+                == PackageManager.PERMISSION_GRANTED) {
+            enableRecordingLocation = true;
+        }
+        /* Do not prompt if the preference is already set, this is a secure
+         * camera session, or the prompt has already been triggered. */
+        if ((RecordLocationPreference.isSet(
+                mPreferences, CameraSettings.KEY_RECORD_LOCATION) && enableRecordingLocation) ||
+                mActivity.isSecureCamera() || mLocationPromptTriggered) {
+            return;
+        }
+        // Check if the back camera exists
+        int backCameraId = CameraHolder.instance().getBackCameraId();
+        if (backCameraId == -1) {
+            // If there is no back camera, do not show the prompt.
+            return;
+        }
+
+        mLocationPromptTriggered = true;
+
+        /* Enable the location at the begining, always.
+           If the user denies the permission, it will be disabled
+           right away due to exception */
+        enableRecordingLocation(enableRecordingLocation);
+    }
+
+    @Override
+    public void waitingLocationPermissionResult(boolean result) {
+        mLocationManager.waitingLocationPermissionResult(result);
+    }
+
+    @Override
+    public void enableRecordingLocation(boolean enable) {
+        setLocationPreference(enable ? RecordLocationPreference.VALUE_ON
+                : RecordLocationPreference.VALUE_OFF);
+        mLocationManager.recordLocation(enable);
+    }
+
+    @Override
+    public void setPreferenceForTest(String key, String value) {
+        mUI.setPreference(key, value);
+        onSharedPreferenceChanged();
+    }
+
+    @Override
+    public void onPreviewUIReady() {
+        if (mPaused || mCameraDevice == null) {
+            return;
+        }
+        Log.v(TAG, "onPreviewUIReady");
+        if (mCameraState == PREVIEW_STOPPED) {
+            startPreview();
+        } else {
+            synchronized (mCameraDevice) {
+                SurfaceHolder sh = mUI.getSurfaceHolder();
+                if (sh == null) {
+                    Log.w(TAG, "startPreview: holder for preview are not ready.");
+                    return;
+                }
+                mCameraDevice.setPreviewDisplay(sh);
+            }
+        }
+    }
+
+    @Override
+    public void onPreviewUIDestroyed() {
+        if (mCameraDevice == null) {
+            return;
+        }
+        try {
+            if (mOpenCameraThread != null) {
+                mOpenCameraThread.join();
+                mOpenCameraThread = null;
+            }
+        } catch (InterruptedException ex) {
+            // ignore
+        }
+        stopPreview();
+    }
+
+    private void setLocationPreference(String value) {
+        mPreferences.edit()
+                .putString(CameraSettings.KEY_RECORD_LOCATION, value)
+                .apply();
+        // TODO: Fix this to use the actual onSharedPreferencesChanged listener
+        // instead of invoking manually
+        if (mUI.mMenuInitialized) {
+            onSharedPreferenceChanged();
+        }
+    }
+
+    private void onCameraOpened() {
+        if (mPaused) {
+            return;
+        }
+        Log.v(TAG, "onCameraOpened");
+        openCameraCommon();
+        resizeForPreviewAspectRatio();
+        mFocusManager.setFocusRing(mUI.getFocusRing());
+    }
+
+    private void switchCamera() {
+        if (mPaused) return;
+
+        mUI.applySurfaceChange(SPhotoUI.SURFACE_STATUS.HIDE);
+        Log.v(TAG, "Start to switch camera. id=" + mPendingSwitchCameraId);
+        mCameraId = mPendingSwitchCameraId;
+        mPendingSwitchCameraId = -1;
+        mSnapshotOnIdle = false;
+        setCameraId(mCameraId);
+
+        try {
+            if (mOpenCameraThread != null) {
+                mOpenCameraThread.join();
+            }
+        } catch (InterruptedException e) {
+            e.printStackTrace();
+        }
+        mOpenCameraThread = null;
+
+        // from onPause
+        try {
+            if (mOpenCameraThread != null) {
+                mOpenCameraThread.join();
+                mOpenCameraThread = null;
+            }
+        } catch (InterruptedException ex) {
+            // ignore
+        }
+        closeCamera();
+        mUI.collapseCameraControls();
+        if (mFocusManager != null) mFocusManager.removeMessages();
+
+        // Restart the camera and initialize the UI. From onCreate.
+        mPreferences.setLocalId(mActivity, mCameraId);
+        CameraSettings.upgradeLocalPreferences(mPreferences.getLocal());
+        mCameraDevice = CameraUtil.openCamera(
+                mActivity, mCameraId, mHandler,
+                mActivity.getCameraOpenErrorCallback());
+
+        if (mCameraDevice == null) {
+            Log.e(TAG, "Failed to open camera:" + mCameraId + ", aborting.");
+            return;
+        }
+        mParameters = mCameraDevice.getParameters();
+        mInitialParams = mCameraDevice.getParameters();
+        initializeCapabilities();
+        CameraInfo info = CameraHolder.instance().getCameraInfo()[mCameraId];
+        mMirror = (info.facing == CameraInfo.CAMERA_FACING_FRONT);
+        mFocusManager.setMirror(mMirror);
+        mFocusManager.setParameters(mInitialParams);
+        setupPreview();
+
+        mUI.applySurfaceChange(SPhotoUI.SURFACE_STATUS.SURFACE_VIEW);
+        // reset zoom value index
+        mZoomValue = 0;
+        resizeForPreviewAspectRatio();
+        openCameraCommon();
+
+        // Start switch camera animation. Post a message because
+        // onFrameAvailable from the old camera may already exist.
+        mHandler.sendEmptyMessage(SWITCH_CAMERA_START_ANIMATION);
+    }
+
+    protected void setCameraId(int cameraId) {
+        ListPreference pref = mPreferenceGroup.findPreference(CameraSettings.KEY_CAMERA_ID);
+        pref.setValue("" + cameraId);
+    }
+
+    // either open a new camera or switch cameras
+    private void openCameraCommon() {
+        loadCameraPreferences();
+
+        mUI.onCameraOpened(mPreferenceGroup, mPreferences, mParameters, this);
+        updateCameraSettings();
+        showTapToFocusToastIfNeeded();
+        resetMiscSettings();
+    }
+
+    @Override
+    public void onScreenSizeChanged(int width, int height) {
+        if (mFocusManager != null) mFocusManager.setPreviewSize(width, height);
+    }
+
+    @Override
+    public void onPreviewRectChanged(Rect previewRect) {
+        if (mFocusManager != null) mFocusManager.setPreviewRect(previewRect);
+    }
+
+    private void resetMiscSettings() {
+        boolean disableQcomMiscSetting = PersistUtil.isDisableQcomMiscSetting();
+        if (disableQcomMiscSetting) {
+            mUI.setPreference(CameraSettings.KEY_FACE_DETECTION,
+                    ParametersWrapper.FACE_DETECTION_OFF);
+            mUI.setPreference(CameraSettings.KEY_FOCUS_MODE,
+                    Parameters.FOCUS_MODE_AUTO);
+            mUI.setPreference(CameraSettings.KEY_FLASH_MODE,
+                    Parameters.FLASH_MODE_OFF);
+            onSharedPreferenceChanged();
+        }
+    }
+
+    void setPreviewFrameLayoutCameraOrientation(){
+        CameraInfo info = CameraHolder.instance().getCameraInfo()[mCameraId];
+        //if camera mount angle is 0 or 180, we want to resize preview
+        if (info.orientation % 180 == 0){
+            mUI.cameraOrientationPreviewResize(true);
+        } else{
+            mUI.cameraOrientationPreviewResize(false);
+        }
+    }
+
+    @Override
+    public void resizeForPreviewAspectRatio() {
+        if ( mCameraDevice == null || mParameters == null) {
+            Log.e(TAG, "Camera not yet initialized");
+            return;
+        }
+        setPreviewFrameLayoutCameraOrientation();
+        Size size = mParameters.getPreviewSize();
+        Log.i(TAG, "Using preview width = " + size.width + "& height = " + size.height);
+        mUI.setAspectRatio((float) size.width / size.height);
+    }
+
+    @Override
+    public void onSwitchSavePath() {
+        if (mUI.mMenuInitialized) {
+            mUI.setPreference(CameraSettings.KEY_CAMERA_SAVEPATH, "1");
+        } else {
+            mPreferences.edit()
+                    .putString(CameraSettings.KEY_CAMERA_SAVEPATH, "1")
+                    .apply();
+        }
+        RotateTextToast.makeText(mActivity, R.string.on_switch_save_path_to_sdcard,
+                Toast.LENGTH_SHORT).show();
+    }
+
+    // Snapshots can only be taken after this is called. It should be called
+    // once only. We could have done these things in onCreate() but we want to
+    // make preview screen appear as soon as possible.
+    private void initializeFirstTime() {
+        if (mFirstTimeInitialized || mPaused) {
+            return;
+        }
+
+        // Initialize location service.
+        boolean recordLocation = RecordLocationPreference.get(mPreferences,
+                CameraSettings.KEY_RECORD_LOCATION);
+        mLocationManager.recordLocation(recordLocation);
+
+        mUI.initializeFirstTime();
+        MediaSaveService s = mActivity.getMediaSaveService();
+        // We set the listener only when both service and shutterbutton
+        // are initialized.
+        if (s != null) {
+            s.setListener(this);
+        }
+
+        mSNamedImages = new SNamedImages();
+
+        mFirstTimeInitialized = true;
+        Log.d(TAG, "addIdleHandler in first time initialization");
+        addIdleHandler();
+
+    }
+
+    // If the activity is paused and resumed, this method will be called in
+    // onResume.
+    private void initializeSecondTime() {
+        // Start location update if needed.
+        boolean recordLocation = RecordLocationPreference.get(mPreferences,
+                CameraSettings.KEY_RECORD_LOCATION);
+        mLocationManager.recordLocation(recordLocation);
+        MediaSaveService s = mActivity.getMediaSaveService();
+        if (s != null) {
+            s.setListener(this);
+        }
+        mSNamedImages = new SNamedImages();
+        if (!mIsImageCaptureIntent) {
+            mUI.showSwitcher();
+        }
+        mUI.initializeSecondTime(mParameters);
+    }
+
+    private void showTapToFocusToastIfNeeded() {
+        // Show the tap to focus toast if this is the first start.
+        if (mFocusAreaSupported &&
+                mPreferences.getBoolean(CameraSettings.KEY_CAMERA_FIRST_USE_HINT_SHOWN, true)) {
+            // Delay the toast for one second to wait for orientation.
+            mHandler.sendEmptyMessageDelayed(SHOW_TAP_TO_FOCUS_TOAST, 1000);
+        }
+    }
+
+    private void addIdleHandler() {
+        if (mIdleHandler == null) {
+            mIdleHandler = new MessageQueue.IdleHandler() {
+                @Override
+                public boolean queueIdle() {
+                    Storage.ensureOSXCompatible();
+                    return false;
+                }
+            };
+
+            MessageQueue queue = Looper.myQueue();
+            queue.addIdleHandler(mIdleHandler);
+        }
+    }
+
+    private void removeIdleHandler() {
+        if (mIdleHandler != null) {
+            MessageQueue queue = Looper.myQueue();
+            queue.removeIdleHandler(mIdleHandler);
+            mIdleHandler = null;
+        }
+    }
+
+    @Override
+    public void startFaceDetection() {
+        if (mCameraDevice == null) return;
+
+        if (mFaceDetectionEnabled == false
+               || mFaceDetectionStarted || mCameraState != IDLE) return;
+        if (mParameters.getMaxNumDetectedFaces() > 0) {
+            mFaceDetectionStarted = true;
+            CameraInfo info = CameraHolder.instance().getCameraInfo()[mCameraId];
+            mUI.onStartFaceDetection(mDisplayOrientation,
+                    (info.facing == CameraInfo.CAMERA_FACING_FRONT));
+            mCameraDevice.setFaceDetectionCallback(mHandler, mUI);
+            mCameraDevice.startFaceDetection();
+        }
+    }
+
+    @Override
+    public void stopFaceDetection() {
+        if (mFaceDetectionEnabled == false || !mFaceDetectionStarted) return;
+        if (mParameters.getMaxNumDetectedFaces() > 0) {
+            mFaceDetectionStarted = false;
+            mCameraDevice.setFaceDetectionCallback(null, null);
+            mCameraDevice.stopFaceDetection();
+            mUI.onStopFaceDetection();
+        }
+    }
+
+    @Override
+    public void setFocusRatio(float ratio) {
+        mHandler.removeMessages(SET_FOCUS_RATIO);
+        Message m = mHandler.obtainMessage(SET_FOCUS_RATIO);
+        m.obj = ratio;
+        mHandler.sendMessage(m);
+    }
+
+    // TODO: need to check cached background apps memory and longshot ION memory
+    private boolean isLongshotNeedCancel() {
+
+        if (PERSIST_SKIP_MEM_CHECK == true) {
+            return false;
+        }
+
+        if (Storage.getAvailableSpace() <= Storage.LOW_STORAGE_THRESHOLD_BYTES) {
+            Log.w(TAG, "current storage is full");
+            return true;
+        }
+        if (SECONDARY_SERVER_MEM == 0) {
+            ActivityManager am = (ActivityManager) mActivity.getSystemService(
+                    Context.ACTIVITY_SERVICE);
+            ActivityManager.MemoryInfo memInfo = new ActivityManager.MemoryInfo();
+            am.getMemoryInfo(memInfo);
+            SECONDARY_SERVER_MEM = memInfo.secondaryServerThreshold;
+        }
+
+        long totalMemory = Runtime.getRuntime().totalMemory();
+        long maxMemory = Runtime.getRuntime().maxMemory();
+        long remainMemory = maxMemory - totalMemory;
+
+        MemInfoReader reader = new MemInfoReader();
+        reader.readMemInfo();
+        long[] info = reader.getRawInfo();
+        long availMem = (info[Debug.MEMINFO_FREE] + info[Debug.MEMINFO_CACHED]) * 1024;
+
+        if (availMem <= SECONDARY_SERVER_MEM || remainMemory <= LONGSHOT_CANCEL_THRESHOLD) {
+            Log.e(TAG, "cancel longshot: free=" + info[Debug.MEMINFO_FREE] * 1024
+                    + " cached=" + info[Debug.MEMINFO_CACHED] * 1024
+                    + " threshold=" + SECONDARY_SERVER_MEM);
+            mLongshotActive = false;
+            RotateTextToast.makeText(mActivity,R.string.msg_cancel_longshot_for_limited_memory,
+                Toast.LENGTH_SHORT).show();
+            return true;
+        }
+
+        return false;
+    }
+
+    private final class LongshotShutterCallback
+            implements CameraShutterCallback {
+        private int mExpectedLongshotSnapNum;
+
+        public LongshotShutterCallback() {
+            mExpectedLongshotSnapNum = mLongshotSnapNum;
+        }
+
+        @Override
+        public void onShutter(CameraProxy camera) {
+            mShutterCallbackTime = System.currentTimeMillis();
+            mShutterLag = mShutterCallbackTime - mCaptureStartTime;
+            Log.e(TAG, "[KPI Perf] PROFILE_SHUTTER_LAG mShutterLag = " + mShutterLag + "ms");
+            synchronized(mCameraDevice) {
+                if (mExpectedLongshotSnapNum != mLongshotSnapNum) {
+                    return;
+                }
+
+                if (++mLongshotSnapNum >= mLongShotMaxSnap &&
+                    (mLongShotMaxSnap != -1)) {
+                    mLongshotActive = false;
+                    mUI.enableShutter(false);
+                    mCameraDevice.stopLongshot();
+                    return;
+                }
+
+                if (mCameraState != LONGSHOT ||
+                    !mLongshotActive) {
+                    mCameraDevice.stopLongshot();
+                    return;
+                }
+
+                if(isLongshotNeedCancel()) {
+                    return;
+                }
+
+                if(mLongShotCaptureCount == mLongShotCaptureCountLimit) {
+                    mLongshotActive = false;
+                    return;
+                }
+
+                Location loc = getLocationAccordPictureFormat(mParameters.get(KEY_PICTURE_FORMAT));
+
+                mLongShotCaptureCount++;
+                if (mLongshotSave) {
+                    mCameraDevice.takePicture(mHandler,
+                            new LongshotShutterCallback(),
+                            mRawPictureCallback, mPostViewPictureCallback,
+                            new LongshotPictureCallback(loc));
+                } else {
+                    mCameraDevice.takePicture(mHandler,new LongshotShutterCallback(),
+                            mRawPictureCallback, mPostViewPictureCallback,
+                            new JpegPictureCallback(loc));
+                }
+            }
+        }
+    }
+
+    private final class ShutterCallback
+            implements CameraShutterCallback {
+
+        private boolean mNeedsAnimation;
+
+        public ShutterCallback(boolean needsAnimation) {
+            mNeedsAnimation = needsAnimation;
+        }
+
+        @Override
+        public void onShutter(CameraProxy camera) {
+            mShutterCallbackTime = System.currentTimeMillis();
+            mShutterLag = mShutterCallbackTime - mCaptureStartTime;
+            Log.e(TAG, "[KPI Perf] PROFILE_SHUTTER_LAG mShutterLag = " + mShutterLag + "ms");
+            if (mNeedsAnimation) {
+                mActivity.runOnUiThread(new Runnable() {
+                    @Override
+                    public void run() {
+                        animateAfterShutter();
+                    }
+                });
+            }
+        }
+    }
+
+    private final class StatsCallback
+           implements android.hardware.Camera.CameraDataCallback {
+            @Override
+        public void onCameraData(int [] data, android.hardware.Camera camera) {
+            //if(!mPreviewing || !mFirstTimeInitialized){
+            if(!mFirstTimeInitialized){
+                return;
+            }
+            //The first element in the array stores max hist value . Stats data begin from second value
+            synchronized(statsdata) {
+                System.arraycopy(data,0,statsdata,0,STATS_DATA);
+            }
+            mActivity.runOnUiThread(new Runnable() {
+                public void run() {
+                    if(mGraphView != null)
+                        mGraphView.PreviewChanged();
+                }
+           });
+        }
+    }
+
+    private final class MetaDataCallback
+           implements android.hardware.Camera.CameraMetaDataCallback{
+        private static final int QCAMERA_METADATA_HDR = 3;
+        private static final int QCAMERA_METADATA_RTB = 5;
+        private int mLastMessage = -1;
+
+        @Override
+        public void onCameraMetaData (byte[] data, android.hardware.Camera camera) {
+            int metadata[] = new int[3];
+            if (data.length >= 12) {
+                for (int i =0;i<3;i++) {
+                    metadata[i] = byteToInt( (byte []) data, i*4);
+                }
+                /* Checking if the meta data is for auto HDR */
+                if (metadata[0] == QCAMERA_METADATA_RTB) {
+                    final String tip;
+                    Log.d(TAG,"QCAMERA_METADATA_RTB msgtype =" +metadata[2]);
+                    switch (metadata[2]) {
+                        case TOO_FAR:
+                            tip = "Too far";
+                            break;
+                        case TOO_NEAR:
+                            tip = "Too near";
+                            break;
+                        case LOW_LIGHT:
+                            tip = "Low light";
+                            break;
+                        case SUBJECT_NOT_FOUND:
+                            tip = "Object not found";
+                            break;
+                        case DEPTH_EFFECT_SUCCESS:
+                            tip = "Depth effect success";
+                            break;
+                        case NO_DEPTH_EFFECT:
+                            tip = "NO depth effect";
+                            break;
+                        default:
+                            tip = "Message type =" + metadata[2];
+                            break;
+                    }
+                    mDepthSuccess = metadata[2] == DEPTH_EFFECT_SUCCESS;
+                    mActivity.runOnUiThread(new Runnable() {
+                        @Override
+                        public void run() {
+                            if (mBokehTipText != null) {
+                                if (!mDepthSuccess) {
+                                    mBokehTipText.setVisibility(View.VISIBLE);
+                                    mBokehTipText.setText(tip);
+                                } else {
+                                    mBokehTipText.setVisibility(View.GONE);
+                                }
+                            }
+                            mUI.enableBokehFocus(mDepthSuccess);
+                        }
+                    });
+                }
+            }
+        }
+
+        private int byteToInt (byte[] b, int offset) {
+            int value = 0;
+            for (int i = 0; i < 4; i++) {
+                int shift = (4 - 1 - i) * 8;
+                value += (b[(3-i) + offset] & 0x000000FF) << shift;
+            }
+            return value;
+        }
+    }
+
+    private final class PostViewPictureCallback
+            implements CameraPictureCallback {
+        @Override
+        public void onPictureTaken(byte [] data, CameraProxy camera) {
+            Log.d(TAG, "PostViewPictureCallback: onPictureTaken()");
+            mPostViewPictureCallbackTime = System.currentTimeMillis();
+            Log.v(TAG, "mShutterToPostViewCallbackTime = "
+                    + (mPostViewPictureCallbackTime - mShutterCallbackTime)
+                    + "ms");
+        }
+    }
+
+    private final class RawPictureCallback
+            implements CameraPictureCallback {
+        @Override
+        public void onPictureTaken(byte [] rawData, CameraProxy camera) {
+            Log.d(TAG, "RawPictureCallback: onPictureTaken()");
+            mRawPictureCallbackTime = System.currentTimeMillis();
+            Log.v(TAG, "mShutterToRawCallbackTime = "
+                    + (mRawPictureCallbackTime - mShutterCallbackTime) + "ms");
+        }
+    }
+
+    private final class LongshotPictureCallback implements CameraPictureCallback {
+        Location mLocation;
+
+        public LongshotPictureCallback(Location loc) {
+            mLocation = loc;
+        }
+
+        @Override
+        public void onPictureTaken(final byte [] jpegData, CameraProxy camera) {
+            Log.d(TAG, "LongshotPictureCallback: onPictureTaken()");
+            if (mPaused) {
+                return;
+            }
+
+            String jpegFilePath = new String(jpegData);
+            mSNamedImages.nameNewImage(mCaptureStartTime);
+            SNamedEntity name = mSNamedImages.getNextNameEntity();
+            String title = (name == null) ? null : name.title;
+            long date = (name == null) ? -1 : name.date;
+
+            if (title == null) {
+                Log.e(TAG, "Unbalanced name/data pair");
+                return;
+            }
+
+
+            if  (date == -1 ) {
+                Log.e(TAG, "Invalid filename date");
+                return;
+            }
+
+            String dstPath = Storage.DIRECTORY;
+            File sdCard = android.os.Environment.getExternalStorageDirectory();
+            File dstFile = new File(dstPath);
+            if (dstFile == null) {
+                Log.e(TAG, "Destination file path invalid");
+                return;
+            }
+
+            File srcFile = new File(jpegFilePath);
+            if (srcFile == null) {
+                Log.e(TAG, "Source file path invalid");
+                return;
+            }
+
+            if ( srcFile.renameTo(dstFile) ) {
+                Size s = mParameters.getPictureSize();
+                String pictureFormat = mParameters.get(KEY_PICTURE_FORMAT);
+                Log.d(TAG, "capture:" + title + "." + pictureFormat);
+                mActivity.getMediaSaveService().addImage(
+                       null, title, date, mLocation, s.width, s.height,
+                       0, null, mOnMediaSavedListener, mContentResolver, pictureFormat);
+            } else {
+                Log.e(TAG, "Failed to move jpeg file");
+            }
+        }
+    }
+
+    private byte[] flipJpeg(byte[] jpegData, int orientation, int jpegOrientation) {
+        Bitmap srcBitmap = BitmapFactory.decodeByteArray(jpegData, 0, jpegData.length);
+        Matrix m = new Matrix();
+        if(orientation == 270 || orientation == 90) {
+            // Judge whether the picture or phone is horizontal screen
+            if (jpegOrientation == 0 || jpegOrientation == 180) {
+                m.preScale(-1, 1);
+            } else { // the picture or phone is Vertical screen
+                m.preScale(1, -1);
+            }
+        }
+        Bitmap dstBitmap = Bitmap.createBitmap(srcBitmap, 0, 0, srcBitmap.getWidth(), srcBitmap.getHeight(), m, false);
+        dstBitmap.setDensity(DisplayMetrics.DENSITY_DEFAULT);
+        int size = dstBitmap.getWidth() * dstBitmap.getHeight();
+        ByteArrayOutputStream outStream = new ByteArrayOutputStream(size);
+        dstBitmap.compress(Bitmap.CompressFormat.JPEG, 100, outStream);
+
+        return outStream.toByteArray();
+    }
+
+    public static byte[] addExifTags(byte[] jpeg, int orientationInDegree) {
+        ExifInterface exif = new ExifInterface();
+        exif.addOrientationTag(orientationInDegree);
+        ByteArrayOutputStream jpegOut = new ByteArrayOutputStream();
+        try {
+            exif.writeExif(jpeg, jpegOut);
+        } catch (IOException e) {
+            Log.e(TAG, "Could not write EXIF", e);
+        }
+        return jpegOut.toByteArray();
+    }
+
+    private final class JpegPictureCallback
+            implements CameraPictureCallback {
+        public static final int GDEPTH_SIZE = 1280 * 960;
+        Location mLocation;
+        byte[] mBokeh;
+        byte[] mOrigin;
+        byte[] mDepth;
+        int mCallTime = 0;
+
+        public JpegPictureCallback(Location loc) {
+            mLocation = loc;
+        }
+
+        @Override
+        public void onPictureTaken(byte [] jpegData, CameraProxy camera) {
+            mCallTime ++;
+            if (mIsBokehMode && !PERSIST_BOKEH_DEBUG_CHECK && mSaveBokehXmp) {
+                if (jpegData != null && mCallTime == 1) {
+                    mBokeh = jpegData;
+                }
+                if (jpegData != null && mCallTime == 2 && mOrigin == null) {
+                    mOrigin = jpegData;
+                }
+                if (jpegData != null && mCallTime == 3) {
+                    mDepth = jpegData;
+                    jpegData = mBokeh;
+                }
+            }
+            mUI.stopSelfieFlash();
+            if (mCameraState != LONGSHOT) {
+                mUI.enableShutter(true);
+            }
+            if (mUI.isPreviewCoverVisible()) {
+                 // When take picture request is sent before starting preview, onPreviewFrame()
+                 // callback doesn't happen so removing preview cover here, instead.
+                 mUI.hidePreviewCover();
+            }
+            if (mPaused) {
+                return;
+            }
+            if (mIsImageCaptureIntent) {
+                stopPreview();
+            } else if (mSceneMode == CameraUtil.SCENE_MODE_HDR) {
+                mUI.showSwitcher();
+                mUI.setSwipingEnabled(true);
+            }
+
+            ExifInterface exif = Exif.getExif(jpegData);
+            boolean overrideMakerAndModelTag = false;
+            if (mApplicationContext != null) {
+                overrideMakerAndModelTag =
+                    mApplicationContext.getResources()
+                       .getBoolean(R.bool.override_maker_and_model_tag);
+            }
+
+            if (overrideMakerAndModelTag) {
+                ExifTag maker = exif.buildTag(ExifInterface.TAG_MAKE, Build.MANUFACTURER);
+                exif.setTag(maker);
+                ExifTag model = exif.buildTag(ExifInterface.TAG_MODEL, Build.MODEL);
+                exif.setTag(model);
+            }
+
+            mReceivedSnapNum = mReceivedSnapNum + 1;
+            mJpegPictureCallbackTime = System.currentTimeMillis();
+
+            Log.v(TAG, "JpegPictureCallback: Received = " + mReceivedSnapNum + " " +
+                      "Burst count = " + mBurstSnapNum);
+            // If postview callback has arrived, the captured image is displayed
+            // in postview callback. If not, the captured image is displayed in
+            // raw picture callback.
+            if (mPostViewPictureCallbackTime != 0) {
+                mShutterToPictureDisplayedTime =
+                        mPostViewPictureCallbackTime - mShutterCallbackTime;
+                mPictureDisplayedToJpegCallbackTime =
+                        mJpegPictureCallbackTime - mPostViewPictureCallbackTime;
+            } else {
+                mShutterToPictureDisplayedTime =
+                        mRawPictureCallbackTime - mShutterCallbackTime;
+                mPictureDisplayedToJpegCallbackTime =
+                        mJpegPictureCallbackTime - mRawPictureCallbackTime;
+            }
+            Log.v(TAG, "mPictureDisplayedToJpegCallbackTime = "
+                    + mPictureDisplayedToJpegCallbackTime + "ms");
+
+            if (isLongshotDone()) {
+                mCameraDevice.setLongshot(false);
+            }
+
+            boolean needRestartPreview = !mIsImageCaptureIntent
+                    && !mPreviewRestartSupport
+                    && (mCameraState != LONGSHOT)
+                    && ((mReceivedSnapNum == mBurstSnapNum) && (mCameraState != LONGSHOT));
+
+            needRestartPreview |= isLongshotDone();
+
+            boolean backCameraRestartPreviewOnPictureTaken = false;
+            boolean frontCameraRestartPreviewOnPictureTaken = false;
+            boolean additionalCameraRestartPreviewOnPictureTaken = false;
+            if (mApplicationContext != null) {
+                backCameraRestartPreviewOnPictureTaken =
+                    mApplicationContext.getResources().getBoolean(R.bool.back_camera_restart_preview_onPictureTaken);
+                frontCameraRestartPreviewOnPictureTaken =
+                    mApplicationContext.getResources().getBoolean(R.bool.front_camera_restart_preview_onPictureTaken);
+            additionalCameraRestartPreviewOnPictureTaken =
+                    mApplicationContext.getResources().getBoolean(R.bool.additional_camera_restart_preview_onPictureTaken);
+            }
+
+            CameraInfo info = CameraHolder.instance().getCameraInfo()[mCameraId];
+            if ((info.facing == CameraInfo.CAMERA_FACING_BACK
+                    && backCameraRestartPreviewOnPictureTaken && (mCameraState != LONGSHOT))
+                    || (info.facing == CameraInfo.CAMERA_FACING_FRONT
+                    && frontCameraRestartPreviewOnPictureTaken && (mCameraState != LONGSHOT))
+                    || (info.facing > CameraInfo.CAMERA_FACING_FRONT
+                    && additionalCameraRestartPreviewOnPictureTaken && (mCameraState != LONGSHOT))) {
+                needRestartPreview = true;
+            }
+
+            if (needRestartPreview) {
+                Log.d(TAG, "JpegPictureCallback: needRestartPreview");
+                setupPreview();
+                if (CameraUtil.FOCUS_MODE_CONTINUOUS_PICTURE.equals(mFocusManager.getFocusMode(false))
+                        || CameraUtil.FOCUS_MODE_MW_CONTINUOUS_PICTURE.equals(mFocusManager.getFocusMode(false))) {
+                    mCameraDevice.cancelAutoFocus();
+                }
+            } else if (((mCameraState != LONGSHOT) && (mReceivedSnapNum == mBurstSnapNum))
+                        || isLongshotDone()){
+                mFocusManager.restartTouchFocusTimer();
+                if (CameraUtil.FOCUS_MODE_CONTINUOUS_PICTURE.equals(mFocusManager.getFocusMode(false))
+                        || CameraUtil.FOCUS_MODE_MW_CONTINUOUS_PICTURE.equals(mFocusManager.getFocusMode(false))) {
+                    mCameraDevice.cancelAutoFocus();
+                }
+                if (!mIsImageCaptureIntent) {
+                    setCameraState(IDLE);
+                }
+                startFaceDetection();
+            }
+
+            int orientation = Exif.getOrientation(exif);
+            if(mCameraId == CameraHolder.instance().getFrontCameraId()) {
+                IconListPreference selfieMirrorPref = (IconListPreference) mPreferenceGroup
+                        .findPreference(CameraSettings.KEY_SELFIE_MIRROR);
+                if (selfieMirrorPref != null && selfieMirrorPref.getValue() != null &&
+                        selfieMirrorPref.getValue().equalsIgnoreCase("enable")) {
+                    jpegData = flipJpeg(jpegData, info.orientation, orientation);
+                    jpegData = addExifTags(jpegData, orientation);
+                }
+            }
+            if (!mIsImageCaptureIntent) {
+                // Burst snapshot. Generate new image name.
+                if (mReceivedSnapNum > 1) {
+                    mSNamedImages.nameNewImage(mCaptureStartTime, mRefocus);
+                }
+                // Calculate the width and the height of the jpeg.
+                Size s = mParameters.getPictureSize();
+                int width, height;
+                if ((mJpegRotation + orientation) % 180 == 0) {
+                    width = s.width;
+                    height = s.height;
+                } else {
+                    width = s.height;
+                    height = s.width;
+                }
+                String pictureFormat = mParameters.get(KEY_PICTURE_FORMAT);
+                if (pictureFormat != null && !pictureFormat.equalsIgnoreCase(PIXEL_FORMAT_JPEG)) {
+                    // overwrite width and height if raw picture
+                    String pair = mParameters.get(KEY_QC_RAW_PICUTRE_SIZE);
+                    if (pair != null) {
+                        int pos = pair.indexOf('x');
+                        if (pos != -1) {
+                            width = Integer.parseInt(pair.substring(0, pos));
+                            height = Integer.parseInt(pair.substring(pos + 1));
+                        }
+                    }
+                }
+                SNamedEntity name = mSNamedImages.getNextNameEntity();
+                String title = (name == null) ? null : name.title;
+                long date = (name == null) ? -1 : name.date;
+                // Handle debug mode outputs
+                if (mDebugUri != null) {
+                    // If using a debug uri, save jpeg there.
+                    saveToDebugUri(jpegData);
+                    // Adjust the title of the debug image shown in mediastore.
+                    if (title != null) {
+                        title = DEBUG_IMAGE_PREFIX + title;
+                    }
+                }
+                if (title == null) {
+                    Log.e(TAG, "Unbalanced name/data pair");
+                } else {
+                    if (date == -1) {
+                        date = mCaptureStartTime;
+                    }
+                    if (mHeading >= 0) {
+                        // heading direction has been updated by the sensor.
+                        ExifTag directionRefTag = exif.buildTag(
+                                ExifInterface.TAG_GPS_IMG_DIRECTION_REF,
+                                ExifInterface.GpsTrackRef.MAGNETIC_DIRECTION);
+                        ExifTag directionTag = exif.buildTag(
+                                ExifInterface.TAG_GPS_IMG_DIRECTION,
+                                new Rational(mHeading, 1));
+                        exif.setTag(directionRefTag);
+                        exif.setTag(directionTag);
+                    }
+                    String mPictureFormat = mParameters.get(KEY_PICTURE_FORMAT);
+                    Log.d(TAG, "capture:" + title + "." + mPictureFormat);
+                    if (mIsBokehMode) {
+                        if (!PERSIST_BOKEH_DEBUG_CHECK && mSaveBokehXmp) {
+                            if (jpegData != null && mCallTime == 3) {
+                                if (mOrigin != null && mBokeh != null) {
+                                    GImage gImage = new GImage(mOrigin, "image/jpeg");
+                                    GDepth gDepth = GDepth.createGDepth(mDepth);
+                                    gDepth.setRoi(new Rect(0,0,width,height));
+                                    mActivity.getMediaSaveService().addXmpImage(mBokeh,gImage,
+                                            gDepth,"bokeh_"+title,date,mLocation,width,height,
+                                            orientation,exif,mOnMediaSavedListener,
+                                            mContentResolver,mPictureFormat);
+                                }
+                            }
+                        } else {
+                            if (mCallTime == 3) {
+                                mActivity.getMediaSaveService().addImage(mDepth,
+                                        title, date, mLocation, width, height,
+                                        orientation, exif, mOnMediaSavedListener,
+                                        mContentResolver, mPictureFormat);
+                            } else {
+                                mActivity.getMediaSaveService().addImage(
+                                        jpegData, title, date, mLocation, width, height,
+                                        orientation, exif, mOnMediaSavedListener,
+                                        mContentResolver, mPictureFormat);
+                            }
+                        }
+                    } else {
+                        mActivity.getMediaSaveService().addImage(
+                                jpegData, title, date, mLocation, width, height,
+                                orientation, exif, mOnMediaSavedListener,
+                                mContentResolver, mPictureFormat);
+                    }
+                }
+                // Animate capture with real jpeg data instead of a preview frame.
+                if ((mCameraState != LONGSHOT) || isLongshotDone()) {
+                    Size pic_size = mParameters.getPictureSize();
+                    if ((pic_size.width <= 352) && (pic_size.height<= 288)) {
+                        mUI.setDownFactor(2); //Downsample by 2 for CIF & below
+                    } else {
+                        mUI.setDownFactor(4);
+                    }
+                    if (mAnimateCapture) {
+                        mUI.animateCapture(jpegData);
+                    }
+                } else {
+                    // In long shot mode, we do not want to update the preview thumbnail
+                    // for each snapshot, instead, keep the last jpeg data and orientation,
+                    // use it to show the final one at the end of long shot.
+                    mLastJpegData = jpegData;
+                    mLastJpegOrientation = orientation;
+                }
+
+            } else {
+                stopPreview();
+                mJpegImageData = jpegData;
+                if (!mQuickCapture) {
+                    mUI.showCapturedImageForReview(jpegData, orientation, false);
+                } else {
+                    onCaptureDone();
+                }
+            }
+            if(!mLongshotActive) {
+                mActivity.updateStorageSpaceAndHint(
+                        new CameraActivity.OnStorageUpdateDoneListener() {
+                    @Override
+                    public void onStorageUpdateDone(long storageSpace) {
+                        mUI.updateRemainingPhotos(--mRemainingPhotos);
+                    }
+                });
+            } else {
+                mUI.updateRemainingPhotos(--mRemainingPhotos);
+            }
+            long now = System.currentTimeMillis();
+            mJpegCallbackFinishTime = now - mJpegPictureCallbackTime;
+            Log.v(TAG, "mJpegCallbackFinishTime = "
+                    + mJpegCallbackFinishTime + "ms");
+
+            if (mReceivedSnapNum == mBurstSnapNum) {
+                mJpegPictureCallbackTime = 0;
+            }
+
+            if (isLongshotDone()) {
+                mLongshotSnapNum = 0;
+            }
+
+            if (mCameraState != LONGSHOT && mReceivedSnapNum == mBurstSnapNum &&
+                        !mIsImageCaptureIntent) {
+                    cancelAutoFocus();
+                }
+            }
+        }
+    }
+
+    private OnSeekBarChangeListener mBlurDegreeListener = new OnSeekBarChangeListener() {
+        public void onStartTrackingTouch(SeekBar bar) {
+        }
+        public void onProgressChanged(SeekBar bar, int progress, boolean fromtouch) {
+            if (mParameters != null) {
+                mParameters.set(CameraSettings.KEY_QC_BOKEH_BLUR_VALUE, progress);
+                mCameraDevice.setParameters(mParameters);
+                Log.d(TAG,"seekbar bokeh degree = "+ progress);
+                mUI.setBokehRenderDegree(progress);
+            }
+        }
+        public void onStopTrackingTouch(SeekBar bar) {
+            final SharedPreferences prefs = PreferenceManager.getDefaultSharedPreferences(mActivity);
+            SharedPreferences.Editor editor = prefs.edit();
+            editor.putInt(CameraSettings.KEY_BOKEH_BLUR_VALUE, bar.getProgress());
+            editor.apply();
+        }
+    };
+
+    private final class AutoFocusCallback implements CameraAFCallback {
+        @Override
+        public void onAutoFocus(
+                boolean focused, CameraProxy camera) {
+            if (mPaused) return;
+
+            mAutoFocusTime = System.currentTimeMillis() - mFocusStartTime;
+            Log.v(TAG, "mAutoFocusTime = " + mAutoFocusTime + "ms");
+            //don't reset the camera state while capture is in progress
+            //otherwise, it might result in another takepicture
+            switch (mCameraState) {
+                case PhotoController.LONGSHOT:
+                case SNAPSHOT_IN_PROGRESS:
+                    break;
+                default:
+                    setCameraState(IDLE);
+                    break;
+            }
+            mCameraDevice.refreshParameters();
+            mFocusManager.setParameters(mCameraDevice.getParameters());
+            mFocusManager.onAutoFocus(focused, mUI.isShutterPressed());
+        }
+    }
+
+    @TargetApi(Build.VERSION_CODES.JELLY_BEAN)
+    private final class AutoFocusMoveCallback
+            implements CameraAFMoveCallback {
+        @Override
+        public void onAutoFocusMoving(
+                boolean moving, CameraProxy camera) {
+            mCameraDevice.refreshParameters();
+            mFocusManager.setParameters(mCameraDevice.getParameters());
+            mFocusManager.onAutoFocusMoving(moving);
+        }
+    }
+
+    /**
+     * This class is just a thread-safe queue for name,date holder objects.
+     */
+    public static class SNamedImages {
+        private Vector<SNamedEntity> mQueue;
+
+        public SNamedImages() {
+            mQueue = new Vector<SNamedEntity>();
+        }
+
+        public void nameNewImage(long date) {
+            SNamedEntity r = new SNamedEntity();
+            r.title = CameraUtil.createJpegName(date);
+            r.date = date;
+            mQueue.add(r);
+        }
+
+        public SNamedEntity getNextNameEntity() {
+            synchronized(mQueue) {
+                if (!mQueue.isEmpty()) {
+                    return mQueue.remove(0);
+                }
+            }
+            return null;
+        }
+
+        public static class SNamedEntity {
+            public String title;
+            public long date;
+        }
+    }
+
+    private void setCameraState(int state) {
+        mCameraState = state;
+        switch (state) {
+            case PhotoController.PREVIEW_STOPPED:
+            case PhotoController.SNAPSHOT_IN_PROGRESS:
+            case PhotoController.LONGSHOT:
+            case PhotoController.SWITCHING_CAMERA:
+                mUI.enableGestures(false);
+                break;
+            case PhotoController.IDLE:
+                mUI.enableGestures(true);
+                break;
+        }
+    }
+
+    private void animateAfterShutter() {
+        // Only animate when in full screen capture mode
+        // i.e. If monkey/a user swipes to the gallery during picture taking,
+        // don't show animation
+        if (!mIsImageCaptureIntent) {
+            mUI.animateFlash();
+        }
+    }
+
+    @Override
+    public boolean capture() {
+        // If we are already in the middle of taking a snapshot or the image save request
+        // is full then ignore.
+        if (mCameraDevice == null || mCameraState == SNAPSHOT_IN_PROGRESS
+                || mCameraState == SWITCHING_CAMERA
+                || mCameraState == PREVIEW_STOPPED
+                || mActivity.getMediaSaveService() == null
+                || mActivity.getMediaSaveService().isQueueFull()) {
+            return false;
+        }
+        mCaptureStartTime = System.currentTimeMillis();
+        mPostViewPictureCallbackTime = 0;
+        mJpegImageData = null;
+
+        final boolean animateBefore = (mSceneMode == CameraUtil.SCENE_MODE_HDR);
+
+        if (animateBefore) {
+            animateAfterShutter();
+        }
+
+        if (mCameraState == LONGSHOT) {
+            mLongshotSnapNum = 0;
+            mCameraDevice.setLongshot(true);
+        }
+
+        // Set rotation and gps data.
+        int orientation = (mOrientation + mOrientationOffset) % 360;
+        mJpegRotation = CameraUtil.getJpegRotation(mCameraId, orientation);
+        String pictureFormat = mParameters.get(KEY_PICTURE_FORMAT);
+        Location loc = getLocationAccordPictureFormat(pictureFormat);
+
+        synchronized (mCameraDevice) {
+            mParameters.setRotation(mJpegRotation);
+            CameraUtil.setGpsParameters(mParameters, loc);
+
+            mParameters.remove(CameraSettings.KEY_QC_LEGACY_BURST);
+
+            // Unlock AE&AWB, if they continue
+            // to be locked during snapshot, then
+            // side effects could be triggered w.r.t.
+            // flash.
+            mFocusManager.setAeAwbLock(false);
+            setAutoExposureLockIfSupported();
+            setAutoWhiteBalanceLockIfSupported();
+
+            mCameraDevice.setParameters(mParameters);
+            mParameters = mCameraDevice.getParameters();
+        }
+
+        mBurstSnapNum = CameraUtil.getNumSnapsPerShutter(mParameters);
+        mReceivedSnapNum = 0;
+        mPreviewRestartSupport = PersistUtil.isPreviewRestartEnabled();
+        mPreviewRestartSupport &= CameraSettings.isInternalPreviewSupported(
+                mParameters);
+        mPreviewRestartSupport &= (mBurstSnapNum == 1);
+        // Restart is needed  if HDR is enabled
+        mPreviewRestartSupport &= !CameraUtil.SCENE_MODE_HDR.equals(mSceneMode);
+        mPreviewRestartSupport &= PIXEL_FORMAT_JPEG.equalsIgnoreCase(
+                pictureFormat);
+
+        mUI.enableShutter(false);
+
+        // We don't want user to press the button again while taking a
+        // multi-second HDR photo. For longshot, no need to disable.
+        if (!CameraUtil.SCENE_MODE_HDR.equals(mSceneMode)) {
+            mHandler.sendEmptyMessageDelayed(UNLOCK_CAM_SHUTTER, 120);
+        }
+
+        if (!isShutterSoundOn()) {
+            mCameraDevice.enableShutterSound(false);
+        } else {
+            mCameraDevice.enableShutterSound(true);
+        }
+
+        mSaveBokehXmp = mIsBokehMode && mDepthSuccess;
+
+        if (mCameraState == LONGSHOT) {
+            mLongShotCaptureCountLimit = SystemProperties.getInt(
+                                    "persist.sys.camera.longshot.shotnum", 0);
+            mLongShotCaptureCount = 1;
+            if(mLongshotSave) {
+                mCameraDevice.takePicture(mHandler,
+                        new LongshotShutterCallback(),
+                        mRawPictureCallback, mPostViewPictureCallback,
+                        new LongshotPictureCallback(loc));
+            } else {
+                mCameraDevice.takePicture(mHandler,
+                        new LongshotShutterCallback(),
+                        mRawPictureCallback, mPostViewPictureCallback,
+                        new JpegPictureCallback(loc));
+            }
+        } else {
+            mCameraDevice.takePicture(mHandler,
+                    new ShutterCallback(!animateBefore),
+                    mRawPictureCallback, mPostViewPictureCallback,
+                    new JpegPictureCallback(loc));
+            setCameraState(SNAPSHOT_IN_PROGRESS);
+        }
+
+        mSNamedImages.nameNewImage(mCaptureStartTime);
+
+        mFaceDetectionStarted = false;
+
+        UsageStatistics.onEvent(UsageStatistics.COMPONENT_CAMERA,
+                UsageStatistics.ACTION_CAPTURE_DONE, "Photo", 0,
+                UsageStatistics.hashFileName(mSNamedImages.mQueue.lastElement().title + ".jpg"));
+        return true;
+    }
+
+    @Override
+    public void setFocusParameters() {
+        setCameraParameters(UPDATE_PARAM_PREFERENCE);
+    }
+
+    private Location getLocationAccordPictureFormat(String pictureFormat) {
+        if (pictureFormat != null &&
+                PIXEL_FORMAT_JPEG.equalsIgnoreCase(pictureFormat)) {
+            return mLocationManager.getCurrentLocation();
+        }
+        return null;
+    }
+
+    private int getPreferredCameraId(ComboPreferences preferences) {
+        int intentCameraId = CameraUtil.getCameraFacingIntentExtras(mActivity);
+        if (intentCameraId != -1) {
+            // Testing purpose. Launch a specific camera through the intent
+            // extras.
+            return intentCameraId;
+        } else {
+            return CameraSettings.readPreferredCameraId(preferences);
+        }
+    }
+
+    private void updateLongshotScene() {
+        String[] longshotScenes = mActivity.getResources().getStringArray(
+                R.array.longshot_scenemodes);
+        if (longshotScenes.length == 0) {
+            mUI.overrideSettings(CameraSettings.KEY_LONGSHOT, null);
+            return;
+        }
+        boolean useLongshot = false;
+        for (String scene : longshotScenes) {
+            if (scene.equals(mSceneMode)) {
+                useLongshot = true;
+                break;
+            }
+        }
+        mUI.overrideSettings(CameraSettings.KEY_LONGSHOT,
+                useLongshot ? mActivity.getString(R.string.setting_on_value) :
+                              mActivity.getString(R.string.setting_off_value));
+    }
+
+    private void updateCameraSettings() {
+        String sceneMode = null;
+        String flashMode = null;
+        String focusMode = null;
+        boolean disableLongShot = false;
+
+        String continuousShotOn =
+                mActivity.getString(R.string.setting_on_value);
+        String continuousShot =
+                mParameters.get("long-shot");
+
+
+        if ((continuousShot != null) && continuousShot.equals(continuousShotOn)) {
+            String pictureFormat = mActivity.getString(R.string.
+                    pref_camera_picture_format_value_jpeg);
+            mUI.overrideSettings(CameraSettings.KEY_PICTURE_FORMAT, pictureFormat);
+        } else {
+            mUI.overrideSettings(CameraSettings.KEY_PICTURE_FORMAT, null);
+        }
+
+        if (!Parameters.SCENE_MODE_AUTO.equals(mSceneMode) &&
+                !"sports".equals(mSceneMode)) {
+            flashMode = Parameters.FLASH_MODE_OFF;
+            focusMode = mFocusManager.getFocusMode(false);
+            colorEffect = mParameters.getColorEffect();
+            String defaultEffect = mActivity.getString(R.string.pref_camera_coloreffect_default);
+            if (CameraUtil.SCENE_MODE_HDR.equals(mSceneMode)) {
+                disableLongShot = true;
+                if (colorEffect != null & !colorEffect.equals(defaultEffect)) {
+                    // Change the colorEffect to default(None effect) when HDR ON.
+                    colorEffect = defaultEffect;
+                    mUI.setPreference(CameraSettings.KEY_COLOR_EFFECT, colorEffect);
+                    mParameters.setColorEffect(colorEffect);
+                    mCameraDevice.setParameters(mParameters);
+                    mParameters = mCameraDevice.getParameters();
+                }
+            }
+
+        }
+
+        if (disableLongShot || mIsBokehMode) {
+            mUI.overrideSettings(CameraSettings.KEY_LONGSHOT,
+                    mActivity.getString(R.string.setting_off_value));
+        } else {
+            updateLongshotScene();
+        }
+
+        if (flashMode == null) {
+            // Restore saved flash mode or default mode
+            if (mSavedFlashMode == null) {
+                mSavedFlashMode =  mPreferences.getString(
+                    CameraSettings.KEY_FLASH_MODE,
+                    mActivity.getString(R.string.pref_camera_flashmode_default));
+            }
+            mUI.setPreference(CameraSettings.KEY_FLASH_MODE, mSavedFlashMode);
+            mSavedFlashMode = null;
+        } else {
+            // Save the current flash mode
+            if (mSavedFlashMode == null) {
+                mSavedFlashMode =  mPreferences.getString(
+                    CameraSettings.KEY_FLASH_MODE,
+                    mActivity.getString(R.string.pref_camera_flashmode_default));
+            }
+            mUI.overrideSettings(CameraSettings.KEY_FLASH_MODE, flashMode);
+        }
+
+        if(mCameraId != CameraHolder.instance().getFrontCameraId()) {
+            CameraSettings.removePreferenceFromScreen(mPreferenceGroup, CameraSettings.KEY_SELFIE_FLASH);
+            CameraSettings.removePreferenceFromScreen(mPreferenceGroup, CameraSettings.KEY_SELFIE_MIRROR);
+        } else {
+            ListPreference prefSelfieMirror = mPreferenceGroup.findPreference(CameraSettings.KEY_SELFIE_MIRROR);
+            if(prefSelfieMirror != null && prefSelfieMirror.getValue() != null
+                    && prefSelfieMirror.getValue().equalsIgnoreCase("enable")) {
+                mUI.overrideSettings(CameraSettings.KEY_LONGSHOT, "off");
+            }
+        }
+
+        String bokehMode = mPreferences.getString(
+                CameraSettings.KEY_BOKEH_MODE,
+                mActivity.getString(R.string.pref_camera_bokeh_mode_default));
+        if (!bokehMode.equals(mActivity.getString(
+                R.string.pref_camera_bokeh_mode_entry_value_disable))) {
+            mIsBokehMode = true;
+            if (mCameraDevice != null) {
+                mCameraDevice.setMetadataCb(mMetaDataCallback);
+            }
+            mUI.overrideSettings(CameraSettings.KEY_FLASH_MODE, Parameters.FLASH_MODE_OFF);
+            mUI.overrideSettings(CameraSettings.KEY_SCENE_MODE, Parameters.SCENE_MODE_AUTO);
+            final SharedPreferences prefs = PreferenceManager.getDefaultSharedPreferences(mActivity);
+            final int degree = prefs.getInt(CameraSettings.KEY_BOKEH_BLUR_VALUE,50);
+            mUI.getBokehDegreeBar().setProgress(degree);
+            mUI.getBokehDegreeBar().setOnSeekBarChangeListener(mBlurDegreeListener);
+            mUI.enableBokehRender(true);
+            mUI.setBokehRenderDegree(degree);
+            mBokehTipText.setVisibility(View.VISIBLE);
+        } else {
+            mIsBokehMode = false;
+            if (mCameraDevice != null) {
+                mCameraDevice.setMetadataCb(null);
+            }
+            mUI.overrideSettings(CameraSettings.KEY_BOKEH_MPO,
+                    mActivity.getString(R.string.pref_camera_bokeh_mpo_default));
+            mUI.overrideSettings(CameraSettings.KEY_BOKEH_BLUR_VALUE,
+                    mActivity.getString(R.string.pref_camera_bokeh_blur_degree_default));
+            mUI.getBokehDegreeBar().setOnSeekBarChangeListener(null);
+            mUI.getBokehDegreeBar().setVisibility(View.GONE);
+            mUI.enableBokehRender(false);
+            mBokehTipText.setVisibility(View.GONE);
+        }
+    }
+
+    private void loadCameraPreferences() {
+        CameraSettings settings = new CameraSettings(mActivity, mInitialParams,
+                mCameraId, CameraHolder.instance().getCameraInfo());
+        mPreferenceGroup = settings.getPreferenceGroup(R.xml.camera_preferences);
+
+        int numOfCams = Camera.getNumberOfCameras();
+
+        Log.e(TAG,"loadCameraPreferences() updating camera_id pref");
+
+        IconListPreference switchIconPref =
+                (IconListPreference)mPreferenceGroup.findPreference(
+                CameraSettings.KEY_CAMERA_ID);
+
+        //if numOfCams < 2 then switchIconPref will be null as there is no switch icon in this case
+        if (switchIconPref == null)
+            return;
+
+        int[] iconIds = new int[numOfCams];
+        String[] entries = new String[numOfCams];
+        String[] labels = new String[numOfCams];
+        int[] largeIconIds = new int[numOfCams];
+
+        for(int i=0;i<numOfCams;i++) {
+            CameraInfo info = CameraHolder.instance().getCameraInfo()[i];
+            if(info.facing == CameraInfo.CAMERA_FACING_BACK) {
+                iconIds[i] = R.drawable.ic_switch_back;
+                entries[i] = mActivity.getResources().getString(R.string.pref_camera_id_entry_back);
+                labels[i] = mActivity.getResources().getString(R.string.pref_camera_id_label_back);
+                largeIconIds[i] = R.drawable.ic_switch_back;
+            } else {
+                iconIds[i] = R.drawable.ic_switch_front;
+                entries[i] = mActivity.getResources().getString(R.string.pref_camera_id_entry_front);
+                labels[i] = mActivity.getResources().getString(R.string.pref_camera_id_label_front);
+                largeIconIds[i] = R.drawable.ic_switch_front;
+            }
+        }
+
+        switchIconPref.setIconIds(iconIds);
+        switchIconPref.setEntries(entries);
+        switchIconPref.setLabels(labels);
+        switchIconPref.setLargeIconIds(largeIconIds);
+
+    }
+
+    @Override
+    public void onOrientationChanged(int orientation) {
+        // We keep the last known orientation. So if the user first orient
+        // the camera then point the camera to floor or sky, we still have
+        // the correct orientation.
+        if (orientation == OrientationEventListener.ORIENTATION_UNKNOWN) return;
+        orientation = (orientation - mOrientationOffset + 360) % 360;
+        int oldOrientation = mOrientation;
+        mOrientation = CameraUtil.roundOrientation(orientation, mOrientation);
+        if (oldOrientation != mOrientation) {
+            if (mParameters != null && mCameraDevice != null && mCameraState == IDLE) {
+                Log.v(TAG, "onOrientationChanged, update parameters");
+                synchronized (mCameraDevice) {
+                    setFlipValue();
+                    mCameraDevice.setParameters(mParameters);
+                }
+            }
+            mUI.tryToCloseSubList();
+            mUI.setOrientation(mOrientation, true);
+            if (mGraphView != null) {
+                mGraphView.setRotation(-mOrientation);
+            }
+        }
+
+        // Show the toast after getting the first orientation changed.
+        if (mHandler.hasMessages(SHOW_TAP_TO_FOCUS_TOAST)) {
+            mHandler.removeMessages(SHOW_TAP_TO_FOCUS_TOAST);
+            showTapToFocusToast();
+        }
+    }
+
+    @Override
+    public void onStop() {}
+
+    @Override
+    public void onDestroy() {}
+
+    @Override
+    public void onCaptureCancelled() {
+        mActivity.setResultEx(Activity.RESULT_CANCELED, new Intent());
+        mActivity.finish();
+    }
+
+    @Override
+    public void onCaptureRetake() {
+        if (mPaused)
+            return;
+        mUI.hidePostCaptureAlert();
+        setupPreview();
+    }
+
+    @Override
+    public void onCaptureDone() {
+        if (mPaused) {
+            return;
+        }
+
+        byte[] data = mJpegImageData;
+
+        if (mCropValue == null) {
+            // First handle the no crop case -- just return the value.  If the
+            // caller specifies a "save uri" then write the data to its
+            // stream. Otherwise, pass back a scaled down version of the bitmap
+            // directly in the extras.
+            if (mSaveUri != null) {
+                OutputStream outputStream = null;
+                try {
+                    outputStream = mContentResolver.openOutputStream(mSaveUri);
+                    outputStream.write(data);
+                    outputStream.close();
+
+                    mActivity.setResultEx(Activity.RESULT_OK);
+                    mActivity.finish();
+                } catch (IOException ex) {
+                    // ignore exception
+                } finally {
+                    CameraUtil.closeSilently(outputStream);
+                }
+            } else {
+                ExifInterface exif = Exif.getExif(data);
+                int orientation = Exif.getOrientation(exif);
+                Bitmap bitmap = CameraUtil.makeBitmap(data, 50 * 1024);
+                bitmap = CameraUtil.rotate(bitmap, orientation);
+                mActivity.setResultEx(Activity.RESULT_OK,
+                        new Intent("inline-data").putExtra("data", bitmap));
+                mActivity.finish();
+            }
+        } else {
+            // Save the image to a temp file and invoke the cropper
+            Uri tempUri = null;
+            FileOutputStream tempStream = null;
+            try {
+                File path = mActivity.getFileStreamPath(sTempCropFilename);
+                path.delete();
+                tempStream = mActivity.openFileOutput(sTempCropFilename, 0);
+                tempStream.write(data);
+                tempStream.close();
+                tempUri = Uri.fromFile(path);
+            } catch (FileNotFoundException ex) {
+                mActivity.setResultEx(Activity.RESULT_CANCELED);
+                mActivity.finish();
+                return;
+            } catch (IOException ex) {
+                mActivity.setResultEx(Activity.RESULT_CANCELED);
+                mActivity.finish();
+                return;
+            } finally {
+                CameraUtil.closeSilently(tempStream);
+            }
+
+            Bundle newExtras = new Bundle();
+            if (mCropValue.equals("circle")) {
+                newExtras.putString("circleCrop", "true");
+            }
+            if (mSaveUri != null) {
+                newExtras.putParcelable(MediaStore.EXTRA_OUTPUT, mSaveUri);
+            } else {
+                newExtras.putBoolean(CameraUtil.KEY_RETURN_DATA, true);
+            }
+            if (mActivity.isSecureCamera()) {
+                newExtras.putBoolean(CameraUtil.KEY_SHOW_WHEN_LOCKED, true);
+            }
+
+            // TODO: Share this constant.
+            final String CROP_ACTION = "com.android.camera.action.CROP";
+            Intent cropIntent = new Intent(CROP_ACTION);
+
+            cropIntent.setData(tempUri);
+            cropIntent.putExtras(newExtras);
+
+            mActivity.startActivityForResult(cropIntent, REQUEST_CROP);
+        }
+    }
+
+    @Override
+    public void onShutterButtonFocus(boolean pressed) {
+        if (mCameraDevice == null
+                || mPaused || mUI.collapseCameraControls()
+                || (mCameraState == SNAPSHOT_IN_PROGRESS)
+                || (mCameraState == PREVIEW_STOPPED)
+                || (null == mFocusManager)) {
+            Log.v(TAG, "onShutterButtonFocus error case mCameraState = " + mCameraState
+                + "mCameraDevice = " + mCameraDevice + "mPaused =" + mPaused);
+            return;
+        }
+
+        synchronized(mCameraDevice) {
+           if (mCameraState == LONGSHOT) {
+               mLongshotActive = false;
+               mUI.enableShutter(false);
+           }
+        }
+
+        // Do not do focus if there is not enough storage.
+        if (pressed && !canTakePicture()) return;
+
+        if (pressed) {
+            mFocusManager.onShutterDown();
+        } else {
+            // for countdown mode, we need to postpone the shutter release
+            // i.e. lock the focus during countdown.
+            if (!mUI.isCountingDown()) {
+                mFocusManager.onShutterUp();
+            }
+        }
+    }
+
+    @Override
+    public synchronized void onShutterButtonClick() {
+        if ((mCameraDevice == null)
+                || mPaused || mUI.collapseCameraControls()
+                || !mUI.mMenuInitialized
+                || (mCameraState == SWITCHING_CAMERA)
+                || (mCameraState == PREVIEW_STOPPED)
+                || (mCameraState == LONGSHOT)
+                || (null == mFocusManager)) return;
+
+        // Do not take the picture if there is not enough storage.
+        if (mActivity.getStorageSpaceBytes() <= Storage.LOW_STORAGE_THRESHOLD_BYTES) {
+            Log.i(TAG, "Not enough space or storage not ready. remaining="
+                    + mActivity.getStorageSpaceBytes());
+            return;
+        }
+        Log.v(TAG, "onShutterButtonClick: mCameraState=" + mCameraState);
+
+        if (mSceneMode == CameraUtil.SCENE_MODE_HDR) {
+            mUI.hideSwitcher();
+            mUI.setSwipingEnabled(false);
+        }
+
+         //Need to disable focus for ZSL mode
+        if (mFocusManager != null) {
+            mFocusManager.setZslEnable(false);
+        }
+
+        // If the user wants to do a snapshot while the previous one is still
+        // in progress, remember the fact and do it after we finish the previous
+        // one and re-start the preview. Snapshot in progress also includes the
+        // state that autofocus is focusing and a picture will be taken when
+        // focus callback arrives.
+        if ((((mFocusManager != null) && mFocusManager.isFocusingSnapOnFinish())
+                || mCameraState == SNAPSHOT_IN_PROGRESS)
+                && !mIsImageCaptureIntent) {
+            mSnapshotOnIdle = true;
+            return;
+        }
+
+        String timer = mPreferences.getString(
+                CameraSettings.KEY_TIMER,
+                mActivity.getString(R.string.pref_camera_timer_default));
+        boolean playSound = mPreferences.getString(CameraSettings.KEY_TIMER_SOUND_EFFECTS,
+                mActivity.getString(R.string.pref_camera_timer_sound_default))
+                .equals(mActivity.getString(R.string.setting_on_value));
+
+        int seconds = Integer.parseInt(timer);
+        // When shutter button is pressed, check whether the previous countdown is
+        // finished. If not, cancel the previous countdown and start a new one.
+        if (mUI.isCountingDown()) {
+            mUI.cancelCountDown();
+        }
+
+        mSnapshotOnIdle = false;
+        initiateSnap();
+    }
+
+    private boolean isShutterSoundOn() {
+        IconListPreference shutterSoundPref = (IconListPreference) mPreferenceGroup
+                .findPreference(CameraSettings.KEY_SHUTTER_SOUND);
+        if (shutterSoundPref != null && shutterSoundPref.getValue() != null &&
+                shutterSoundPref.getValue().equalsIgnoreCase("disable")) {
+            return false;
+        }
+        return true;
+    }
+
+    private void initiateSnap()
+    {
+        if(mPreferences.getString(CameraSettings.KEY_SELFIE_FLASH,
+                mActivity.getString(R.string.pref_selfie_flash_default))
+                .equalsIgnoreCase("on") &&
+                mCameraId == CameraHolder.instance().getFrontCameraId()) {
+            mUI.startSelfieFlash();
+            if(selfieThread == null) {
+                selfieThread = new SelfieThread();
+                selfieThread.start();
+            }
+        } else {
+            mFocusManager.doSnap();
+        }
+    }
+
+    @Override
+    public void onShutterButtonLongClick() {
+        // Do not take the picture if there is not enough storage.
+        if (mActivity.getStorageSpaceBytes() <= Storage.LOW_STORAGE_THRESHOLD_BYTES) {
+            Log.i(TAG, "Not enough space or storage not ready. remaining="
+                    + mActivity.getStorageSpaceBytes());
+            return;
+        }
+
+        if ((null != mCameraDevice) && ((mCameraState == IDLE) || (mCameraState == FOCUSING))) {
+            //Add on/off Menu for longshot
+            String longshot_enable = mPreferences.getString(
+                CameraSettings.KEY_LONGSHOT,
+                mActivity.getString(R.string.pref_camera_longshot_default));
+
+            Log.d(TAG, "longshot_enable = " + longshot_enable);
+            if (longshot_enable.equals("on")) {
+                boolean enable = PersistUtil.isLongSaveEnabled();
+                mLongshotSave = enable;
+
+                //Cancel the previous countdown when long press shutter button for longshot.
+                if (mUI.isCountingDown()) {
+                    mUI.cancelCountDown();
+                }
+                //check whether current memory is enough for longshot.
+                if(isLongshotNeedCancel()) {
+                    return;
+                }
+                mLongshotActive = true;
+                setCameraState(PhotoController.LONGSHOT);
+                mFocusManager.doSnap();
+            }
+        }
+    }
+
+    @Override
+    public void installIntentFilter() {
+        // Do nothing.
+    }
+
+    @Override
+    public boolean updateStorageHintOnResume() {
+        return mFirstTimeInitialized;
+    }
+
+    @Override
+    public void onResumeBeforeSuper() {
+        mPaused = false;
+        if (mFocusManager == null) initializeFocusManager();
+    }
+
+    private void openCamera() {
+        // We need to check whether the activity is paused before long
+        // operations to ensure that onPause() can be done ASAP.
+        if (mPaused) {
+            return;
+        }
+        Log.v(TAG, "Open camera device.");
+        mCameraDevice = CameraUtil.openCamera(
+                mActivity, mCameraId, mHandler,
+                mActivity.getCameraOpenErrorCallback());
+        if (mCameraDevice == null) {
+            Log.e(TAG, "Failed to open camera:" + mCameraId);
+            mHandler.sendEmptyMessage(OPEN_CAMERA_FAIL);
+            return;
+        }
+        mParameters = mCameraDevice.getParameters();
+        mCameraPreviewParamsReady = true;
+        mInitialParams = mCameraDevice.getParameters();
+        if (mFocusManager == null) {
+            initializeFocusManager();
+        } else {
+            mFocusManager.setParameters(mInitialParams);
+        }
+        initializeCapabilities();
+        mHandler.sendEmptyMessageDelayed(CAMERA_OPEN_DONE, 100);
+        return;
+    }
+
+    @Override
+    public void onResumeAfterSuper() {
+        mUI.showSurfaceView();
+        // Add delay on resume from lock screen only, in order to to speed up
+        // the onResume --> onPause --> onResume cycle from lock screen.
+        // Don't do always because letting go of thread can cause delay.
+        String action = mActivity.getIntent().getAction();
+        if (MediaStore.INTENT_ACTION_STILL_IMAGE_CAMERA.equals(action)
+                || MediaStore.INTENT_ACTION_STILL_IMAGE_CAMERA_SECURE.equals(action)) {
+            Log.v(TAG, "On resume, from lock screen.");
+
+            // Note: onPauseAfterSuper() will delete this runnable, so we will
+            // at most have 1 copy queued up.
+            mHandler.postDelayed(new Runnable() {
+                public void run() {
+                    onResumeTasks();
+                }
+            }, ON_RESUME_TASKS_DELAY_MSEC);
+        } else {
+            Log.v(TAG, "On resume.");
+            onResumeTasks();
+        }
+
+        mUI.setSwitcherIndex();
+
+        mHandler.post(new Runnable() {
+            @Override
+            public void run() {
+                mActivity.updateStorageSpaceAndHint();
+                updateRemainingPhotos();
+            }
+        });
+    }
+
+    private void updateRemainingPhotos() {
+        if (mJpegFileSizeEstimation != 0) {
+            mRemainingPhotos = (int)
+                    ((mActivity.getStorageSpaceBytes() - Storage.LOW_STORAGE_THRESHOLD_BYTES)
+                    / mJpegFileSizeEstimation);
+        } else {
+            mRemainingPhotos = -1;
+        }
+        mUI.updateRemainingPhotos(mRemainingPhotos);
+    }
+
+    private void onResumeTasks() {
+        Log.v(TAG, "Executing onResumeTasks.");
+        if (mOpenCameraFail || mCameraDisabled) return;
+
+        if (mOpenCameraThread == null) {
+            mOpenCameraThread = new OpenCameraThread();
+            mOpenCameraThread.start();
+        }
+
+        mUI.applySurfaceChange(SPhotoUI.SURFACE_STATUS.SURFACE_VIEW);
+
+        mJpegPictureCallbackTime = 0;
+        mZoomValue = 0;
+
+        // If first time initialization is not finished, put it in the
+        // message queue.
+        if (!mFirstTimeInitialized) {
+            mHandler.sendEmptyMessage(FIRST_TIME_INIT);
+        } else {
+            initializeSecondTime();
+        }
+        mUI.initDisplayChangeListener();
+        keepScreenOnAwhile();
+
+        UsageStatistics.onContentViewChanged(
+                UsageStatistics.COMPONENT_CAMERA, "SPhotoModule");
+
+        Sensor gsensor = mSensorManager.getDefaultSensor(Sensor.TYPE_ACCELEROMETER);
+        if (gsensor != null) {
+            mSensorManager.registerListener(this, gsensor, SensorManager.SENSOR_DELAY_NORMAL);
+        }
+
+        Sensor msensor = mSensorManager.getDefaultSensor(Sensor.TYPE_MAGNETIC_FIELD);
+        if (msensor != null) {
+            mSensorManager.registerListener(this, msensor, SensorManager.SENSOR_DELAY_NORMAL);
+        }
+
+        mOnResumeTime = SystemClock.uptimeMillis();
+        checkDisplayRotation();
+
+        mAnimateCapture = PersistUtil.isCaptureAnimationEnabled();
+    }
+
+    @Override
+    public void onPauseBeforeSuper() {
+        mPaused = true;
+        mUI.applySurfaceChange(SPhotoUI.SURFACE_STATUS.HIDE);
+
+        Sensor gsensor = mSensorManager.getDefaultSensor(Sensor.TYPE_ACCELEROMETER);
+        if (gsensor != null) {
+            mSensorManager.unregisterListener(this, gsensor);
+        }
+
+        Sensor msensor = mSensorManager.getDefaultSensor(Sensor.TYPE_MAGNETIC_FIELD);
+        if (msensor != null) {
+            mSensorManager.unregisterListener(this, msensor);
+        }
+
+        if(selfieThread != null) {
+            selfieThread.interrupt();
+        }
+        mUI.stopSelfieFlash();
+
+        Log.d(TAG, "remove idle handleer in onPause");
+        removeIdleHandler();
+    }
+
+    @Override
+    public void onPauseAfterSuper() {
+        Log.v(TAG, "On pause.");
+        mUI.showPreviewCover();
+        mUI.hideSurfaceView();
+
+        try {
+            if (mOpenCameraThread != null) {
+                mOpenCameraThread.join();
+            }
+        } catch (InterruptedException ex) {
+            // ignore
+        }
+        mOpenCameraThread = null;
+        // Reset the focus first. Camera CTS does not guarantee that
+        // cancelAutoFocus is allowed after preview stops.
+        if (mCameraDevice != null && mCameraState != PREVIEW_STOPPED) {
+            mCameraDevice.cancelAutoFocus();
+        }
+        // If the camera has not been opened asynchronously yet,
+        // and startPreview hasn't been called, then this is a no-op.
+        // (e.g. onResume -> onPause -> onResume).
+        stopPreview();
+
+        // Load the power shutter
+        mActivity.initPowerShutter(mPreferences);
+
+        // Load max brightness
+        mActivity.initMaxBrightness(mPreferences);
+
+        mSNamedImages = null;
+
+        if (mLocationManager != null) mLocationManager.recordLocation(false);
+
+        // If we are in an image capture intent and has taken
+        // a picture, we just clear it in onPause.
+        mJpegImageData = null;
+
+        // Remove the messages and runnables in the queue.
+        mHandler.removeCallbacksAndMessages(null);
+
+        closeCamera();
+
+        resetScreenOn();
+        mUI.onPause();
+
+        mPendingSwitchCameraId = -1;
+        if (mFocusManager != null) mFocusManager.removeMessages();
+        MediaSaveService s = mActivity.getMediaSaveService();
+        if (s != null) {
+            s.setListener(null);
+        }
+        mUI.removeDisplayChangeListener();
+    }
+
+    /**
+     * The focus manager is the first UI related element to get initialized,
+     * and it requires the RenderOverlay, so initialize it here
+     */
+    private void initializeFocusManager() {
+        // Create FocusManager object. startPreview needs it.
+        // if mFocusManager not null, reuse it
+        // otherwise create a new instance
+        if (mFocusManager != null) {
+            mFocusManager.removeMessages();
+        } else {
+            CameraInfo info = CameraHolder.instance().getCameraInfo()[mCameraId];
+            mMirror = (info.facing == CameraInfo.CAMERA_FACING_FRONT);
+            String[] defaultFocusModes = mActivity.getResources().getStringArray(
+                    R.array.pref_camera_focusmode_default_array);
+            synchronized (this){
+                if (mFocusManager == null) {
+                    mFocusManager = new FocusOverlayManager(mPreferences, defaultFocusModes,
+                            mInitialParams, this, mMirror,
+                            mActivity.getMainLooper(), mUI.getFocusRing(), mActivity);
+                }
+            }
+        }
+    }
+
+    @Override
+    public void onConfigurationChanged(Configuration newConfig) {
+        Log.v(TAG, "onConfigurationChanged");
+        setDisplayOrientation();
+        resizeForPreviewAspectRatio();
+    }
+
+    @Override
+    public void updateCameraOrientation() {
+        if (mDisplayRotation != CameraUtil.getDisplayRotation(mActivity)) {
+            setDisplayOrientation();
+        }
+    }
+
+    @Override
+    public void onActivityResult(
+            int requestCode, int resultCode, Intent data) {
+        switch (requestCode) {
+            case REQUEST_CROP: {
+                Intent intent = new Intent();
+                if (data != null) {
+                    Bundle extras = data.getExtras();
+                    if (extras != null) {
+                        intent.putExtras(extras);
+                    }
+                }
+                mActivity.setResultEx(resultCode, intent);
+                mActivity.finish();
+
+                File path = mActivity.getFileStreamPath(sTempCropFilename);
+                path.delete();
+
+                break;
+            }
+        }
+    }
+
+    protected CameraManager.CameraProxy getCamera() {
+        return mCameraDevice;
+    }
+
+    private boolean canTakePicture() {
+        return isCameraIdle() && (mActivity.getStorageSpaceBytes() > Storage.LOW_STORAGE_THRESHOLD_BYTES);
+    }
+
+    @Override
+    public void autoFocus() {
+        mFocusStartTime = System.currentTimeMillis();
+        mCameraDevice.autoFocus(mHandler, mAutoFocusCallback);
+        setCameraState(FOCUSING);
+    }
+
+    @Override
+    public void cancelAutoFocus() {
+        if (null != mCameraDevice ) {
+            mCameraDevice.cancelAutoFocus();
+            setCameraState(IDLE);
+            mFocusManager.setAeAwbLock(false);
+            setCameraParameters(UPDATE_PARAM_PREFERENCE);
+        }
+    }
+
+    // Preview area is touched. Handle touch focus.
+    @Override
+    public void onSingleTapUp(View view, int x, int y) {
+        if (mPaused || mCameraDevice == null || !mFirstTimeInitialized
+                || mCameraState == SNAPSHOT_IN_PROGRESS
+                || mCameraState == SWITCHING_CAMERA
+                || mCameraState == PREVIEW_STOPPED) {
+            return;
+        }
+        // Check if metering area or focus area is supported.
+        if (!mFocusAreaSupported && !mMeteringAreaSupported) return;
+        mFocusManager.onSingleTapUp(x, y);
+    }
+
+    @Override
+    public boolean onBackPressed() {
+        return mUI.onBackPressed();
+    }
+
+    @Override
+    public boolean onKeyDown(int keyCode, KeyEvent event) {
+        // Do not handle any key if the activity is
+        // not in active camera/video mode
+        if (!mActivity.isInCameraApp()) {
+            return false;
+        }
+        switch (keyCode) {
+            case KeyEvent.KEYCODE_VOLUME_UP:
+            case KeyEvent.KEYCODE_MEDIA_NEXT:
+                if (mFirstTimeInitialized && (mUI.mMenuInitialized)) {
+                    if (!CameraActivity.mPowerShutter && !CameraUtil.hasCameraKey()) {
+                        onShutterButtonFocus(true);
+                    } else {
+                        mUI.onScaleStepResize(true);
+                    }
+                }
+                return true;
+            case KeyEvent.KEYCODE_VOLUME_DOWN:
+            case KeyEvent.KEYCODE_MEDIA_PREVIOUS:
+                if (mFirstTimeInitialized && (mUI.mMenuInitialized)) {
+                    if (!CameraActivity.mPowerShutter && !CameraUtil.hasCameraKey()) {
+                        onShutterButtonFocus(true);
+                    } else {
+                        mUI.onScaleStepResize(false);
+                    }
+                }
+                return true;
+            case KeyEvent.KEYCODE_FOCUS:
+                if (mFirstTimeInitialized) {
+                    if (event.getRepeatCount() == 0) {
+                        onShutterButtonFocus(true);
+                    }
+                    return true;
+                }
+                return false;
+            case KeyEvent.KEYCODE_CAMERA:
+            case KeyEvent.KEYCODE_HEADSETHOOK:
+                if (mFirstTimeInitialized && event.getRepeatCount() == 0) {
+                    onShutterButtonClick();
+                }
+                return true;
+            case KeyEvent.KEYCODE_DPAD_CENTER:
+                // If we get a dpad center event without any focused view, move
+                // the focus to the shutter button and press it.
+                if (mFirstTimeInitialized && event.getRepeatCount() == 0) {
+                    // Start auto-focus immediately to reduce shutter lag. After
+                    // the shutter button gets the focus, onShutterButtonFocus()
+                    // will be called again but it is fine.
+                    onShutterButtonFocus(true);
+                    mUI.pressShutterButton();
+                }
+                return true;
+            case KeyEvent.KEYCODE_POWER:
+                if (mFirstTimeInitialized && event.getRepeatCount() == 0
+                        && CameraActivity.mPowerShutter && !CameraUtil.hasCameraKey()) {
+                    onShutterButtonFocus(true);
+                }
+                return true;
+        }
+        return false;
+    }
+
+    @Override
+    public boolean onKeyUp(int keyCode, KeyEvent event) {
+        switch (keyCode) {
+            case KeyEvent.KEYCODE_VOLUME_UP:
+            case KeyEvent.KEYCODE_VOLUME_DOWN:
+            case KeyEvent.KEYCODE_MEDIA_NEXT:
+            case KeyEvent.KEYCODE_MEDIA_PREVIOUS:
+                if (!CameraActivity.mPowerShutter && !CameraUtil.hasCameraKey()
+                        && mFirstTimeInitialized) {
+                    onShutterButtonClick();
+                }
+                return true;
+            case KeyEvent.KEYCODE_FOCUS:
+                if (mFirstTimeInitialized) {
+                    onShutterButtonFocus(false);
+                }
+                return true;
+            case KeyEvent.KEYCODE_POWER:
+                if (CameraActivity.mPowerShutter && !CameraUtil.hasCameraKey()
+                        && mFirstTimeInitialized) {
+                    onShutterButtonClick();
+                }
+                return true;
+        }
+        return false;
+    }
+
+    private void closeCamera() {
+        Log.v(TAG, "Close camera device.");
+        if (mCameraDevice != null) {
+            mCameraDevice.setZoomChangeListener(null);
+            mCameraDevice.setFaceDetectionCallback(null, null);
+            mCameraDevice.setErrorCallback(null);
+
+            if (mActivity.isSecureCamera() || mActivity.isForceReleaseCamera()) {
+                // Blocks until camera is actually released.
+                CameraHolder.instance().strongRelease();
+            } else {
+                CameraHolder.instance().release();
+            }
+
+            mFaceDetectionStarted = false;
+            mCameraDevice = null;
+            setCameraState(PREVIEW_STOPPED);
+            if (mFocusManager != null) {
+                mFocusManager.onCameraReleased();
+            }
+        }
+    }
+
+    private void setDisplayOrientation() {
+        mDisplayRotation = CameraUtil.getDisplayRotation(mActivity);
+        mDisplayOrientation = CameraUtil.getDisplayOrientation(mDisplayRotation, mCameraId);
+        mCameraDisplayOrientation = mDisplayOrientation;
+        // This will be called again in checkDisplayRotation(), so there
+        // should not be any problem even if mUI is null.
+        if (mUI != null) {
+            mUI.setDisplayOrientation(mDisplayOrientation);
+        }
+        if (mFocusManager != null) {
+            mFocusManager.setDisplayOrientation(mDisplayOrientation);
+        }
+        // Change the camera display orientation
+        if (mCameraDevice != null) {
+            mCameraDevice.setDisplayOrientation(mCameraDisplayOrientation);
+        }
+    }
+
+    /** Only called by UI thread. */
+    private void setupPreview() {
+        mFocusManager.resetTouchFocus();
+        startPreview();
+    }
+
+    /** This can run on a background thread, so don't do UI updates here. Post any
+             view updates to MainHandler or do it on onPreviewStarted() .  */
+    private void startPreview() {
+        if (mPaused || mCameraDevice == null || mParameters == null) {
+            return;
+        }
+
+        synchronized (mCameraDevice) {
+            SurfaceHolder sh = null;
+            Log.v(TAG, "startPreview: SurfaceHolder (MDP path)");
+            if (mUI != null) {
+                sh = mUI.getSurfaceHolder();
+            }
+
+            // Let UI set its expected aspect ratio
+            mCameraDevice.setPreviewDisplay(sh);
+        }
+
+        if (!mCameraPreviewParamsReady) {
+            Log.w(TAG, "startPreview: parameters for preview are not ready.");
+            return;
+        }
+        mErrorCallback.setActivity(mActivity);
+        mCameraDevice.setErrorCallback(mErrorCallback);
+
+        // Reset camera state after taking a picture
+        if (mCameraState != PREVIEW_STOPPED && mCameraState != INIT) {
+            setCameraState(IDLE);
+        }
+
+        // Preview needs to be stopped when changing resolution
+        if (mRestartPreview && mCameraState != PREVIEW_STOPPED && mCameraState != INIT) {
+            stopPreview();
+            mRestartPreview = false;
+        }
+
+        if (mFocusManager == null) initializeFocusManager();
+
+        if (!mSnapshotOnIdle) {
+            mFocusManager.setAeAwbLock(false); // Unlock AE and AWB.
+        }
+
+        setCameraParameters(UPDATE_PARAM_ALL);
+        mCameraDevice.setOneShotPreviewCallback(mHandler,
+                new CameraManager.CameraPreviewDataCallback() {
+                    @Override
+                    public void onPreviewFrame(byte[] data, CameraProxy camera) {
+                        mUI.hidePreviewCover();
+                    }
+                });
+        mCameraDevice.startPreview();
+
+        mHandler.sendEmptyMessage(ON_PREVIEW_STARTED);
+
+        setDisplayOrientation();
+
+        if (!mSnapshotOnIdle) {
+            // If the focus mode is continuous autofocus, call cancelAutoFocus to
+            // resume it because it may have been paused by autoFocus call.
+            if (CameraUtil.FOCUS_MODE_CONTINUOUS_PICTURE.equals(mFocusManager.getFocusMode(false)) && mCameraState !=INIT ||
+                    CameraUtil.FOCUS_MODE_MW_CONTINUOUS_PICTURE.equals(mFocusManager.getFocusMode(false))) {
+                mCameraDevice.cancelAutoFocus();
+            }
+        } else {
+            mHandler.sendEmptyMessageDelayed(INSTANT_CAPTURE, 1500);
+        }
+    }
+
+    @Override
+    public void stopPreview() {
+        if (mCameraDevice != null && mCameraState != PREVIEW_STOPPED) {
+            if (mCameraState == LONGSHOT) {
+                mCameraDevice.setLongshot(false);
+                mLongshotActive = false;
+            }
+            Log.v(TAG, "stopPreview");
+            mCameraDevice.stopPreview();
+        }
+        setCameraState(PREVIEW_STOPPED);
+        if (mFocusManager != null) mFocusManager.onPreviewStopped();
+        stopFaceDetection();
+    }
+
+    @SuppressWarnings("deprecation")
+    private void updateCameraParametersInitialize() {
+        // Reset preview frame rate to the maximum because it may be lowered by
+        // video camera application.
+        int[] fpsRange = CameraUtil.getPhotoPreviewFpsRange(mParameters);
+        if (fpsRange != null && fpsRange.length > 0) {
+            mParameters.setPreviewFpsRange(
+                    fpsRange[Parameters.PREVIEW_FPS_MIN_INDEX],
+                    fpsRange[Parameters.PREVIEW_FPS_MAX_INDEX]);
+        }
+
+        mParameters.set(CameraUtil.RECORDING_HINT, CameraUtil.FALSE);
+
+        // Disable video stabilization. Convenience methods not available in API
+        // level <= 14
+        String vstabSupported = mParameters.get("video-stabilization-supported");
+        if ("true".equals(vstabSupported)) {
+            mParameters.set("video-stabilization", "false");
+        }
+    }
+
+    private void updateCameraParametersZoom() {
+        // Set zoom.
+        if (mParameters.isZoomSupported()) {
+            Parameters p = mCameraDevice.getParameters();
+            mZoomValue = p.getZoom();
+            mParameters.setZoom(mZoomValue);
+        }
+    }
+    private boolean needRestart() {
+        mRestartPreview = false;
+
+        if(mCameraState != PREVIEW_STOPPED) {
+            //Switch on Normal Camera mode
+            Log.v(TAG, "Switching to Normal Camera Mode. Restart Preview");
+            mRestartPreview = true;
+            return mRestartPreview;
+        }
+        return mRestartPreview;
+    }
+
+    private String getSaturationSafe() {
+        String ret = null;
+        if (CameraUtil.isSupported(mParameters, "saturation") &&
+                CameraUtil.isSupported(mParameters, "max-saturation")) {
+            ret = mPreferences.getString(
+                    CameraSettings.KEY_SATURATION,
+                    mActivity.getString(R.string.pref_camera_saturation_default));
+        }
+        return ret;
+    }
+
+    private String getSharpnessSafe() {
+        String ret = null;
+        if (CameraUtil.isSupported(mParameters, "sharpness") &&
+                CameraUtil.isSupported(mParameters, "max-sharpness")) {
+            ret = mPreferences.getString(
+                    CameraSettings.KEY_SHARPNESS,
+                    mActivity.getString(R.string.pref_camera_sharpness_default));
+        }
+        return ret;
+    }
+
+    /** This can run on a background thread, so don't do UI updates here.*/
+    private void qcomUpdateCameraParametersPreference() {
+        //qcom Related Parameter update
+        String longshot_enable = mPreferences.getString(
+                CameraSettings.KEY_LONGSHOT,
+                mActivity.getString(R.string.pref_camera_longshot_default));
+        mParameters.set("long-shot", longshot_enable);
+
+        // Set Picture Format
+        // Picture Formats specified in UI should be consistent with
+        // PIXEL_FORMAT_JPEG and PIXEL_FORMAT_RAW constants
+        String pictureFormat = mPreferences.getString(
+                CameraSettings.KEY_PICTURE_FORMAT,
+                mActivity.getString(R.string.pref_camera_picture_format_default));
+
+        //Change picture format to JPEG if camera is start from other APK by intent.
+        if (mIsImageCaptureIntent && !pictureFormat.equals(PIXEL_FORMAT_JPEG)) {
+            pictureFormat = PIXEL_FORMAT_JPEG;
+            Editor editor = mPreferences.edit();
+            editor.putString(CameraSettings.KEY_PICTURE_FORMAT,
+                mActivity.getString(R.string.pref_camera_picture_format_value_jpeg));
+            editor.apply();
+        }
+        Log.v(TAG, "Picture format value =" + pictureFormat);
+        mParameters.set(KEY_PICTURE_FORMAT, pictureFormat);
+
+        // Set JPEG quality.
+        String jpegQuality = mPreferences.getString(
+                CameraSettings.KEY_JPEG_QUALITY,
+                mActivity.getString(R.string.pref_camera_jpegquality_default));
+        Size pic_size = mParameters.getPictureSize();
+        if (pic_size == null) {
+            Log.e(TAG, "error getPictureSize: size is null");
+        } else {
+            mParameters.setJpegQuality(SJpegEncodingQualityMappings.getQualityNumber(jpegQuality));
+            int jpegFileSize = estimateJpegFileSize(pic_size, jpegQuality);
+            if (jpegFileSize != mJpegFileSizeEstimation) {
+                mJpegFileSizeEstimation = jpegFileSize;
+                mHandler.post(new Runnable() {
+                    @Override
+                    public void run() {
+                        updateRemainingPhotos();
+                    }
+                });
+            }
+        }
+
+        // Set shutter speed parameter
+        String shutterSpeed = mPreferences.getString(
+                CameraSettings.KEY_SHUTTER_SPEED,
+                mActivity.getString(R.string.pref_camera_shutter_speed_default));
+        if (CameraUtil.isSupported(shutterSpeed,
+            CameraSettings.getSupportedShutterSpeedValues(mParameters))) {
+            mParameters.set(CameraSettings.KEY_SNAPCAM_SHUTTER_SPEED, shutterSpeed);
+        }
+
+        // Set color effect parameter.
+        String colorEffect = mPreferences.getString(
+                CameraSettings.KEY_COLOR_EFFECT,
+                mActivity.getString(R.string.pref_camera_coloreffect_default));
+        Log.v(TAG, "Color effect value =" + colorEffect);
+        if (CameraUtil.isSupported(colorEffect, mParameters.getSupportedColorEffects())) {
+            mParameters.setColorEffect(colorEffect);
+        }
+
+        //Set Saturation
+        String saturationStr = getSaturationSafe();
+        if (saturationStr != null) {
+            int saturation = Integer.parseInt(saturationStr);
+            Log.v(TAG, "Saturation value =" + saturation);
+            if((0 <= saturation) && (saturation <= ParametersWrapper.getMaxSaturation(mParameters))){
+                ParametersWrapper.setSaturation(mParameters, saturation);
+            }
+        }
+
+        // Set sharpness parameter
+        String sharpnessStr = getSharpnessSafe();
+        if (sharpnessStr != null) {
+            int sharpness = Integer.parseInt(sharpnessStr) *
+                    (ParametersWrapper.getMaxSharpness(mParameters)/MAX_SHARPNESS_LEVEL);
+            Log.v(TAG, "Sharpness value =" + sharpness);
+            if((0 <= sharpness) && (sharpness <= ParametersWrapper.getMaxSharpness(mParameters))){
+                ParametersWrapper.setSharpness(mParameters, sharpness);
+            }
+        }
+        // Set Face Recognition
+        String faceRC = mPreferences.getString(
+                CameraSettings.KEY_FACE_RECOGNITION,
+                mActivity.getString(R.string.pref_camera_facerc_default));
+        Log.v(TAG, "Face Recognition value = " + faceRC);
+        if (CameraUtil.isSupported(faceRC,
+                CameraSettings.getSupportedFaceRecognitionModes(mParameters))) {
+            mParameters.set(CameraSettings.KEY_QC_FACE_RECOGNITION, faceRC);
+        }
+
+
+        // Set face detetction parameter.
+        // clear override to re-enable setting if true portrait is off.
+        mActivity.runOnUiThread(new Runnable() {
+            @Override
+            public void run() {
+                mUI.overrideSettings(CameraSettings.KEY_FACE_DETECTION, null);
+            }
+        });
+
+        String faceDetection = mPreferences.getString(
+            CameraSettings.KEY_FACE_DETECTION,
+            mActivity.getString(R.string.pref_camera_facedetection_default));
+
+        if (CameraUtil.isSupported(faceDetection,
+                ParametersWrapper.getSupportedFaceDetectionModes(mParameters))) {
+            ParametersWrapper.setFaceDetectionMode(mParameters, faceDetection);
+            if(faceDetection.equals("on") && mFaceDetectionEnabled == false) {
+                mFaceDetectionEnabled = true;
+                startFaceDetection();
+            }
+            if(faceDetection.equals("off") && mFaceDetectionEnabled == true) {
+                stopFaceDetection();
+                mFaceDetectionEnabled = false;
+            }
+        }
+
+        // Set anti banding parameter.
+        String antiBanding = mPreferences.getString(
+                 CameraSettings.KEY_ANTIBANDING,
+                 mActivity.getString(R.string.pref_camera_antibanding_default));
+        Log.v(TAG, "antiBanding value =" + antiBanding);
+        if (CameraUtil.isSupported(antiBanding, mParameters.getSupportedAntibanding())) {
+            mParameters.setAntibanding(antiBanding);
+        }
+
+        ParametersWrapper.setCameraMode(mParameters, 0);
+        mFocusManager.setZslEnable(false);
+
+        setFlipValue();
+
+        if(!mFocusManager.getFocusMode(false).equals(Parameters.FOCUS_MODE_CONTINUOUS_PICTURE) &&
+            !mFocusManager.isFocusCompleted()) {
+            mUI.getFocusRing().stopFocusAnimations();
+        }
+
+        String bokehMode = mPreferences.getString(
+                CameraSettings.KEY_BOKEH_MODE,
+                mActivity.getString(R.string.pref_camera_bokeh_mode_default));
+        String bokehMpo = mPreferences.getString(
+                CameraSettings.KEY_BOKEH_MPO,
+                mActivity.getString(R.string.pref_camera_bokeh_mpo_default));
+        final SharedPreferences prefs = PreferenceManager.getDefaultSharedPreferences(mActivity);
+        final int bokehBlurDegree = prefs.getInt(CameraSettings.KEY_BOKEH_BLUR_VALUE,50);
+        final boolean supportBokeh = CameraSettings.isBokehModeSupported(mParameters);
+        mActivity.runOnUiThread(new Runnable() {
+            @Override
+            public void run() {
+                mUI.getCameraControls().setBokehMode(supportBokeh);
+            }
+        });
+
+        if (!bokehMode.equals(mActivity.getString(
+                R.string.pref_camera_bokeh_mode_entry_value_disable))) {
+            mIsBokehMode = true;
+            if(mParameters.getSceneMode() != Parameters.SCENE_MODE_AUTO) {
+                mParameters.setSceneMode(Parameters.SCENE_MODE_AUTO);
+            }
+            if(mParameters.getFlashMode() != Parameters.FLASH_MODE_OFF) {
+                mParameters.setFlashMode(Parameters.FLASH_MODE_OFF);
+            }
+            if(mParameters.get("long-shot").equals(mActivity.getString(R.string.setting_on_value))) {
+                mParameters.set("long-shot",mActivity.getString(R.string.setting_off_value));
+            }
+        } else {
+            mIsBokehMode = false;
+        }
+        mParameters.set(CameraSettings.KEY_QC_BOKEH_MODE, bokehMode);
+        mParameters.set(CameraSettings.KEY_QC_BOKEH_MPO_MODE, bokehMpo);
+        mParameters.set(CameraSettings.KEY_QC_BOKEH_BLUR_VALUE, bokehBlurDegree);
+        Log.v(TAG, "Bokeh Mode = " + bokehMode + " bokehMpo = " + bokehMpo +
+                " bokehBlurDegree = " + bokehBlurDegree);
+
+        mLongShotMaxSnap = SystemProperties.getInt(PERSIST_LONGSHOT_MAX_SNAP, -1);
+        mParameters.set("max-longshot-snap",mLongShotMaxSnap);
+    }
+
+    private int estimateJpegFileSize(final Size size, final String quality) {
+        int[] ratios = mActivity.getResources().getIntArray(R.array.jpegquality_compression_ratio);
+        String[] qualities = mActivity.getResources().getStringArray(
+                R.array.pref_camera_jpegquality_entryvalues);
+        int ratio = 0;
+        for (int i = ratios.length - 1; i >= 0; --i) {
+            if (qualities[i].equals(quality)) {
+                ratio = ratios[i];
+                break;
+            }
+        }
+
+        if (ratio == 0) {
+            return 0;
+        } else {
+            return size.width * size.height * 3 / ratio;
+        }
+    }
+
+    private void setFlipValue() {
+        // Read Flip mode from adb command
+        //value: 0(default) - FLIP_MODE_OFF
+        //value: 1 - FLIP_MODE_H
+        //value: 2 - FLIP_MODE_V
+        //value: 3 - FLIP_MODE_VH
+        PersistUtil myUtil     = new PersistUtil();
+        int preview_flip_value = myUtil.getPreviewFlip();
+        int video_flip_value   = myUtil.getVideoFlip();
+        int picture_flip_value = myUtil.getPictureFlip();
+
+        int rotation = CameraUtil.getJpegRotation(mCameraId, mOrientation);
+        mParameters.setRotation(rotation);
+        if (rotation == 90 || rotation == 270) {
+            // in case of 90 or 270 degree, V/H flip should reverse
+            if (preview_flip_value == 1) {
+                preview_flip_value = 2;
+            } else if (preview_flip_value == 2) {
+                preview_flip_value = 1;
+            }
+            if (video_flip_value == 1) {
+                video_flip_value = 2;
+            } else if (video_flip_value == 2) {
+                video_flip_value = 1;
+            }
+            if (picture_flip_value == 1) {
+                picture_flip_value = 2;
+            } else if (picture_flip_value == 2) {
+                picture_flip_value = 1;
+            }
+        }
+        String preview_flip = CameraUtil.getFilpModeString(preview_flip_value);
+        String video_flip = CameraUtil.getFilpModeString(video_flip_value);
+        String picture_flip = CameraUtil.getFilpModeString(picture_flip_value);
+        if(CameraUtil.isSupported(preview_flip, CameraSettings.getSupportedFlipMode(mParameters))){
+            mParameters.set(CameraSettings.KEY_QC_PREVIEW_FLIP, preview_flip);
+        }
+        if(CameraUtil.isSupported(video_flip, CameraSettings.getSupportedFlipMode(mParameters))){
+            mParameters.set(CameraSettings.KEY_QC_VIDEO_FLIP, video_flip);
+        }
+        if(CameraUtil.isSupported(picture_flip, CameraSettings.getSupportedFlipMode(mParameters))){
+            mParameters.set(CameraSettings.KEY_QC_SNAPSHOT_PICTURE_FLIP, picture_flip);
+        }
+    }
+
+    @TargetApi(Build.VERSION_CODES.JELLY_BEAN)
+    private void setAutoExposureLockIfSupported() {
+        if (mAeLockSupported) {
+            mParameters.setAutoExposureLock(mFocusManager.getAeAwbLock());
+        }
+    }
+
+    @TargetApi(Build.VERSION_CODES.JELLY_BEAN)
+    private void setAutoWhiteBalanceLockIfSupported() {
+        if (mAwbLockSupported) {
+            mParameters.setAutoWhiteBalanceLock(mFocusManager.getAeAwbLock());
+        }
+    }
+
+    private void setFocusAreasIfSupported() {
+        if (mFocusAreaSupported) {
+            mParameters.setFocusAreas(mFocusManager.getFocusAreas());
+        }
+    }
+
+    private void setMeteringAreasIfSupported() {
+        if (mMeteringAreaSupported) {
+            mParameters.setMeteringAreas(mFocusManager.getMeteringAreas());
+        }
+    }
+    private void setZoomMenuValue() {
+        String zoomMenuValue = mPreferences.getString(CameraSettings.KEY_ZOOM,
+                                mActivity.getString(R.string.pref_camera_zoom_default));
+        if (!zoomMenuValue.equals("0")) {
+            int zoomValue = Integer.parseInt(zoomMenuValue);
+            if (mZoomIdxTbl[0] == -1) {
+                /* update the index table once */
+                Log.d(TAG, "Update the zoom index table.");
+                List<Integer> zoomRatios = mParameters.getZoomRatios();
+                int lastZoomIdx = 0;
+                for (int zoom = 1; zoom <= MAX_ZOOM; zoom++) {
+                    int zoomIdx = zoomRatios.indexOf(zoom*100);
+                    if (zoomIdx == -1) {
+                       Log.d(TAG, "Can't find matching zoom value "+zoom);
+                       int nextZoom = 0;
+                       while ((++lastZoomIdx < zoomRatios.size()) &&
+                              (nextZoom < (zoom*100))){
+                           nextZoom = zoomRatios.get(lastZoomIdx);
+                           zoomIdx = lastZoomIdx;
+                       }
+                       if (lastZoomIdx < zoomRatios.size()) {
+                           zoomIdx = lastZoomIdx - 1;
+                       } else {
+                           break;
+                       }
+                    }
+                    mZoomIdxTbl[zoom-1] = zoomIdx;
+                    lastZoomIdx = zoomIdx;
+                }
+            }
+
+            if ((zoomValue <= mZoomIdxTbl.length) &&
+                (mZoomIdxTbl[zoomValue-1] != -1)) {
+                int step = 1;
+                int cur_zoom = mParameters.getZoom();
+                Log.d(TAG, "zoom index = "+mZoomIdxTbl[zoomValue-1]+", cur index = "+cur_zoom);
+                if (cur_zoom > mZoomIdxTbl[zoomValue-1]) {
+                    step = -1;
+                }
+
+                /* move zoom slowly */
+                while (cur_zoom != mZoomIdxTbl[zoomValue-1]) {
+                    cur_zoom += step;
+                    mParameters.setZoom(cur_zoom);
+                    try {
+                        Thread.sleep(25);
+                    } catch(InterruptedException e) {
+                    }
+                }
+                mParameters.setZoom(mZoomIdxTbl[zoomValue-1]);
+            } else {
+                Log.e(TAG, "Zoom value "+zoomValue+" is not supported!");
+            }
+        }
+    }
+
+    /** This can run on a background thread, so don't do UI updates here.*/
+    private boolean updateCameraParametersPreference() {
+        setAutoExposureLockIfSupported();
+        setAutoWhiteBalanceLockIfSupported();
+        setFocusAreasIfSupported();
+        setMeteringAreasIfSupported();
+
+        // Set picture size.
+        String pictureSize = mPreferences.getString(
+                CameraSettings.KEY_PICTURE_SIZE, null);
+        if (pictureSize == null) {
+            CameraSettings.initialCameraPictureSize(mActivity, mParameters);
+        } else {
+            Size old_size = mParameters.getPictureSize();
+            Log.v(TAG, "old picture_size = " + old_size.width + " x " + old_size.height);
+            List<Size> supported = mParameters.getSupportedPictureSizes();
+            CameraSettings.setCameraPictureSize(
+                    pictureSize, supported, mParameters);
+            Size size = mParameters.getPictureSize();
+            Log.v(TAG, "new picture_size = " + size.width + " x " + size.height);
+            if (old_size != null && size != null) {
+                if(!size.equals(old_size) && mCameraState != PREVIEW_STOPPED) {
+                    Log.v(TAG, "Picture Size changed. Restart Preview.");
+                    mRestartPreview = true;
+                }
+            }
+        }
+        Size size = mParameters.getPictureSize();
+
+        // Set a preview size that is closest to the viewfinder height and has
+        // the right aspect ratio.
+        List<Size> sizes = mParameters.getSupportedPreviewSizes();
+        Size optimalSize = CameraUtil.getOptimalPreviewSize(mActivity, sizes,
+                (double) size.width / size.height);
+
+        Point previewSize = PersistUtil.getCameraPreviewSize();
+        if (previewSize != null) {
+            optimalSize.width = previewSize.x;
+            optimalSize.height = previewSize.y;
+        }
+
+        Log.d(TAG, "updateCameraParametersPreference final preview size = "
+                + optimalSize.width + ", " + optimalSize.height);
+
+        Size original = mParameters.getPreviewSize();
+        if (!original.equals(optimalSize)) {
+            mParameters.setPreviewSize(optimalSize.width, optimalSize.height);
+
+            // Zoom related settings will be changed for different preview
+            // sizes, so set and read the parameters to get latest values
+            if (mHandler.getLooper() == Looper.myLooper()) {
+                // On UI thread only, not when camera starts up
+                setupPreview();
+            } else {
+                mCameraDevice.setParameters(mParameters);
+            }
+            mParameters = mCameraDevice.getParameters();
+            Log.v(TAG, "Preview Size changed. Restart Preview");
+            mRestartPreview = true;
+        }
+
+        Log.v(TAG, "Preview size is " + optimalSize.width + "x" + optimalSize.height);
+        size = mParameters.getPictureSize();
+
+        // Set jpegthumbnail size
+        // Set a jpegthumbnail size that is closest to the Picture height and has
+        // the right aspect ratio.
+        List<Size> supported = mParameters.getSupportedJpegThumbnailSizes();
+        optimalSize = CameraUtil.getOptimalJpegThumbnailSize(supported,
+                (double) size.width / size.height);
+        original = mParameters.getJpegThumbnailSize();
+        if (!original.equals(optimalSize)) {
+            mParameters.setJpegThumbnailSize(optimalSize.width, optimalSize.height);
+        }
+
+        Log.v(TAG, "Thumbnail size is " + optimalSize.width + "x" + optimalSize.height);
+
+        // Since changing scene mode may change supported values, set scene mode
+        // first. HDR is a scene mode. To promote it in UI, it is stored in a
+        // separate preference.
+        String onValue = mActivity.getString(R.string.setting_on_value);
+        String hdr = mPreferences.getString(CameraSettings.KEY_CAMERA_HDR,
+                mActivity.getString(R.string.pref_camera_hdr_default));
+        boolean hdrOn = onValue.equals(hdr);
+
+
+        if (hdrOn) {
+            mSceneMode = CameraUtil.SCENE_MODE_HDR;
+            if (!(Parameters.SCENE_MODE_AUTO).equals(mParameters.getSceneMode())
+                && !(Parameters.SCENE_MODE_HDR).equals(mParameters.getSceneMode())) {
+                mParameters.setSceneMode(Parameters.SCENE_MODE_AUTO);
+                mCameraDevice.setParameters(mParameters);
+                mParameters = mCameraDevice.getParameters();
+            }
+        } else {
+            mSceneMode = mPreferences.getString(
+                    CameraSettings.KEY_SCENE_MODE,
+                    mActivity.getString(R.string.pref_camera_scenemode_default));
+        }
+
+        if (mSceneMode == null) {
+            mSceneMode = Parameters.SCENE_MODE_AUTO;
+        }
+
+        if (CameraUtil.isSupported(mSceneMode, mParameters.getSupportedSceneModes())) {
+            if (!mParameters.getSceneMode().equals(mSceneMode)) {
+                if (mHandler.getLooper() == Looper.myLooper()) {
+                    mUI.setPreference(CameraSettings.KEY_ADVANCED_FEATURES, scenModeStr);
+                }
+                mParameters.setSceneMode(mSceneMode);
+
+                // Setting scene mode will change the settings of flash mode,
+                // white balance, and focus mode. Here we read back the
+                // parameters, so we can know those settings.
+                mCameraDevice.setParameters(mParameters);
+                mParameters = mCameraDevice.getParameters();
+            }
+        }
+
+        // Set JPEG quality.
+        int jpegQuality;
+        if(mCameraId>1) {
+            jpegQuality=95; //Temproray Solution for camera ids greater than 1. Proper fix TBD.
+        } else {
+            jpegQuality = CameraProfile.getJpegEncodingQualityParameter(mCameraId,
+                CameraProfile.QUALITY_HIGH);
+        }
+
+        mParameters.setJpegQuality(jpegQuality);
+
+        // When shutter speed gets disabled preview needs to be restarted
+        if (CameraUtil.isSupported(mParameters, CameraSettings.KEY_SNAPCAM_SHUTTER_SPEED)) {
+            String shutterSpeed = mPreferences.getString(CameraSettings.KEY_SHUTTER_SPEED, null);
+            if (shutterSpeed != null) {
+                String oldShutterSpeed = mParameters.get(CameraSettings.KEY_SNAPCAM_SHUTTER_SPEED);
+                if(!shutterSpeed.equals(oldShutterSpeed) && shutterSpeed.equals("0")
+                        && mCameraState != PREVIEW_STOPPED) {
+                    Log.v(TAG, "Shutter speed disabled. Restart Preview.");
+                    mRestartPreview = true;
+                }
+            }
+        }
+
+        if (Parameters.SCENE_MODE_AUTO.equals(mSceneMode) ||
+                "asd".equals(mSceneMode) ||
+                "sports".equals(mSceneMode)) {
+            // Set flash mode.
+            String flashMode;
+            if (mSavedFlashMode == null) {
+                flashMode = mPreferences.getString(
+                    CameraSettings.KEY_FLASH_MODE,
+                    mActivity.getString(R.string.pref_camera_flashmode_default));
+            } else {
+                flashMode = mSavedFlashMode;
+            }
+
+            List<String> supportedFlash = mParameters.getSupportedFlashModes();
+            if (CameraUtil.isSupported(flashMode, supportedFlash)) {
+                mParameters.setFlashMode(flashMode);
+            } else {
+                flashMode = mParameters.getFlashMode();
+                if (flashMode == null) {
+                    flashMode = mActivity.getString(
+                            R.string.pref_camera_flashmode_no_flash);
+                }
+            }
+
+            // Set focus time.
+            mFocusManager.setFocusTime(Integer.decode(
+                    mPreferences.getString(CameraSettings.KEY_FOCUS_TIME,
+                    mActivity.getString(R.string.pref_camera_focustime_default))));
+        } else {
+            mFocusManager.overrideFocusMode(mParameters.getFocusMode());
+            String flashMode = Parameters.FLASH_MODE_OFF;
+            if (CameraUtil.isSupported(flashMode,
+                    mParameters.getSupportedFlashModes())) {
+                mParameters.setFlashMode(flashMode);
+            }
+        }
+
+        if (mContinuousFocusSupported && ApiHelper.HAS_AUTO_FOCUS_MOVE_CALLBACK) {
+            updateAutoFocusMoveCallback();
+        }
+
+        setZoomMenuValue();
+
+        //QCom related parameters updated here.
+        qcomUpdateCameraParametersPreference();
+        return false;
+    }
+
+    @TargetApi(Build.VERSION_CODES.JELLY_BEAN)
+    private void updateAutoFocusMoveCallback() {
+        if (mParameters.getFocusMode().equals(CameraUtil.FOCUS_MODE_CONTINUOUS_PICTURE) ||
+            mParameters.getFocusMode().equals(CameraUtil.FOCUS_MODE_MW_CONTINUOUS_PICTURE)) {
+            mCameraDevice.setAutoFocusMoveCallback(mHandler,
+                    (CameraAFMoveCallback) mAutoFocusMoveCallback);
+        } else {
+            mCameraDevice.setAutoFocusMoveCallback(null, null);
+        }
+    }
+
+    // We separate the parameters into several subsets, so we can update only
+    // the subsets actually need updating. The PREFERENCE set needs extra
+    // locking because the preference can be changed from GLThread as well.
+    private void setCameraParameters(int updateSet) {
+        if (mCameraDevice == null) {
+            return;
+        }
+        synchronized (mCameraDevice) {
+            boolean doModeSwitch = false;
+
+            if ((updateSet & UPDATE_PARAM_INITIALIZE) != 0) {
+                updateCameraParametersInitialize();
+            }
+
+            if ((updateSet & UPDATE_PARAM_ZOOM) != 0) {
+                updateCameraParametersZoom();
+            }
+
+            if ((updateSet & UPDATE_PARAM_PREFERENCE) != 0) {
+                doModeSwitch = updateCameraParametersPreference();
+            }
+
+            CameraUtil.dumpParameters(mParameters);
+            mCameraDevice.setParameters(mParameters);
+            mFocusManager.setParameters(mParameters);
+        }
+    }
+
+    // If the Camera is idle, update the parameters immediately, otherwise
+    // accumulate them in mUpdateSet and update later.
+    private void setCameraParametersWhenIdle(int additionalUpdateSet) {
+        mUpdateSet |= additionalUpdateSet;
+        if (mCameraDevice == null) {
+            // We will update all the parameters when we open the device, so
+            // we don't need to do anything now.
+            mUpdateSet = 0;
+            return;
+        } else if (isCameraIdle()) {
+            setCameraParameters(mUpdateSet);
+             if(mRestartPreview && mCameraState != PREVIEW_STOPPED) {
+                Log.v(TAG, "Restarting Preview...");
+                stopPreview();
+                resizeForPreviewAspectRatio();
+                startPreview();
+                setCameraState(IDLE);
+            }
+            mRestartPreview = false;
+            updateCameraSettings();
+            mUpdateSet = 0;
+        } else {
+            if (!mHandler.hasMessages(SET_CAMERA_PARAMETERS_WHEN_IDLE)) {
+                mHandler.sendEmptyMessageDelayed(
+                        SET_CAMERA_PARAMETERS_WHEN_IDLE, 1000);
+            }
+        }
+    }
+
+    @Override
+    public boolean isCameraIdle() {
+        return (mCameraState == IDLE) ||
+                (mCameraState == PREVIEW_STOPPED) ||
+                ((mFocusManager != null) && mFocusManager.isFocusCompleted()
+                        && (mCameraState != SWITCHING_CAMERA));
+    }
+
+    @Override
+    public boolean isImageCaptureIntent() {
+        String action = mActivity.getIntent().getAction();
+        return (MediaStore.ACTION_IMAGE_CAPTURE.equals(action)
+                || CameraActivity.ACTION_IMAGE_CAPTURE_SECURE.equals(action));
+    }
+
+    private void setupCaptureParams() {
+        Bundle myExtras = mActivity.getIntent().getExtras();
+        if (myExtras != null) {
+            mSaveUri = (Uri) myExtras.getParcelable(MediaStore.EXTRA_OUTPUT);
+            mCropValue = myExtras.getString("crop");
+        }
+    }
+
+    // Return true if the preference has the specified key but not the value.
+    private static boolean notSame(ListPreference pref, String key, String value) {
+        return (key.equals(pref.getKey()) && !value.equals(pref.getValue()));
+    }
+
+    @Override
+    public void onSharedPreferenceChanged(ListPreference pref) {
+        // ignore the events after "onPause()"
+        if (mPaused) return;
+
+
+        if (CameraSettings.KEY_CAMERA_SAVEPATH.equals(pref.getKey())) {
+            Storage.setSaveSDCard(
+                    mPreferences.getString(CameraSettings.KEY_CAMERA_SAVEPATH, "0").equals("1"));
+            mActivity.updateStorageSpaceAndHint();
+            updateRemainingPhotos();
+        }
+
+        //call generic onSharedPreferenceChanged
+        onSharedPreferenceChanged();
+    }
+
+    @Override
+    public void onSharedPreferenceChanged() {
+        // ignore the events after "onPause()"
+        if (mPaused) return;
+
+        boolean recordLocation = RecordLocationPreference.get(mPreferences,
+                CameraSettings.KEY_RECORD_LOCATION);
+        mLocationManager.recordLocation(recordLocation);
+        if(needRestart()){
+            Log.v(TAG, "Restarting Preview... Camera Mode Changed");
+            setCameraParameters(UPDATE_PARAM_PREFERENCE);
+            stopPreview();
+            startPreview();
+            setCameraState(IDLE);
+            mRestartPreview = false;
+        }
+        /* Check if the SPhotoUI Menu is initialized or not. This
+         * should be initialized during onCameraOpen() which should
+         * have been called by now. But for some reason that is not
+         * executed till now, then schedule these functionality for
+         * later by posting a message to the handler */
+        if (mUI.mMenuInitialized) {
+            setCameraParametersWhenIdle(UPDATE_PARAM_PREFERENCE);
+            mActivity.initPowerShutter(mPreferences);
+            mActivity.initMaxBrightness(mPreferences);
+        } else {
+            mHandler.sendEmptyMessage(SET_PHOTO_UI_PARAMS);
+        }
+        resizeForPreviewAspectRatio();
+    }
+
+    @Override
+    public void onCameraPickerClicked(int cameraId) {
+        if (mPaused || mPendingSwitchCameraId != -1) return;
+
+        mPendingSwitchCameraId = cameraId;
+
+        Log.v(TAG, "Start to switch camera. cameraId=" + cameraId);
+        // We need to keep a preview frame for the animation before
+        // releasing the camera. This will trigger onPreviewTextureCopied.
+        //TODO: Need to animate the camera switch
+        switchCamera();
+    }
+
+    // Preview texture has been copied. Now camera can be released and the
+    // animation can be started.
+    @Override
+    public void onPreviewTextureCopied() {
+        mHandler.sendEmptyMessage(SWITCH_CAMERA);
+    }
+
+    @Override
+    public void onCaptureTextureCopied() {
+    }
+
+    @Override
+    public void onUserInteraction() {
+        if (!mActivity.isFinishing()) keepScreenOnAwhile();
+    }
+
+    private void resetScreenOn() {
+        mHandler.removeMessages(CLEAR_SCREEN_DELAY);
+        mActivity.getWindow().clearFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON);
+    }
+
+    private void keepScreenOnAwhile() {
+        mHandler.removeMessages(CLEAR_SCREEN_DELAY);
+        mActivity.getWindow().addFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON);
+        mHandler.sendEmptyMessageDelayed(CLEAR_SCREEN_DELAY, SCREEN_DELAY);
+    }
+
+    @Override
+    public void onOverriddenPreferencesClicked() {
+        if (mPaused) return;
+        mUI.showPreferencesToast();
+    }
+
+    private void showTapToFocusToast() {
+        // TODO: Use a toast?
+        new RotateTextToast(mActivity, R.string.tap_to_focus, 0).show();
+        // Clear the preference.
+        Editor editor = mPreferences.edit();
+        editor.putBoolean(CameraSettings.KEY_CAMERA_FIRST_USE_HINT_SHOWN, false);
+        editor.apply();
+    }
+
+    private void initializeCapabilities() {
+        mFocusAreaSupported = CameraUtil.isFocusAreaSupported(mInitialParams);
+        mMeteringAreaSupported = CameraUtil.isMeteringAreaSupported(mInitialParams);
+        mAeLockSupported = CameraUtil.isAutoExposureLockSupported(mInitialParams);
+        mAwbLockSupported = CameraUtil.isAutoWhiteBalanceLockSupported(mInitialParams);
+
+        List<String> focusModes = mInitialParams.getSupportedFocusModes();
+        if (focusModes != null &&
+                (focusModes.contains(CameraUtil.FOCUS_MODE_CONTINUOUS_PICTURE) ||
+                focusModes.contains(CameraUtil.FOCUS_MODE_MW_CONTINUOUS_PICTURE))) {
+            mContinuousFocusSupported = true;
+        } else {
+            mContinuousFocusSupported = false;
+        }
+    }
+
+    @Override
+    public void onCountDownFinished() {
+        mSnapshotOnIdle = false;
+        initiateSnap();
+        mFocusManager.onShutterUp();
+        mUI.showUIAfterCountDown();
+    }
+
+    @Override
+    public void onShowSwitcherPopup() {
+        mUI.onShowSwitcherPopup();
+    }
+
+    @Override
+    public int onZoomChanged(int index) {
+        // Not useful to change zoom value when the activity is paused.
+        if (mPaused) return index;
+        mZoomValue = index;
+        if (mParameters == null || mCameraDevice == null) return index;
+        if ( mFocusManager != null
+                && mFocusManager.getCurrentFocusState() == FocusOverlayManager.STATE_FOCUSING ) {
+            mFocusManager.cancelAutoFocus();
+        }
+        // Set zoom parameters asynchronously
+        synchronized (mCameraDevice) {
+            mParameters.setZoom(mZoomValue);
+            mCameraDevice.setParameters(mParameters);
+            Parameters p = mCameraDevice.getParameters();
+            if (p != null) return p.getZoom();
+        }
+        return index;
+    }
+
+    @Override
+    public void onZoomChanged(float requestedZoom) {
+        if ( mFocusManager != null
+                && mFocusManager.getCurrentFocusState() == FocusOverlayManager.STATE_FOCUSING ) {
+            mFocusManager.cancelAutoFocus();
+        }
+    }
+
+    @Override
+    public int getCameraState() {
+        return mCameraState;
+    }
+
+    @Override
+    public void onQueueStatus(boolean full) {
+        mUI.enableShutter(!full);
+    }
+
+    @Override
+    public void onMediaSaveServiceConnected(MediaSaveService s) {
+        // We set the listener only when both service and shutterbutton
+        // are initialized.
+        if (mFirstTimeInitialized) {
+            s.setListener(this);
+        }
+    }
+
+    @Override
+    public void onAccuracyChanged(Sensor sensor, int accuracy) {
+    }
+
+    @Override
+    public void onSensorChanged(SensorEvent event) {
+        int type = event.sensor.getType();
+        float[] data;
+        if (type == Sensor.TYPE_ACCELEROMETER) {
+            data = mGData;
+        } else if (type == Sensor.TYPE_MAGNETIC_FIELD) {
+            data = mMData;
+        } else {
+            // we should not be here.
+            return;
+        }
+        for (int i = 0; i < 3 ; i++) {
+            data[i] = event.values[i];
+        }
+        float[] orientation = new float[3];
+        SensorManager.getRotationMatrix(mR, null, mGData, mMData);
+        SensorManager.getOrientation(mR, orientation);
+        mHeading = (int) (orientation[0] * 180f / Math.PI) % 360;
+        if (mHeading < 0) {
+            mHeading += 360;
+        }
+    }
+    @Override
+    public void onPreviewFocusChanged(boolean previewFocused) {
+        mUI.onPreviewFocusChanged(previewFocused);
+    }
+    // TODO: Delete this function after old camera code is removed
+    @Override
+    public void onRestorePreferencesClicked() {}
+
+/*
+ * Provide a mapping for Jpeg encoding quality levels
+ * from String representation to numeric representation.
+ */
+    @Override
+    public boolean arePreviewControlsVisible() {
+        return mUI.arePreviewControlsVisible();
+    }
+
+    // For debugging only.
+    public void setDebugUri(Uri uri) {
+        mDebugUri = uri;
+    }
+
+    // For debugging only.
+    private void saveToDebugUri(byte[] data) {
+        if (mDebugUri != null) {
+            OutputStream outputStream = null;
+            try {
+                outputStream = mContentResolver.openOutputStream(mDebugUri);
+                outputStream.write(data);
+                outputStream.close();
+            } catch (IOException e) {
+                Log.e(TAG, "Exception while writing debug jpeg file", e);
+            } finally {
+                CameraUtil.closeSilently(outputStream);
+            }
+        }
+    }
+
+    @Override
+    public void onErrorListener(int error) {
+        enableRecordingLocation(false);
+    }
+
+    public boolean isLongshotDone() {
+        return ((mCameraState == LONGSHOT) && (mLongshotSnapNum == mReceivedSnapNum) &&
+                !mLongshotActive);
+    }
+}
+
+/* Below is no longer needed, except to get rid of compile error
+ * TODO: Remove these
+ */
+class SJpegEncodingQualityMappings {
+    private static final String TAG = "SJpegEncodingQualityMappings";
+    private static final int DEFAULT_QUALITY = 85;
+    private static HashMap<String, Integer> mHashMap =
+            new HashMap<String, Integer>();
+
+    static {
+        mHashMap.put("normal",    CameraProfile.QUALITY_LOW);
+        mHashMap.put("fine",      CameraProfile.QUALITY_MEDIUM);
+        mHashMap.put("superfine", CameraProfile.QUALITY_HIGH);
+    }
+
+    // Retrieve and return the Jpeg encoding quality number
+    // for the given quality level.
+    public static int getQualityNumber(String jpegQuality) {
+        try{
+            int qualityPercentile = Integer.parseInt(jpegQuality);
+            if(qualityPercentile >= 0 && qualityPercentile <=100)
+                return qualityPercentile;
+            else
+                return DEFAULT_QUALITY;
+        } catch(NumberFormatException nfe){
+            //chosen quality is not a number, continue
+        }
+        Integer quality = mHashMap.get(jpegQuality);
+        if (quality == null) {
+            Log.w(TAG, "Unknown Jpeg quality: " + jpegQuality);
+            return DEFAULT_QUALITY;
+        }
+        return CameraProfile.getJpegEncodingQualityParameter(quality.intValue());
+    }
+}
+
+class SCameraGraphView extends View {
+    private Bitmap  mBitmap;
+    private Paint   mPaint = new Paint();
+    private Paint   mPaintRect = new Paint();
+    private Canvas  mCanvas = new Canvas();
+    private float   mScale = (float)3;
+    private float   mWidth;
+    private float   mHeight;
+    private SPhotoModule mPhotoModule;
+    private CameraManager.CameraProxy mGraphCameraDevice;
+    private float scaled;
+    private static final int STATS_SIZE = 256;
+
+
+    public SCameraGraphView(Context context, AttributeSet attrs) {
+        super(context,attrs);
+
+        mPaint.setFlags(Paint.ANTI_ALIAS_FLAG);
+        mPaintRect.setColor(0xFFFFFFFF);
+        mPaintRect.setStyle(Paint.Style.FILL);
+    }
+    @Override
+    protected void onSizeChanged(int w, int h, int oldw, int oldh) {
+        mBitmap = Bitmap.createBitmap(w, h, Bitmap.Config.RGB_565);
+        mCanvas.setBitmap(mBitmap);
+        mWidth = w;
+        mHeight = h;
+        super.onSizeChanged(w, h, oldw, oldh);
+    }
+    @Override
+    protected void onDraw(Canvas canvas) {
+        if(mPhotoModule == null) {
+            return;
+        }
+
+        if (mBitmap != null) {
+            final Paint paint = mPaint;
+            final Canvas cavas = mCanvas;
+            final float border = 5;
+            float graphheight = mHeight - (2 * border);
+            float graphwidth = mWidth - (2 * border);
+            float left,top,right,bottom;
+            float bargap = 0.0f;
+            float barwidth = graphwidth/STATS_SIZE;
+
+            cavas.drawColor(0xFFAAAAAA);
+            paint.setColor(Color.BLACK);
+
+            for (int k = 0; k <= (graphheight /32) ; k++) {
+                float y = (float)(32 * k)+ border;
+                cavas.drawLine(border, y, graphwidth + border , y, paint);
+            }
+            for (int j = 0; j <= (graphwidth /32); j++) {
+                float x = (float)(32 * j)+ border;
+                cavas.drawLine(x, border, x, graphheight + border, paint);
+            }
+            synchronized(SPhotoModule.statsdata) {
+                 //Assumption: The first element contains
+                //            the maximum value.
+                int maxValue = Integer.MIN_VALUE;
+                if ( 0 == SPhotoModule.statsdata[0] ) {
+                    for ( int i = 1 ; i <= STATS_SIZE ; i++ ) {
+                         if ( maxValue < SPhotoModule.statsdata[i] ) {
+                             maxValue = SPhotoModule.statsdata[i];
+                         }
+                    }
+                } else {
+                    maxValue = SPhotoModule.statsdata[0];
+                }
+                mScale = ( float ) maxValue;
+                for(int i=1 ; i<=STATS_SIZE ; i++)  {
+                    scaled = (SPhotoModule.statsdata[i]/mScale)*STATS_SIZE;
+                    if(scaled >= (float)STATS_SIZE)
+                        scaled = (float)STATS_SIZE;
+                    left = (bargap * (i+1)) + (barwidth * i) + border;
+                    top = graphheight + border;
+                    right = left + barwidth;
+                    bottom = top - scaled;
+                    cavas.drawRect(left, top, right, bottom, mPaintRect);
+                }
+            }
+            canvas.drawBitmap(mBitmap, 0, 0, null);
+        }
+    }
+    public void PreviewChanged() {
+        invalidate();
+    }
+    public void setSPhotoModuleObject(SPhotoModule photoModule) {
+        mPhotoModule = photoModule;
+    }
+}
diff --git a/src/com/android/camera/SPhotoUI.java b/src/com/android/camera/SPhotoUI.java
new file mode 100644
index 0000000..052f1c9
--- /dev/null
+++ b/src/com/android/camera/SPhotoUI.java
@@ -0,0 +1,1337 @@
+/*
+ * Copyright (C) 2012 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+package com.android.camera;
+
+import java.util.List;
+
+import org.codeaurora.snapcam.R;
+
+import android.app.AlertDialog;
+import android.content.DialogInterface;
+import android.content.DialogInterface.OnDismissListener;
+import android.content.SharedPreferences;
+import android.content.res.Configuration;
+import android.graphics.Bitmap;
+import android.graphics.Color;
+import android.graphics.Matrix;
+import android.graphics.Point;
+import android.graphics.RectF;
+import android.graphics.drawable.AnimationDrawable;
+import android.graphics.drawable.ColorDrawable;
+import android.hardware.Camera;
+import android.hardware.Camera.Face;
+import android.os.AsyncTask;
+import android.preference.PreferenceManager;
+import android.util.Log;
+import android.util.Size;
+import android.view.Gravity;
+import android.view.MotionEvent;
+import android.view.SurfaceHolder;
+import android.view.SurfaceView;
+import android.view.View;
+import android.view.View.OnClickListener;
+import android.view.View.OnLayoutChangeListener;
+import android.view.ViewGroup;
+import android.view.ViewStub;
+import android.view.Window;
+import android.view.WindowManager;
+import android.widget.FrameLayout;
+import android.widget.FrameLayout.LayoutParams;
+import android.widget.ImageView;
+import android.widget.LinearLayout;
+import android.widget.ListView;
+import android.widget.PopupWindow;
+import android.widget.SeekBar;
+import android.widget.Toast;
+
+import com.android.camera.CameraPreference.OnPreferenceChangedListener;
+import com.android.camera.ui.AbstractSettingPopup;
+import com.android.camera.ui.CameraControls;
+import com.android.camera.ui.CameraRootView;
+import com.android.camera.ui.CountDownView;
+import com.android.camera.ui.CountDownView.OnCountDownFinishedListener;
+import com.android.camera.ui.FaceView;
+import com.android.camera.ui.ListSubMenu;
+import com.android.camera.ui.ModuleSwitcher;
+import com.android.camera.ui.PieRenderer;
+import com.android.camera.ui.PieRenderer.PieListener;
+import com.android.camera.ui.RenderOverlay;
+import com.android.camera.ui.RotateImageView;
+import com.android.camera.ui.RotateLayout;
+import com.android.camera.ui.RotateTextToast;
+import com.android.camera.ui.SelfieFlashView;
+import com.android.camera.ui.ZoomRenderer;
+import com.android.camera.ui.focus.FocusRing;
+import com.android.camera.util.CameraUtil;
+
+public class SPhotoUI implements PieListener,
+        PreviewGestures.SingleTapListener,
+        SurfaceHolder.Callback,
+        CameraRootView.MyDisplayListener,
+        CameraManager.CameraFaceDetectionCallback {
+
+    private static final String TAG = "CAM_UI";
+    private int mDownSampleFactor = 4;
+    private final AnimationManager mAnimationManager;
+    private final FocusRing mFocusRing;
+    private CameraActivity mActivity;
+    private PhotoController mController;
+    private PreviewGestures mGestures;
+
+    private View mRootView;
+    private SurfaceHolder mSurfaceHolder;
+
+    private PopupWindow mPopup;
+    private ShutterButton mShutterButton;
+    private CountDownView mCountDownView;
+    private SelfieFlashView mSelfieView;
+
+    private FaceView mFaceView;
+    private RenderOverlay mRenderOverlay;
+    private View mReviewCancelButton;
+    private View mReviewDoneButton;
+    private View mReviewRetakeButton;
+    private ImageView mReviewImage;
+    private DecodeImageForReview mDecodeTaskForReview = null;
+
+    private View mMenuButton;
+    private SPhotoMenu mMenu;
+    private ModuleSwitcher mSwitcher;
+    private CameraControls mCameraControls;
+    private AlertDialog mLocationDialog;
+    private SeekBar mBlurDegreeProgressBar;
+
+    private PieRenderer mPieRenderer;
+    private ZoomRenderer mZoomRenderer;
+    private RotateTextToast mNotSelectableToast;
+
+    private int mZoomMax;
+    private List<Integer> mZoomRatios;
+
+    private int mMaxPreviewWidth = 0;
+    private int mMaxPreviewHeight = 0;
+
+    public boolean mMenuInitialized = false;
+    private float mSurfaceTextureUncroppedWidth;
+    private float mSurfaceTextureUncroppedHeight;
+
+    private ImageView mThumbnail;
+    private View mFlashOverlay;
+
+    private SurfaceTextureSizeChangedListener mSurfaceTextureSizeListener;
+    private SurfaceView mSurfaceView = null;
+    private float mAspectRatio = 4f / 3f;
+    private boolean mAspectRatioResize;
+
+    private boolean mOrientationResize;
+    private boolean mPrevOrientationResize;
+    private View mPreviewCover;
+    private RotateLayout mMenuLayout;
+    private RotateLayout mSubMenuLayout;
+    private LinearLayout mPreviewMenuLayout;
+    private boolean mUIhidden = false;
+    private int mPreviewOrientation = -1;
+
+    private int mScreenRatio = CameraUtil.RATIO_UNKNOWN;
+    private int mTopMargin = 0;
+    private int mBottomMargin = 0;
+    private boolean mIsLayoutInitializedAlready = false;
+
+    private int mOrientation;
+    private float mScreenBrightness = 0.0f;
+    private boolean mIsBokehMode = false;
+
+    public enum SURFACE_STATUS {
+        HIDE,
+        SURFACE_VIEW;
+    }
+
+    public interface SurfaceTextureSizeChangedListener {
+        public void onSurfaceTextureSizeChanged(int uncroppedWidth, int uncroppedHeight);
+    }
+
+    public CameraControls getCameraControls() {
+        return mCameraControls;
+    }
+
+    private class DecodeTask extends AsyncTask<Void, Void, Bitmap> {
+        private final byte [] mData;
+        private int mOrientation;
+        private boolean mMirror;
+
+        public DecodeTask(byte[] data, int orientation, boolean mirror) {
+            mData = data;
+            mOrientation = orientation;
+            mMirror = mirror;
+        }
+
+        @Override
+        protected Bitmap doInBackground(Void... params) {
+            // Decode image in background.
+            Bitmap bitmap = CameraUtil.downSample(mData, mDownSampleFactor);
+            if ((mOrientation != 0 || mMirror) && (bitmap != null)) {
+                Matrix m = new Matrix();
+                if (mMirror) {
+                    // Flip horizontally
+                    m.setScale(-1f, 1f);
+                }
+                m.preRotate(mOrientation);
+                return Bitmap.createBitmap(bitmap, 0, 0, bitmap.getWidth(), bitmap.getHeight(), m,
+                        false);
+            }
+            return bitmap;
+        }
+
+        @Override
+        protected void onPostExecute(Bitmap bitmap) {
+        }
+    }
+
+    private class DecodeImageForReview extends DecodeTask {
+        public DecodeImageForReview(byte[] data, int orientation, boolean mirror) {
+            super(data, orientation, mirror);
+        }
+
+        @Override
+        protected void onPostExecute(Bitmap bitmap) {
+            if (isCancelled()) {
+                return;
+            }
+            mReviewImage.setImageBitmap(bitmap);
+            mReviewImage.setVisibility(View.VISIBLE);
+            mDecodeTaskForReview = null;
+        }
+    }
+
+    public synchronized void applySurfaceChange(SURFACE_STATUS status) {
+        if(status == SURFACE_STATUS.HIDE) {
+            mSurfaceView.setVisibility(View.GONE);
+            return;
+        }
+        mSurfaceView.setVisibility(View.VISIBLE);
+    }
+
+    public SPhotoUI(CameraActivity activity, PhotoController controller, View parent) {
+        mActivity = activity;
+        mController = controller;
+        mRootView = parent;
+        mActivity.getLayoutInflater().inflate(R.layout.photo_module,
+                (ViewGroup) mRootView, true);
+        mPreviewCover = mRootView.findViewById(R.id.preview_cover);
+        // display the view
+        mSurfaceView = (SurfaceView) mRootView.findViewById(R.id.mdp_preview_content);
+        mSurfaceView.setVisibility(View.VISIBLE);
+        mSurfaceHolder = mSurfaceView.getHolder();
+        mSurfaceHolder.addCallback(this);
+        mSurfaceHolder.setType(SurfaceHolder.SURFACE_TYPE_PUSH_BUFFERS);
+        Log.v(TAG, "Using mdp_preview_content (MDP path)");
+        mSurfaceView.addOnLayoutChangeListener(new OnLayoutChangeListener() {
+            @Override
+            public void onLayoutChange(View v, int left, int top, int right,
+                    int bottom, int oldLeft, int oldTop, int oldRight,
+                    int oldBottom) {
+                int width = right - left;
+                int height = bottom - top;
+
+                tryToCloseSubList();
+
+                if (mMaxPreviewWidth == 0 && mMaxPreviewHeight == 0) {
+                    mMaxPreviewWidth = width;
+                    mMaxPreviewHeight = height;
+                }
+
+                if (mOrientationResize != mPrevOrientationResize
+                        || mAspectRatioResize || !mIsLayoutInitializedAlready) {
+                    layoutPreview(mAspectRatio);
+                    mAspectRatioResize = false;
+                }
+            }
+        });
+
+        mRenderOverlay = (RenderOverlay) mRootView.findViewById(R.id.render_overlay);
+        mFlashOverlay = mRootView.findViewById(R.id.flash_overlay);
+        mShutterButton = (ShutterButton) mRootView.findViewById(R.id.shutter_button);
+        mSwitcher = (ModuleSwitcher) mRootView.findViewById(R.id.camera_switcher);
+        mSwitcher.setCurrentIndex(ModuleSwitcher.SPHOTO_MODULE_INDEX);
+        mSwitcher.setSwitchListener(mActivity);
+        mSwitcher.setOnClickListener(new OnClickListener() {
+            @Override
+            public void onClick(View v) {
+                if (mController.getCameraState() == PhotoController.LONGSHOT) {
+                       return;
+                }
+                mSwitcher.showPopup();
+                mSwitcher.setOrientation(mOrientation, false);
+            }
+        });
+        mMenuButton = mRootView.findViewById(R.id.menu);
+
+        RotateImageView muteButton = (RotateImageView)mRootView.findViewById(R.id.mute_button);
+        muteButton.setVisibility(View.GONE);
+
+        mBlurDegreeProgressBar = (SeekBar)mRootView.findViewById(R.id.blur_degree_bar);
+        mBlurDegreeProgressBar.setMax(100);
+
+        mCameraControls = (CameraControls) mRootView.findViewById(R.id.camera_controls);
+        ViewStub faceViewStub = (ViewStub) mRootView
+                .findViewById(R.id.face_view_stub);
+        if (faceViewStub != null) {
+            faceViewStub.inflate();
+            mFaceView = (FaceView) mRootView.findViewById(R.id.face_view);
+            setSurfaceTextureSizeChangedListener(mFaceView);
+        }
+        mFocusRing = (FocusRing) mRootView.findViewById(R.id.focus_ring);
+        mAnimationManager = new AnimationManager();
+        mOrientationResize = false;
+        mPrevOrientationResize = false;
+
+        Point size = new Point();
+        mActivity.getWindowManager().getDefaultDisplay().getRealSize(size);
+        mScreenRatio = CameraUtil.determineRatio(size.x, size.y);
+        calculateMargins(size);
+        mCameraControls.setMargins(mTopMargin, mBottomMargin);
+    }
+
+    public SeekBar getBokehDegreeBar() {
+        return mBlurDegreeProgressBar;
+    }
+
+    private void calculateMargins(Point size) {
+        int l = size.x > size.y ? size.x : size.y;
+        int tm = mActivity.getResources().getDimensionPixelSize(R.dimen.preview_top_margin);
+        int bm = mActivity.getResources().getDimensionPixelSize(R.dimen.preview_bottom_margin);
+        mTopMargin = l / 4 * tm / (tm + bm);
+        mBottomMargin = l / 4 - mTopMargin;
+    }
+
+    public void setDownFactor(int factor) {
+        mDownSampleFactor = factor;
+    }
+
+     public void cameraOrientationPreviewResize(boolean orientation){
+        mPrevOrientationResize = mOrientationResize;
+        mOrientationResize = orientation;
+     }
+
+    public void setAspectRatio(float ratio) {
+        if (ratio <= 0.0) throw new IllegalArgumentException();
+
+        if (mOrientationResize && CameraUtil.isScreenRotated(mActivity)) {
+            ratio = 1 / ratio;
+        }
+
+        Log.d(TAG, "setAspectRatio() ratio[" + ratio + "] mAspectRatio[" + mAspectRatio + "]");
+        if (ratio != mAspectRatio) {
+            mAspectRatioResize = true;
+            mAspectRatio = ratio;
+        }
+        mCameraControls.setPreviewRatio(mAspectRatio, false);
+        layoutPreview(ratio);
+    }
+
+    public void layoutPreview(float ratio) {
+        FrameLayout.LayoutParams lp;
+        float scaledTextureWidth, scaledTextureHeight;
+        int rotation = CameraUtil.getDisplayRotation(mActivity);
+        if(!CameraUtil.isDefaultToPortrait(mActivity)) {
+        rotation = (rotation - 90) % 360;
+        }
+        mScreenRatio = CameraUtil.determineRatio(ratio);
+        if (mScreenRatio == CameraUtil.RATIO_16_9
+                && CameraUtil.determinCloseRatio(ratio) == CameraUtil.RATIO_4_3) {
+            int l = (mTopMargin + mBottomMargin) * 4;
+            int s = l * 9 / 16;
+            switch (rotation) {
+                case 90:
+                    lp = new FrameLayout.LayoutParams(l * 3 / 4, s);
+                    lp.setMargins(mTopMargin, 0, mBottomMargin, 0);
+                    scaledTextureWidth = l * 3 / 4;
+                    scaledTextureHeight = s;
+                    break;
+                case 180:
+                    lp = new FrameLayout.LayoutParams(s, l * 3 / 4);
+                    lp.setMargins(0, mBottomMargin, 0, mTopMargin);
+                    scaledTextureWidth = s;
+                    scaledTextureHeight = l * 3 / 4;
+                    break;
+                case 270:
+                    lp = new FrameLayout.LayoutParams(l * 3 / 4, s);
+                    lp.setMargins(mBottomMargin, 0, mTopMargin, 0);
+                    scaledTextureWidth = l * 3 / 4;
+                    scaledTextureHeight = s;
+                    break;
+                default:
+                    lp = new FrameLayout.LayoutParams(s, l * 3 / 4);
+                    lp.setMargins(0, mTopMargin, 0, mBottomMargin);
+                    scaledTextureWidth = s;
+                    scaledTextureHeight = l * 3 / 4;
+                    break;
+            }
+        } else {
+            float width = mMaxPreviewWidth, height = mMaxPreviewHeight;
+            if (width == 0 || height == 0) return;
+            if (mScreenRatio == CameraUtil.RATIO_4_3) {
+                if (height > width) {
+                    height -= (mTopMargin + mBottomMargin);
+                } else {
+                    width -= (mTopMargin + mBottomMargin);
+                }
+            }
+            if (mOrientationResize) {
+                scaledTextureWidth = height * mAspectRatio;
+                if (scaledTextureWidth > width) {
+                    scaledTextureWidth = width;
+                    scaledTextureHeight = scaledTextureWidth / mAspectRatio;
+                } else {
+                    scaledTextureHeight = height;
+                }
+            } else {
+                if (width > height) {
+                    if(Math.max(width, height * mAspectRatio) > width) {
+                        scaledTextureWidth = width;
+                        scaledTextureHeight = width / mAspectRatio;
+                    } else {
+                        scaledTextureWidth = height * mAspectRatio;
+                        scaledTextureHeight = height;
+                    }
+                } else {
+                    if (Math.max(height, width * mAspectRatio) > height) {
+                        scaledTextureWidth = height / mAspectRatio;
+                        scaledTextureHeight = height;
+                    } else {
+                        scaledTextureWidth = width;
+                        scaledTextureHeight = width * mAspectRatio;
+                    }
+                }
+            }
+
+            Log.v(TAG, "setTransformMatrix: scaledTextureWidth = " + scaledTextureWidth
+                    + ", scaledTextureHeight = " + scaledTextureHeight);
+            if (((rotation == 0 || rotation == 180) && scaledTextureWidth > scaledTextureHeight)
+                    || ((rotation == 90 || rotation == 270)
+                        && scaledTextureWidth < scaledTextureHeight)) {
+                lp = new FrameLayout.LayoutParams((int) scaledTextureHeight,
+                        (int) scaledTextureWidth, Gravity.CENTER);
+            } else {
+                lp = new FrameLayout.LayoutParams((int) scaledTextureWidth,
+                        (int) scaledTextureHeight, Gravity.CENTER);
+            }
+            if (mScreenRatio == CameraUtil.RATIO_4_3) {
+                lp.gravity = Gravity.CENTER_HORIZONTAL | Gravity.TOP;
+                lp.setMargins(0, mTopMargin, 0, mBottomMargin);
+            }
+        }
+
+        if (mSurfaceTextureUncroppedWidth != scaledTextureWidth ||
+                mSurfaceTextureUncroppedHeight != scaledTextureHeight) {
+            mSurfaceTextureUncroppedWidth = scaledTextureWidth;
+            mSurfaceTextureUncroppedHeight = scaledTextureHeight;
+            if (mSurfaceTextureSizeListener != null) {
+                mSurfaceTextureSizeListener.onSurfaceTextureSizeChanged(
+                        (int) mSurfaceTextureUncroppedWidth,
+                        (int) mSurfaceTextureUncroppedHeight);
+                Log.d(TAG, "mSurfaceTextureUncroppedWidth=" + mSurfaceTextureUncroppedWidth
+                        + "mSurfaceTextureUncroppedHeight=" + mSurfaceTextureUncroppedHeight);
+            }
+        }
+
+        mSurfaceView.setLayoutParams(lp);
+        mRootView.requestLayout();
+        if (mFaceView != null) {
+            mFaceView.setLayoutParams(lp);
+        }
+        mIsLayoutInitializedAlready = true;
+    }
+
+    public void setSurfaceTextureSizeChangedListener(SurfaceTextureSizeChangedListener listener) {
+        mSurfaceTextureSizeListener = listener;
+    }
+
+    // SurfaceHolder callbacks
+    @Override
+    public void surfaceChanged(SurfaceHolder holder, int format, int width, int height) {
+        Log.v(TAG, "surfaceChanged: width =" + width + ", height = " + height);
+        RectF r = new RectF(mSurfaceView.getLeft(), mSurfaceView.getTop(),
+                mSurfaceView.getRight(), mSurfaceView.getBottom());
+        mController.onPreviewRectChanged(CameraUtil.rectFToRect(r));
+    }
+
+    @Override
+    public void surfaceCreated(SurfaceHolder holder) {
+        Log.v(TAG, "surfaceCreated");
+        mSurfaceHolder = holder;
+        mController.onPreviewUIReady();
+        mActivity.updateThumbnail(mThumbnail);
+    }
+
+    @Override
+    public void surfaceDestroyed(SurfaceHolder holder) {
+        Log.v(TAG, "surfaceDestroyed");
+        mSurfaceHolder = null;
+        mController.onPreviewUIDestroyed();
+    }
+
+    public View getRootView() {
+        return mRootView;
+    }
+
+    public void onCameraOpened(PreferenceGroup prefGroup, ComboPreferences prefs,
+            Camera.Parameters params, OnPreferenceChangedListener listener) {
+        if (mPieRenderer == null) {
+            mPieRenderer = new PieRenderer(mActivity);
+            mPieRenderer.setPieListener(this);
+            mRenderOverlay.addRenderer(mPieRenderer);
+        }
+
+        if (mMenu == null) {
+            mMenu = new SPhotoMenu(mActivity, this);
+            mMenu.setListener(listener);
+        }
+        mMenu.initialize(prefGroup);
+        mMenuInitialized = true;
+
+        if (mZoomRenderer == null) {
+            mZoomRenderer = new ZoomRenderer(mActivity);
+            mRenderOverlay.addRenderer(mZoomRenderer);
+        }
+
+        if (mGestures == null) {
+            // this will handle gesture disambiguation and dispatching
+            mGestures = new PreviewGestures(mActivity, this, mZoomRenderer, mPieRenderer, null);
+            mRenderOverlay.setGestures(mGestures);
+        }
+        mGestures.setSPhotoMenu(mMenu);
+
+        mGestures.setZoomEnabled(params.isZoomSupported());
+        mGestures.setRenderOverlay(mRenderOverlay);
+        mRenderOverlay.requestLayout();
+
+        initializeZoom(params);
+        mActivity.setPreviewGestures(mGestures);
+    }
+
+    public void animateCapture(final byte[] jpegData) {
+        // Decode jpeg byte array and then animate the jpeg
+        mActivity.updateThumbnail(jpegData);
+    }
+
+    private void openMenu() {
+        if (mPieRenderer != null) {
+            // If autofocus is not finished, cancel autofocus so that the
+            // subsequent touch can be handled by PreviewGestures
+            if (mController.getCameraState() == PhotoController.FOCUSING) {
+                    mController.cancelAutoFocus();
+            }
+            mPieRenderer.showInCenter();
+        }
+    }
+
+    public void initializeControlByIntent() {
+        if (!mActivity.isSecureCamera() && !mActivity.isCaptureIntent()) {
+            mThumbnail = (ImageView) mRootView.findViewById(R.id.preview_thumb);
+            mThumbnail.setOnClickListener(new OnClickListener() {
+                @Override
+                public void onClick(View v) {
+                    if (!CameraControls.isAnimating()
+                            && mController.getCameraState() != PhotoController.SNAPSHOT_IN_PROGRESS) {
+                        mActivity.gotoGallery();
+                    }
+                }
+            });
+        }
+        mMenuButton = mRootView.findViewById(R.id.menu);
+        mMenuButton.setOnClickListener(new OnClickListener() {
+            @Override
+            public void onClick(View v) {
+                if (mMenu != null) {
+                    mMenu.openFirstLevel();
+                }
+            }
+        });
+        if (mController.isImageCaptureIntent()) {
+            hideSwitcher();
+            mCameraControls.hideRemainingPhotoCnt();
+            mSwitcher.setSwitcherVisibility(false);
+            ViewGroup cameraControls = (ViewGroup) mRootView.findViewById(R.id.camera_controls);
+            mActivity.getLayoutInflater().inflate(R.layout.review_module_control, cameraControls);
+
+            mReviewDoneButton = mRootView.findViewById(R.id.done_button);
+            mReviewCancelButton = mRootView.findViewById(R.id.btn_cancel);
+            mReviewRetakeButton = mRootView.findViewById(R.id.btn_retake);
+            mReviewImage = (ImageView) mRootView.findViewById(R.id.review_image);
+            mReviewCancelButton.setVisibility(View.VISIBLE);
+
+            mReviewDoneButton.setOnClickListener(new OnClickListener() {
+                @Override
+                public void onClick(View v) {
+                    mController.onCaptureDone();
+                }
+            });
+            mReviewCancelButton.setOnClickListener(new OnClickListener() {
+                @Override
+                public void onClick(View v) {
+                    mController.onCaptureCancelled();
+                }
+            });
+
+            mReviewRetakeButton.setOnClickListener(new OnClickListener() {
+                @Override
+                public void onClick(View v) {
+                    mController.onCaptureRetake();
+                    if (mController.isImageCaptureIntent()) {
+                        mCameraControls.setTitleBarVisibility(View.VISIBLE);
+                    }
+                }
+            });
+        }
+    }
+
+    public void hideRemainingPhotoCnt() {
+        mCameraControls.hideRemainingPhotoCnt();
+    }
+
+    public void showRemainingPhotoCnt() {
+        mCameraControls.showRemainingPhotoCnt();
+    }
+
+    public void hideUI() {
+        mSwitcher.closePopup();
+        if (mUIhidden)
+            return;
+        mUIhidden = true;
+        mCameraControls.hideUI();
+    }
+
+    public void showUI() {
+        if (!mUIhidden || (mMenu != null && mMenu.isMenuBeingShown()))
+            return;
+        mUIhidden = false;
+        mCameraControls.showUI();
+    }
+
+    public boolean arePreviewControlsVisible() {
+        return !mUIhidden;
+    }
+
+    public void hideSwitcher() {
+        mSwitcher.closePopup();
+        mSwitcher.setVisibility(View.INVISIBLE);
+    }
+
+    public void showSwitcher() {
+        mSwitcher.setVisibility(View.VISIBLE);
+    }
+
+    public void setSwitcherIndex() {
+        mSwitcher.setCurrentIndex(ModuleSwitcher.SPHOTO_MODULE_INDEX);
+    }
+
+    // called from onResume but only the first time
+    public void initializeFirstTime() {
+        // Initialize shutter button.
+        mShutterButton.setImageResource(R.drawable.btn_new_shutter);
+        mShutterButton.setOnShutterButtonListener(mController);
+        mShutterButton.setVisibility(View.VISIBLE);
+    }
+
+    // called from onResume every other time
+    public void initializeSecondTime(Camera.Parameters params) {
+        initializeZoom(params);
+        if (mController.isImageCaptureIntent()) {
+            hidePostCaptureAlert();
+        }
+        if (mMenu != null) {
+            mMenu.reloadPreferences();
+        }
+        RotateImageView muteButton = (RotateImageView)mRootView.findViewById(R.id.mute_button);
+        muteButton.setVisibility(View.GONE);
+    }
+
+    public void initializeZoom(Camera.Parameters params) {
+        if ((params == null) || !params.isZoomSupported()
+                || (mZoomRenderer == null)) return;
+        mZoomMax = params.getMaxZoom();
+        mZoomRatios = params.getZoomRatios();
+        // Currently we use immediate zoom for fast zooming to get better UX and
+        // there is no plan to take advantage of the smooth zoom.
+        if (mZoomRenderer != null) {
+            mZoomRenderer.setZoomMax(mZoomMax);
+            mZoomRenderer.setZoom(params.getZoom());
+            mZoomRenderer.setZoomValue(mZoomRatios.get(params.getZoom()));
+            mZoomRenderer.setOnZoomChangeListener(new ZoomChangeListener());
+        }
+    }
+
+    public void overrideSettings(final String ... keyvalues) {
+        if (mMenu == null)
+            return;
+        mMenu.overrideSettings(keyvalues);
+    }
+
+    public void setCameraState(int state) {
+    }
+
+    public void animateFlash() {
+        mAnimationManager.startFlashAnimation(mFlashOverlay);
+    }
+
+    public void enableGestures(boolean enable) {
+        if (mGestures != null) {
+            mGestures.setEnabled(enable);
+        }
+    }
+
+    // forward from preview gestures to controller
+    @Override
+    public void onSingleTapUp(View view, int x, int y) {
+        mController.onSingleTapUp(view, x, y);
+    }
+
+    public boolean onBackPressed() {
+        if (mMenu != null && mMenu.handleBackKey()) {
+            return true;
+        }
+
+        if (mPieRenderer != null && mPieRenderer.showsItems()) {
+            mPieRenderer.hide();
+            return true;
+        }
+        // In image capture mode, back button should:
+        // 1) if there is any popup, dismiss them, 2) otherwise, get out of
+        // image capture
+        if (mController.isImageCaptureIntent()) {
+            mController.onCaptureCancelled();
+            return true;
+        } else if (!mController.isCameraIdle()) {
+            // ignore backs while we're taking a picture
+            return true;
+        } if (mSwitcher != null && mSwitcher.showsPopup()) {
+            mSwitcher.closePopup();
+            return true;
+        } else {
+            return false;
+        }
+    }
+
+    public void onPreviewFocusChanged(boolean previewFocused) {
+        if (previewFocused) {
+            showUI();
+        } else {
+            hideUI();
+        }
+        if (mFaceView != null) {
+            mFaceView.setBlockDraw(!previewFocused);
+        }
+        if (mGestures != null) {
+            mGestures.setEnabled(previewFocused);
+        }
+        if (mRenderOverlay != null) {
+            // this can not happen in capture mode
+            mRenderOverlay.setVisibility(previewFocused ? View.VISIBLE : View.GONE);
+        }
+        if (mPieRenderer != null) {
+            mPieRenderer.setBlockFocus(!previewFocused);
+        }
+        if (!previewFocused && mCountDownView != null) mCountDownView.cancelCountDown();
+    }
+
+    public ViewGroup getMenuLayout() {
+        return mMenuLayout;
+    }
+
+    public void setPreviewMenuLayout(LinearLayout layout) {
+        mPreviewMenuLayout = layout;
+    }
+
+    public ViewGroup getPreviewMenuLayout() {
+        return mPreviewMenuLayout;
+    }
+
+    public void showPopup(ListView popup, int level, boolean animate) {
+        FrameLayout.LayoutParams params;
+        hideUI();
+
+        popup.setVisibility(View.VISIBLE);
+        if (level == 1) {
+            if (mMenuLayout == null) {
+                mMenuLayout = new RotateLayout(mActivity, null);
+                if (mRootView.getLayoutDirection() != View.LAYOUT_DIRECTION_RTL) {
+                    params = new FrameLayout.LayoutParams(
+                            CameraActivity.SETTING_LIST_WIDTH_1, LayoutParams.WRAP_CONTENT,
+                            Gravity.LEFT | Gravity.TOP);
+                } else {
+                    params = new FrameLayout.LayoutParams(
+                            CameraActivity.SETTING_LIST_WIDTH_1, LayoutParams.WRAP_CONTENT,
+                            Gravity.RIGHT | Gravity.TOP);
+                }
+                mMenuLayout.setLayoutParams(params);
+                ((ViewGroup) mRootView).addView(mMenuLayout);
+            }
+            mMenuLayout.setOrientation(mOrientation, true);
+            mMenuLayout.addView(popup);
+        }
+        if (level == 2) {
+            if (mSubMenuLayout == null) {
+                mSubMenuLayout = new RotateLayout(mActivity, null);
+                ((ViewGroup) mRootView).addView(mSubMenuLayout);
+            }
+            if (mRootView.getLayoutDirection() != View.LAYOUT_DIRECTION_RTL) {
+                params = new FrameLayout.LayoutParams(
+                        CameraActivity.SETTING_LIST_WIDTH_2, LayoutParams.WRAP_CONTENT,
+                        Gravity.LEFT | Gravity.TOP);
+            } else {
+                params = new FrameLayout.LayoutParams(
+                        CameraActivity.SETTING_LIST_WIDTH_2, LayoutParams.WRAP_CONTENT,
+                        Gravity.RIGHT | Gravity.TOP);
+            }
+            int screenHeight = (mOrientation == 0 || mOrientation == 180)
+                ? mRootView.getHeight() : mRootView.getWidth();
+            int height = ((ListSubMenu) popup).getPreCalculatedHeight();
+            int yBase = ((ListSubMenu) popup).getYBase();
+            int y = Math.max(0, yBase);
+            if (yBase + height > screenHeight)
+                y = Math.max(0, screenHeight - height);
+            if (mRootView.getLayoutDirection() != View.LAYOUT_DIRECTION_RTL) {
+                params.setMargins(CameraActivity.SETTING_LIST_WIDTH_1, y, 0, 0);
+            } else {
+                params.setMargins(0, y, CameraActivity.SETTING_LIST_WIDTH_1, 0);
+            }
+
+            mSubMenuLayout.setLayoutParams(params);
+
+            mSubMenuLayout.addView(popup);
+            mSubMenuLayout.setOrientation(mOrientation, true);
+        }
+        if (animate) {
+            if (level == 1)
+                mMenu.animateSlideIn(mMenuLayout, CameraActivity.SETTING_LIST_WIDTH_1, true);
+            if (level == 2)
+                mMenu.animateFadeIn(popup);
+        } else {
+            popup.setAlpha(1f);
+        }
+    }
+
+    public void removeLevel2() {
+        if (mSubMenuLayout != null) {
+            View v = mSubMenuLayout.getChildAt(0);
+            mSubMenuLayout.removeView(v);
+        }
+    }
+
+    public void showPopup(AbstractSettingPopup popup) {
+        hideUI();
+
+        if (mPopup == null) {
+            mPopup = new PopupWindow(LayoutParams.WRAP_CONTENT, LayoutParams.WRAP_CONTENT);
+            mPopup.setBackgroundDrawable(new ColorDrawable(Color.TRANSPARENT));
+            mPopup.setOutsideTouchable(true);
+            mPopup.setFocusable(true);
+            mPopup.setOnDismissListener(new PopupWindow.OnDismissListener() {
+                @Override
+                public void onDismiss() {
+                    mPopup = null;
+                    // mMenu.popupDismissed(mDismissAll);
+                    mDismissAll = false;
+                    showUI();
+
+                    // Switch back into fullscreen/lights-out mode after popup
+                    // is dimissed.
+                    mActivity.setSystemBarsVisibility(false);
+                }
+            });
+        }
+        popup.setVisibility(View.VISIBLE);
+        mPopup.setContentView(popup);
+        mPopup.showAtLocation(mRootView, Gravity.CENTER, 0, 0);
+    }
+
+    public void cleanupListview() {
+        showUI();
+        mActivity.setSystemBarsVisibility(false);
+    }
+
+    public void dismissPopup() {
+        if (mPopup != null && mPopup.isShowing()) {
+            mPopup.dismiss();
+        }
+    }
+
+    private boolean mDismissAll = false;
+    public void dismissAllPopup() {
+        mDismissAll = true;
+        if (mPopup != null && mPopup.isShowing()) {
+            mPopup.dismiss();
+        }
+    }
+
+    public void dismissLevel1() {
+        if (mMenuLayout != null) {
+            ((ViewGroup) mRootView).removeView(mMenuLayout);
+            mMenuLayout = null;
+        }
+    }
+
+    public void dismissLevel2() {
+        if (mSubMenuLayout != null) {
+            ((ViewGroup) mRootView).removeView(mSubMenuLayout);
+            mSubMenuLayout = null;
+        }
+    }
+
+    public boolean sendTouchToPreviewMenu(MotionEvent ev) {
+        if (mPreviewMenuLayout != null) {
+            return mPreviewMenuLayout.dispatchTouchEvent(ev);
+        }
+        return false;
+    }
+
+    public boolean sendTouchToMenu(MotionEvent ev) {
+        if (mMenuLayout != null) {
+            View v = mMenuLayout.getChildAt(0);
+            return v.dispatchTouchEvent(ev);
+        }
+        return false;
+    }
+
+    public void dismissSceneModeMenu() {
+        if (mPreviewMenuLayout != null) {
+            ((ViewGroup) mRootView).removeView(mPreviewMenuLayout);
+            mPreviewMenuLayout = null;
+        }
+    }
+
+    public void removeSceneModeMenu() {
+        if (mPreviewMenuLayout != null) {
+            ((ViewGroup) mRootView).removeView(mPreviewMenuLayout);
+            mPreviewMenuLayout = null;
+        }
+        cleanupListview();
+    }
+
+    public void onShowSwitcherPopup() {
+        if (mPieRenderer != null && mPieRenderer.showsItems()) {
+            mPieRenderer.hide();
+        }
+    }
+
+    public boolean collapseCameraControls() {
+        // TODO: Mode switcher should behave like a popup and should hide itself when there
+        // is a touch outside of it.
+        mSwitcher.closePopup();
+        // Remove all the popups/dialog boxes
+        boolean ret = false;
+        if (mMenu != null) {
+            mMenu.removeAllView();
+        }
+        if (mPopup != null) {
+            dismissAllPopup();
+            ret = true;
+        }
+        onShowSwitcherPopup();
+        return ret;
+    }
+
+    protected void showCapturedImageForReview(byte[] jpegData, int orientation, boolean mirror) {
+        mCameraControls.hideCameraSettings();
+        mDecodeTaskForReview = new DecodeImageForReview(jpegData, orientation, mirror);
+        mDecodeTaskForReview.execute();
+        mMenuButton.setVisibility(View.GONE);
+        CameraUtil.fadeIn(mReviewDoneButton);
+        mShutterButton.setVisibility(View.INVISIBLE);
+        CameraUtil.fadeIn(mReviewRetakeButton);
+        setOrientation(mOrientation, true);
+        mMenu.hideTopMenu(true);
+    }
+
+    protected void hidePostCaptureAlert() {
+        mCameraControls.showCameraSettings();
+        if (mDecodeTaskForReview != null) {
+            mDecodeTaskForReview.cancel(true);
+        }
+        mReviewImage.setVisibility(View.GONE);
+        mMenuButton.setVisibility(View.VISIBLE);
+        if (mMenu != null) {
+            mMenu.hideTopMenu(false);
+        }
+        CameraUtil.fadeOut(mReviewDoneButton);
+        mShutterButton.setVisibility(View.VISIBLE);
+        CameraUtil.fadeOut(mReviewRetakeButton);
+    }
+
+    public void setDisplayOrientation(int orientation) {
+        if (mFaceView != null) {
+            mFaceView.setDisplayOrientation(orientation);
+        }
+        if ((mPreviewOrientation == -1 || mPreviewOrientation != orientation)
+                && mMenu != null && mMenu.isPreviewMenuBeingShown()) {
+            dismissSceneModeMenu();
+            mMenu.addModeBack();
+        }
+        mPreviewOrientation = orientation;
+    }
+
+    // shutter button handling
+
+    public boolean isShutterPressed() {
+        return mShutterButton.isPressed();
+    }
+
+    /**
+     * Enables or disables the shutter button.
+     */
+    public void enableShutter(boolean enabled) {
+        if (mShutterButton != null) {
+            mShutterButton.setEnabled(enabled);
+        }
+    }
+
+    public void pressShutterButton() {
+        if (mShutterButton.isInTouchMode()) {
+            mShutterButton.requestFocusFromTouch();
+        } else {
+            mShutterButton.requestFocus();
+        }
+        mShutterButton.setPressed(true);
+    }
+
+    private class ZoomChangeListener implements ZoomRenderer.OnZoomChangedListener {
+        @Override
+        public void onZoomValueChanged(int index) {
+            int newZoom = mController.onZoomChanged(index);
+            if (mZoomRenderer != null) {
+                mZoomRenderer.setZoomValue(mZoomRatios.get(newZoom));
+            }
+        }
+
+        @Override
+        public void onZoomStart() {
+            if (mPieRenderer != null) {
+                mPieRenderer.hide();
+                mPieRenderer.setBlockFocus(true);
+            }
+        }
+
+        @Override
+        public void onZoomEnd() {
+            if (mPieRenderer != null) {
+                mPieRenderer.setBlockFocus(false);
+            }
+        }
+
+        @Override
+        public void onZoomValueChanged(float value) {
+
+        }
+    }
+
+    @Override
+    public void onPieOpened(int centerX, int centerY) {
+        setSwipingEnabled(false);
+        if (mFaceView != null) {
+            mFaceView.setBlockDraw(true);
+        }
+        // Close module selection menu when pie menu is opened.
+        mSwitcher.closePopup();
+        if (mIsBokehMode && mBlurDegreeProgressBar != null) {
+            mBlurDegreeProgressBar.setVisibility(View.VISIBLE);
+        }
+    }
+
+    @Override
+    public void onPieClosed() {
+        setSwipingEnabled(true);
+        if (mFaceView != null) {
+            mFaceView.setBlockDraw(false);
+        }
+        if (mBlurDegreeProgressBar != null) {
+            mBlurDegreeProgressBar.setVisibility(View.GONE);
+        }
+    }
+
+    @Override
+    public void onPieMoved(int centerX, int centerY) {
+        Size bokehCircle = mPieRenderer.getBokehFocusSize();
+        int y;
+        if (centerY > mPieRenderer.getHeight()/2) {
+            y = centerY - bokehCircle.getHeight()/2 - mBlurDegreeProgressBar.getHeight();
+        } else {
+            y = centerY + bokehCircle.getHeight()/2;
+        }
+        mBlurDegreeProgressBar.setX(centerX - mBlurDegreeProgressBar.getWidth() /2);
+        mBlurDegreeProgressBar.setY(y);
+        if (mIsBokehMode && mBlurDegreeProgressBar.getVisibility() != View.VISIBLE
+                && mPieRenderer.isVisible()) {
+            mBlurDegreeProgressBar.setVisibility(View.VISIBLE);
+        }
+    }
+
+    public void enableBokehRender(boolean enable) {
+        if (mPieRenderer != null) {
+            mPieRenderer.setBokehMode(enable);
+            mIsBokehMode = enable;
+        }
+    }
+
+    public void enableBokehFocus(boolean enable) {
+        if (mPieRenderer != null && mIsBokehMode) {
+            mPieRenderer.setBokehMode(enable);
+            if (mBlurDegreeProgressBar != null) {
+                if (enable && mPieRenderer.isVisible()) {
+                    mBlurDegreeProgressBar.setVisibility(View.VISIBLE);
+                } else {
+                    mBlurDegreeProgressBar.setVisibility(View.GONE);
+                }
+            }
+        }
+    }
+
+    public void setBokehRenderDegree(int degree) {
+        if (mPieRenderer != null) {
+            mPieRenderer.setBokehDegree(degree);
+        }
+    }
+
+    public void setSwipingEnabled(boolean enable) {
+        mActivity.setSwipingEnabled(enable);
+    }
+
+    public SurfaceHolder getSurfaceHolder() {
+        return mSurfaceHolder;
+    }
+
+    public void hideSurfaceView() {
+        mSurfaceView.setVisibility(View.INVISIBLE);
+    }
+
+    public void showSurfaceView() {
+        mSurfaceView.setVisibility(View.VISIBLE);
+    }
+    // Countdown timer
+
+    private void initializeCountDown() {
+        mActivity.getLayoutInflater().inflate(R.layout.count_down_to_capture,
+                (ViewGroup) mRootView, true);
+        mCountDownView = (CountDownView) (mRootView.findViewById(R.id.count_down_to_capture));
+        mCountDownView.setCountDownFinishedListener((OnCountDownFinishedListener) mController);
+        mCountDownView.bringToFront();
+        mCountDownView.setOrientation(mOrientation);
+    }
+
+    public boolean isCountingDown() {
+        return mCountDownView != null && mCountDownView.isCountingDown();
+    }
+
+    public void cancelCountDown() {
+        if (mCountDownView == null) return;
+        mCountDownView.cancelCountDown();
+        showUIAfterCountDown();
+    }
+
+    public void startCountDown(int sec, boolean playSound) {
+        if (mCountDownView == null) initializeCountDown();
+        mCountDownView.startCountDown(sec, playSound);
+        hideUIWhileCountDown();
+    }
+
+    public void startSelfieFlash() {
+        if(mSelfieView == null)
+            mSelfieView = (SelfieFlashView) (mRootView.findViewById(R.id.selfie_flash));
+        mSelfieView.bringToFront();
+        mSelfieView.open();
+        mScreenBrightness = setScreenBrightness(1F);
+    }
+
+    public void stopSelfieFlash() {
+        if(mSelfieView == null)
+            mSelfieView = (SelfieFlashView) (mRootView.findViewById(R.id.selfie_flash));
+        mSelfieView.close();
+        if(mScreenBrightness != 0.0f)
+            setScreenBrightness(mScreenBrightness);
+    }
+
+    private float setScreenBrightness(float brightness) {
+        float originalBrightness;
+        Window window = mActivity.getWindow();
+        WindowManager.LayoutParams layout = window.getAttributes();
+        originalBrightness = layout.screenBrightness;
+        layout.screenBrightness = brightness;
+        window.setAttributes(layout);
+        return originalBrightness;
+    }
+
+    public void showPreferencesToast() {
+        if (mNotSelectableToast == null) {
+            String str = mActivity.getResources().getString(R.string.not_selectable_in_scene_mode);
+            mNotSelectableToast = RotateTextToast.makeText(mActivity, str, Toast.LENGTH_SHORT);
+        }
+        mNotSelectableToast.show();
+    }
+
+    public void showPreviewCover() {
+        mPreviewCover.setVisibility(View.VISIBLE);
+    }
+
+    public void hidePreviewCover() {
+        // Hide the preview cover if need.
+        if (mPreviewCover.getVisibility() != View.GONE) {
+            mPreviewCover.setVisibility(View.GONE);
+        }
+    }
+
+    public boolean isPreviewCoverVisible() {
+        if ((mPreviewCover != null) &&
+            (mPreviewCover.getVisibility() == View.VISIBLE)) {
+            return true;
+        } else {
+            return false;
+        }
+    }
+
+    public void onPause() {
+        cancelCountDown();
+
+        // Clear UI.
+        collapseCameraControls();
+        if (mFaceView != null) mFaceView.clear();
+
+        if (mLocationDialog != null && mLocationDialog.isShowing()) {
+            mLocationDialog.dismiss();
+        }
+        mLocationDialog = null;
+        if (mMenu != null) {
+            mMenu.animateSlideOutPreviewMenu();
+        }
+    }
+
+    public void initDisplayChangeListener() {
+        ((CameraRootView) mRootView).setDisplayChangeListener(this);
+    }
+
+    public void removeDisplayChangeListener() {
+        ((CameraRootView) mRootView).removeDisplayChangeListener();
+    }
+
+    public FocusRing getFocusRing() {
+        return mFocusRing;
+    }
+
+    public void onStartFaceDetection(int orientation, boolean mirror) {
+        mFaceView.setBlockDraw(false);
+        mFaceView.clear();
+        mFaceView.setVisibility(View.VISIBLE);
+        mFaceView.setDisplayOrientation(orientation);
+        mFaceView.setMirror(mirror);
+        mFaceView.resume();
+    }
+
+    public void onStopFaceDetection() {
+        if (mFaceView != null) {
+            mFaceView.setBlockDraw(true);
+            mFaceView.clear();
+        }
+    }
+
+    @Override
+    public void onFaceDetection(Face[] faces, CameraManager.CameraProxy camera) {
+        if (mIsBokehMode) {
+            mFaceView.clear();
+            return;
+        }
+        mFaceView.setFaces(faces);
+    }
+
+    public boolean onScaleStepResize(boolean direction) {
+        if(mGestures != null){
+            return mGestures.onScaleStepResize(direction);
+        }
+        return false;
+    }
+
+    @Override
+    public void onDisplayChanged() {
+        Log.d(TAG, "Device flip detected.");
+        mCameraControls.checkLayoutFlip();
+        mController.updateCameraOrientation();
+    }
+
+    public void setPreference(String key, String value) {
+        mMenu.setPreference(key, value);
+    }
+
+    public void updateRemainingPhotos(int remaining) {
+        mCameraControls.updateRemainingPhotos(remaining);
+    }
+
+    public void setOrientation(int orientation, boolean animation) {
+        mOrientation = orientation;
+        mCameraControls.setOrientation(orientation, animation);
+        if (mMenuLayout != null)
+            mMenuLayout.setOrientation(orientation, animation);
+        if (mSubMenuLayout != null)
+            mSubMenuLayout.setOrientation(orientation, animation);
+        if (mPreviewMenuLayout != null) {
+            ViewGroup vg = (ViewGroup) mPreviewMenuLayout.getChildAt(0);
+            if (vg != null)
+                vg = (ViewGroup) vg.getChildAt(0);
+            if (vg != null) {
+                for (int i = vg.getChildCount() - 1; i >= 0; --i) {
+                    RotateLayout l = (RotateLayout) vg.getChildAt(i);
+                    l.setOrientation(orientation, animation);
+                }
+            }
+        }
+        if (mCountDownView != null)
+            mCountDownView.setOrientation(orientation);
+        RotateTextToast.setOrientation(orientation);
+        if (mFaceView != null) {
+            mFaceView.setDisplayRotation(orientation);
+        }
+        if (mZoomRenderer != null) {
+            mZoomRenderer.setOrientation(orientation);
+        }
+        if (mReviewImage != null) {
+            RotateImageView v = (RotateImageView) mReviewImage;
+            v.setOrientation(orientation, animation);
+        }
+        mOrientation = orientation;
+    }
+
+    public void tryToCloseSubList() {
+        if (mMenu != null)
+            mMenu.tryToCloseSubList();
+    }
+
+    public int getOrientation() {
+        return mOrientation;
+    }
+
+    public void adjustOrientation() {
+        setOrientation(mOrientation, true);
+    }
+
+    public void hideUIWhileCountDown() {
+        mMenu.hideCameraControls(true);
+        mGestures.setZoomOnly(true);
+    }
+
+    public void showUIAfterCountDown() {
+        mMenu.hideCameraControls(false);
+        mGestures.setZoomOnly(false);
+    }
+}
diff --git a/src/com/android/camera/SVideoMenu.java b/src/com/android/camera/SVideoMenu.java
new file mode 100644
index 0000000..b016049
--- /dev/null
+++ b/src/com/android/camera/SVideoMenu.java
@@ -0,0 +1,922 @@
+/*
+ * Copyright (C) 2012 The Android Open Source Project
+ * Copyright (C) 2013-2015 The CyanogenMod Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.camera;
+
+import android.animation.Animator;
+import android.animation.Animator.AnimatorListener;
+import android.content.Context;
+import android.content.res.Resources;
+import android.content.SharedPreferences;
+import android.graphics.Rect;
+import android.preference.PreferenceManager;
+import android.util.Log;
+import android.view.LayoutInflater;
+import android.view.MotionEvent;
+import android.view.View;
+import android.view.View.OnClickListener;
+import android.view.ViewPropertyAnimator;
+import android.widget.ListView;
+import android.widget.TextView;
+import android.widget.GridView;
+import android.widget.ImageView;
+import android.widget.LinearLayout;
+import android.widget.FrameLayout;
+import android.widget.FrameLayout.LayoutParams;
+
+import com.android.camera.ui.CameraControls;
+import com.android.camera.ui.ListSubMenu;
+import com.android.camera.ui.ListMenu;
+import com.android.camera.ui.TimeIntervalPopup;
+import com.android.camera.ui.RotateImageView;
+import com.android.camera.ui.RotateTextToast;
+import org.codeaurora.snapcam.R;
+import android.widget.HorizontalScrollView;
+import android.widget.Toast;
+import android.view.ViewGroup;
+import android.view.WindowManager;
+import android.view.Display;
+import com.android.camera.ui.RotateLayout;
+import com.android.camera.util.CameraUtil;
+import android.text.TextUtils;
+import java.util.Locale;
+
+public class SVideoMenu extends MenuController
+        implements ListMenu.Listener,
+        ListSubMenu.Listener,
+        TimeIntervalPopup.Listener {
+
+    private static String TAG = "SVideoMenu";
+
+    private SVideoUI mUI;
+    private String[] mOtherKeys1;
+    private String[] mOtherKeys2;
+
+    private ListMenu mListMenu;
+    private ListSubMenu mListSubMenu;
+    private View mPreviewMenu;
+    private static final int POPUP_NONE = 0;
+    private static final int POPUP_FIRST_LEVEL = 1;
+    private static final int POPUP_SECOND_LEVEL = 2;
+    private static final int POPUP_IN_ANIMATION_SLIDE = 3;
+    private static final int POPUP_IN_ANIMATION_FADE = 4;
+    private static final int PREVIEW_MENU_NONE = 0;
+    private static final int PREVIEW_MENU_IN_ANIMATION = 1;
+    private static final int PREVIEW_MENU_ON = 2;
+    private static final int MODE_FILTER = 1;
+    private static final int DEVELOPER_MENU_TOUCH_COUNT = 7;
+    private int mSceneStatus;
+    private View mFrontBackSwitcher;
+    private View mFilterModeSwitcher;
+    private int mPopupStatus;
+    private int mPreviewMenuStatus;
+    private CameraActivity mActivity;
+    private int mPrivateCounter = 0;
+    private static final int ANIMATION_DURATION = 300;
+    private static final int CLICK_THRESHOLD = 200;
+    private int previewMenuSize;
+
+    public SVideoMenu(CameraActivity activity, SVideoUI ui) {
+        super(activity);
+        mUI = ui;
+        mActivity = activity;
+        mFrontBackSwitcher = ui.getRootView().findViewById(R.id.front_back_switcher);
+        mFilterModeSwitcher = ui.getRootView().findViewById(R.id.filter_mode_switcher);
+    }
+
+    public void initialize(PreferenceGroup group) {
+        super.initialize(group);
+        mListMenu = null;
+        mListSubMenu = null;
+        mPopupStatus = POPUP_NONE;
+        mPreviewMenuStatus = POPUP_NONE;
+        initFilterModeButton(mFilterModeSwitcher);
+        // settings popup
+        mOtherKeys1 = new String[] {
+                CameraSettings.KEY_VIDEOCAMERA_FLASH_MODE,
+                CameraSettings.KEY_RECORD_LOCATION,
+                CameraSettings.KEY_VIDEO_QUALITY,
+                CameraSettings.KEY_CAMERA_SAVEPATH,
+                CameraSettings.KEY_EXPOSURE,
+                CameraSettings.KEY_WHITE_BALANCE,
+                CameraSettings.KEY_VIDEOCAMERA_FOCUS_MODE,
+                CameraSettings.KEY_VIDEOCAMERA_FOCUS_TIME,
+                CameraSettings.KEY_VIDEO_HIGH_FRAME_RATE,
+                CameraSettings.KEY_DIS,
+                CameraSettings.KEY_POWER_SHUTTER,
+                CameraSettings.KEY_MAX_BRIGHTNESS
+        };
+        mOtherKeys2 = new String[] {
+                CameraSettings.KEY_VIDEOCAMERA_FLASH_MODE,
+                CameraSettings.KEY_RECORD_LOCATION,
+                CameraSettings.KEY_VIDEO_QUALITY,
+                CameraSettings.KEY_VIDEO_SNAPSHOT_SIZE,
+                CameraSettings.KEY_CAMERA_SAVEPATH,
+                CameraSettings.KEY_FACE_DETECTION,
+                CameraSettings.KEY_EXPOSURE,
+                CameraSettings.KEY_WHITE_BALANCE,
+                CameraSettings.KEY_VIDEOCAMERA_FOCUS_MODE,
+                CameraSettings.KEY_VIDEOCAMERA_FOCUS_TIME,
+                CameraSettings.KEY_VIDEO_HIGH_FRAME_RATE,
+                CameraSettings.KEY_POWER_SHUTTER,
+                CameraSettings.KEY_MAX_BRIGHTNESS,
+                CameraSettings.KEY_SEE_MORE,
+                CameraSettings.KEY_DIS,
+                CameraSettings.KEY_VIDEO_EFFECT,
+                CameraSettings.KEY_VIDEO_TIME_LAPSE_FRAME_INTERVAL,
+                CameraSettings.KEY_VIDEO_ENCODER,
+                CameraSettings.KEY_AUDIO_ENCODER,
+                CameraSettings.KEY_VIDEO_HDR,
+                CameraSettings.KEY_ANTIBANDING,
+                CameraSettings.KEY_POWER_MODE,
+                CameraSettings.KEY_VIDEO_ROTATION,
+                CameraSettings.KEY_VIDEO_SNAPSHOT_SIZE,
+                CameraSettings.KEY_ZOOM
+        };
+        initSwitchItem(CameraSettings.KEY_CAMERA_ID, mFrontBackSwitcher);
+    }
+
+    public boolean handleBackKey() {
+        if (mPreviewMenuStatus == PREVIEW_MENU_ON) {
+            animateSlideOut(mPreviewMenu);
+            return true;
+        }
+        if (mPopupStatus == POPUP_NONE)
+            return false;
+        if (mPopupStatus == POPUP_FIRST_LEVEL) {
+            animateSlideOut(mListMenu, 1);
+        } else if (mPopupStatus == POPUP_SECOND_LEVEL) {
+            animateFadeOut(mListSubMenu, 2);
+            ((ListMenu) mListMenu).resetHighlight();
+        }
+        return true;
+    }
+
+    public void closeSceneMode() {
+        mUI.removeSceneModeMenu();
+    }
+
+    public void tryToCloseSubList() {
+        if (mListMenu != null)
+            ((ListMenu) mListMenu).resetHighlight();
+
+        if (mPopupStatus == POPUP_SECOND_LEVEL) {
+            mUI.dismissLevel2();
+            mPopupStatus = POPUP_FIRST_LEVEL;
+        }
+    }
+
+    private void animateFadeOut(final ListView v, final int level) {
+        if (v == null || mPopupStatus == POPUP_IN_ANIMATION_FADE)
+            return;
+        mPopupStatus = POPUP_IN_ANIMATION_FADE;
+
+        ViewPropertyAnimator vp = v.animate();
+        vp.alpha(0f).setDuration(ANIMATION_DURATION);
+        vp.setListener(new AnimatorListener() {
+            @Override
+            public void onAnimationStart(Animator animation) {
+            }
+
+            @Override
+            public void onAnimationRepeat(Animator animation) {
+
+            }
+
+            @Override
+            public void onAnimationEnd(Animator animation) {
+                if (level == 1) {
+                    mUI.dismissLevel1();
+                    initializePopup();
+                    mPopupStatus = POPUP_NONE;
+                    mUI.cleanupListview();
+                }
+                else if (level == 2) {
+                    mUI.dismissLevel2();
+                    mPopupStatus = POPUP_FIRST_LEVEL;
+                }
+            }
+
+            @Override
+            public void onAnimationCancel(Animator animation) {
+                if (level == 1) {
+                    mUI.dismissLevel1();
+                    initializePopup();
+                    mPopupStatus = POPUP_NONE;
+                    mUI.cleanupListview();
+                }
+                else if (level == 2) {
+                    mUI.dismissLevel2();
+                    mPopupStatus = POPUP_FIRST_LEVEL;
+                }
+
+            }
+        });
+        vp.start();
+    }
+
+    private void animateSlideOut(final ListView v, final int level) {
+        if (v == null || mPopupStatus == POPUP_IN_ANIMATION_SLIDE)
+            return;
+        mPopupStatus = POPUP_IN_ANIMATION_SLIDE;
+
+        ViewPropertyAnimator vp = v.animate();
+        if (View.LAYOUT_DIRECTION_RTL == TextUtils
+                .getLayoutDirectionFromLocale(Locale.getDefault())) {
+            switch (mUI.getOrientation()) {
+                case 0:
+                    vp.translationXBy(v.getWidth());
+                    break;
+                case 90:
+                    vp.translationYBy(-2 * v.getHeight());
+                    break;
+                case 180:
+                    vp.translationXBy(-2 * v.getWidth());
+                    break;
+                case 270:
+                    vp.translationYBy(v.getHeight());
+                    break;
+            }
+        } else {
+            switch (mUI.getOrientation()) {
+                case 0:
+                    vp.translationXBy(-v.getWidth());
+                    break;
+                case 90:
+                    vp.translationYBy(2 * v.getHeight());
+                    break;
+                case 180:
+                    vp.translationXBy(2 * v.getWidth());
+                    break;
+                case 270:
+                    vp.translationYBy(-v.getHeight());
+                    break;
+            }
+        }
+
+        vp.setListener(new AnimatorListener() {
+            @Override
+            public void onAnimationStart(Animator animation) {
+            }
+
+            @Override
+            public void onAnimationRepeat(Animator animation) {
+
+            }
+
+            @Override
+            public void onAnimationEnd(Animator animation) {
+                if (level == 1) {
+                    mUI.dismissLevel1();
+                    initializePopup();
+                    mPopupStatus = POPUP_NONE;
+                    mUI.cleanupListview();
+                } else if (level == 2) {
+                    mUI.dismissLevel2();
+                    mPopupStatus = POPUP_FIRST_LEVEL;
+                }
+            }
+
+            @Override
+            public void onAnimationCancel(Animator animation) {
+                if (level == 1) {
+                    mUI.dismissLevel1();
+                    initializePopup();
+                    mPopupStatus = POPUP_NONE;
+                    mUI.cleanupListview();
+                } else if (level == 2) {
+                    mUI.dismissLevel2();
+                    mPopupStatus = POPUP_FIRST_LEVEL;
+                }
+
+            }
+        });
+        vp.setDuration(ANIMATION_DURATION).start();
+    }
+
+    public void animateFadeIn(final ListView v) {
+        ViewPropertyAnimator vp = v.animate();
+        vp.alpha(1f).setDuration(ANIMATION_DURATION);
+        vp.start();
+    }
+
+    public void animateSlideIn(final View v, int delta, boolean adjustOrientation) {
+        int orientation = mUI.getOrientation();
+        if (!adjustOrientation)
+            orientation = 0;
+
+        ViewPropertyAnimator vp = v.animate();
+        float dest;
+        if (View.LAYOUT_DIRECTION_RTL == TextUtils
+                .getLayoutDirectionFromLocale(Locale.getDefault())) {
+            switch (orientation) {
+                case 0:
+                    dest = v.getX();
+                    v.setX(-(dest - delta));
+                    vp.translationX(dest);
+                    break;
+                case 90:
+                    dest = v.getY();
+                    v.setY(-(dest + delta));
+                    vp.translationY(dest);
+                    break;
+                case 180:
+                    dest = v.getX();
+                    v.setX(-(dest + delta));
+                    vp.translationX(dest);
+                    break;
+                case 270:
+                    dest = v.getY();
+                    v.setY(-(dest - delta));
+                    vp.translationY(dest);
+                    break;
+            }
+        } else {
+            switch (orientation) {
+                case 0:
+                    dest = v.getX();
+                    v.setX(dest - delta);
+                    vp.translationX(dest);
+                    break;
+                case 90:
+                    dest = v.getY();
+                    v.setY(dest + delta);
+                    vp.translationY(dest);
+                    break;
+                case 180:
+                    dest = v.getX();
+                    v.setX(dest + delta);
+                    vp.translationX(dest);
+                    break;
+                case 270:
+                    dest = v.getY();
+                    v.setY(dest - delta);
+                    vp.translationY(dest);
+                    break;
+            }
+        }
+
+        vp.setDuration(ANIMATION_DURATION).start();
+    }
+
+    public void animateSlideOutPreviewMenu() {
+        if (mPreviewMenu == null)
+            return;
+        animateSlideOut(mPreviewMenu);
+    }
+
+    private void animateSlideOut(final View v) {
+        if (v == null || mPreviewMenuStatus == PREVIEW_MENU_IN_ANIMATION)
+            return;
+        mPreviewMenuStatus = PREVIEW_MENU_IN_ANIMATION;
+
+        ViewPropertyAnimator vp = v.animate();
+        if (View.LAYOUT_DIRECTION_RTL == TextUtils
+                .getLayoutDirectionFromLocale(Locale.getDefault())) {
+            vp.translationXBy(v.getWidth()).setDuration(ANIMATION_DURATION);
+        } else {
+            vp.translationXBy(-v.getWidth()).setDuration(ANIMATION_DURATION);
+        }
+        vp.setListener(new AnimatorListener() {
+            @Override
+            public void onAnimationStart(Animator animation) {
+            }
+
+            @Override
+            public void onAnimationRepeat(Animator animation) {
+
+            }
+
+            @Override
+            public void onAnimationEnd(Animator animation) {
+                closeSceneMode();
+                mPreviewMenuStatus = PREVIEW_MENU_NONE;
+            }
+
+            @Override
+            public void onAnimationCancel(Animator animation) {
+                closeSceneMode();
+                mPreviewMenuStatus = PREVIEW_MENU_NONE;
+            }
+        });
+        vp.setDuration(ANIMATION_DURATION).start();
+    }
+
+    public boolean isOverMenu(MotionEvent ev) {
+        if (mPopupStatus == POPUP_NONE
+                || mPopupStatus == POPUP_IN_ANIMATION_SLIDE
+                || mPopupStatus == POPUP_IN_ANIMATION_FADE)
+            return false;
+        if (mUI.getMenuLayout() == null)
+            return false;
+        Rect rec = new Rect();
+        mUI.getMenuLayout().getChildAt(0).getHitRect(rec);
+        return rec.contains((int) ev.getX(), (int) ev.getY());
+    }
+
+    public boolean isOverPreviewMenu(MotionEvent ev) {
+        if (mPreviewMenuStatus != PREVIEW_MENU_ON)
+            return false;
+        if (mUI.getPreviewMenuLayout() == null)
+            return false;
+        Rect rec = new Rect();
+        mUI.getPreviewMenuLayout().getChildAt(0).getHitRect(rec);
+        rec.top += (int) mUI.getPreviewMenuLayout().getY();
+        rec.bottom += (int) mUI.getPreviewMenuLayout().getY();
+        return rec.contains((int) ev.getX(), (int) ev.getY());
+    }
+
+    public boolean isMenuBeingShown() {
+        return mPopupStatus != POPUP_NONE;
+    }
+
+    public boolean isMenuBeingAnimated() {
+        return mPopupStatus == POPUP_IN_ANIMATION_SLIDE || mPopupStatus == POPUP_IN_ANIMATION_FADE;
+    }
+
+    public boolean isPreviewMenuBeingShown() {
+        return mPreviewMenuStatus == PREVIEW_MENU_ON;
+    }
+
+    public boolean isPreviewMenuBeingAnimated() {
+        return mPreviewMenuStatus == PREVIEW_MENU_IN_ANIMATION;
+    }
+
+    public boolean sendTouchToPreviewMenu(MotionEvent ev) {
+        return mUI.sendTouchToPreviewMenu(ev);
+    }
+
+    public boolean sendTouchToMenu(MotionEvent ev) {
+        return mUI.sendTouchToMenu(ev);
+    }
+
+    public void initSwitchItem(final String prefKey, View switcher) {
+        final IconListPreference pref =
+                (IconListPreference) mPreferenceGroup.findPreference(prefKey);
+        if (pref == null)
+            return;
+
+        int[] iconIds = pref.getLargeIconIds();
+        int resid = -1;
+        int index = pref.findIndexOfValue(pref.getValue());
+        if (!pref.getUseSingleIcon() && iconIds != null) {
+            if (index == -1) {
+                return;
+            }
+            // Each entry has a corresponding icon.
+            index = index % iconIds.length;
+            resid = iconIds[index];
+        } else {
+            // The preference only has a single icon to represent it.
+            resid = pref.getSingleIcon();
+        }
+        ((ImageView) switcher).setImageResource(resid);
+        mPreferences.add(pref);
+        mPreferenceMap.put(pref, switcher);
+        switcher.setOnClickListener(new OnClickListener() {
+            @Override
+            public void onClick(View v) {
+                IconListPreference pref = (IconListPreference) mPreferenceGroup
+                        .findPreference(prefKey);
+                if (pref == null)
+                    return;
+                int index = pref.findIndexOfValue(pref.getValue());
+                CharSequence[] values = pref.getEntryValues();
+                index = (index + 1) % values.length;
+                pref.setValueIndex(index);
+                int iconListLength = ((IconListPreference) pref).getLargeIconIds().length;
+                ((ImageView) v).setImageResource(
+                        ((IconListPreference) pref).getLargeIconIds()[index % iconListLength]);
+                if (prefKey.equals(CameraSettings.KEY_CAMERA_ID))
+                    mListener.onCameraPickerClicked(index);
+                reloadPreference(pref);
+                onSettingChanged(pref);
+            }
+        });
+    }
+
+    public void initFilterModeButton(View button) {
+        button.setVisibility(View.INVISIBLE);
+        final IconListPreference pref = (IconListPreference) mPreferenceGroup
+                .findPreference(CameraSettings.KEY_VIDEOCAMERA_COLOR_EFFECT);
+        if (pref == null || pref.getValue() == null)
+            return;
+
+        changeFilterModeControlIcon(pref.getValue());
+        button.setVisibility(View.VISIBLE);
+        button.setOnClickListener(new OnClickListener() {
+            @Override
+            public void onClick(View v) {
+                addFilterMode();
+                ViewGroup menuLayout = mUI.getPreviewMenuLayout();
+                if (menuLayout != null) {
+                    View view = menuLayout.getChildAt(0);
+                    mUI.adjustOrientation();
+                    animateSlideIn(view, previewMenuSize, false);
+                }
+            }
+        });
+    }
+
+    public void addModeBack() {
+        if (mSceneStatus == MODE_FILTER) {
+            addFilterMode();
+        }
+    }
+
+    public void addFilterMode() {
+        final IconListPreference pref = (IconListPreference) mPreferenceGroup
+                .findPreference(CameraSettings.KEY_VIDEOCAMERA_COLOR_EFFECT);
+        if (pref == null)
+            return;
+
+        int rotation = CameraUtil.getDisplayRotation(mActivity);
+        boolean mIsDefaultToPortrait = CameraUtil.isDefaultToPortrait(mActivity);
+        if (!mIsDefaultToPortrait) {
+            rotation = (rotation + 90) % 360;
+        }
+        WindowManager wm = (WindowManager) mActivity.getSystemService(Context.WINDOW_SERVICE);
+        Display display = wm.getDefaultDisplay();
+        CharSequence[] entries = pref.getEntries();
+
+        Resources r = mActivity.getResources();
+        int height = (int) (r.getDimension(R.dimen.filter_mode_height) + 2
+                * r.getDimension(R.dimen.filter_mode_padding) + 1);
+        int width = (int) (r.getDimension(R.dimen.filter_mode_width) + 2
+                * r.getDimension(R.dimen.filter_mode_padding) + 1);
+
+        int gridRes = 0;
+        boolean portrait = (rotation == 0) || (rotation == 180);
+        int size = height;
+        if (portrait) {
+            gridRes = R.layout.vertical_grid;
+            size = width;
+        } else {
+            gridRes = R.layout.horiz_grid;
+        }
+        previewMenuSize = size;
+        mUI.hideUI();
+        mPreviewMenuStatus = PREVIEW_MENU_ON;
+        mSceneStatus = MODE_FILTER;
+
+        int[] thumbnails = pref.getThumbnailIds();
+
+        LayoutInflater inflater = (LayoutInflater) mActivity.getSystemService(
+                Context.LAYOUT_INFLATER_SERVICE);
+        FrameLayout basic = (FrameLayout) inflater.inflate(
+                gridRes, null, false);
+
+        mUI.dismissSceneModeMenu();
+        LinearLayout previewMenuLayout = new LinearLayout(mActivity);
+        mUI.setPreviewMenuLayout(previewMenuLayout);
+        ViewGroup.LayoutParams params = null;
+        if (portrait) {
+            params = new ViewGroup.LayoutParams(size, LayoutParams.MATCH_PARENT);
+            previewMenuLayout.setLayoutParams(params);
+            ((ViewGroup) mUI.getRootView()).addView(previewMenuLayout);
+        } else {
+            params = new ViewGroup.LayoutParams(LayoutParams.MATCH_PARENT, size);
+            previewMenuLayout.setLayoutParams(params);
+            ((ViewGroup) mUI.getRootView()).addView(previewMenuLayout);
+            previewMenuLayout.setY(display.getHeight() - size);
+        }
+        basic.setLayoutParams(new FrameLayout.LayoutParams(LayoutParams.MATCH_PARENT,
+                LayoutParams.MATCH_PARENT));
+        LinearLayout layout = (LinearLayout) basic.findViewById(R.id.layout);
+
+        final View[] views = new View[entries.length];
+        int init = pref.getCurrentIndex();
+        for (int i = 0; i < entries.length; i++) {
+            RotateLayout layout2 = (RotateLayout) inflater.inflate(
+                    R.layout.filter_mode_view, null, false);
+
+            ImageView imageView = (ImageView) layout2.findViewById(R.id.image);
+            final int j = i;
+
+            layout2.setOnTouchListener(new View.OnTouchListener() {
+                private long startTime;
+
+                @Override
+                public boolean onTouch(View v, MotionEvent event) {
+                    if (event.getAction() == MotionEvent.ACTION_DOWN) {
+                        startTime = System.currentTimeMillis();
+                    } else if (event.getAction() == MotionEvent.ACTION_UP) {
+                        if (System.currentTimeMillis() - startTime < CLICK_THRESHOLD) {
+                            pref.setValueIndex(j);
+                            changeFilterModeControlIcon(pref.getValue());
+                            for (View v1 : views) {
+                                v1.setActivated(v1 == v);
+                            }
+                            onSettingChanged(pref);
+                        }
+
+                    }
+                    return true;
+                }
+            });
+
+            views[j] = layout2;
+            layout2.setActivated(i == init);
+            TextView label = (TextView) layout2.findViewById(R.id.label);
+            imageView.setImageResource(thumbnails[i]);
+            label.setText(entries[i]);
+            layout.addView(layout2);
+        }
+        previewMenuLayout.addView(basic);
+        mPreviewMenu = basic;
+    }
+
+    private void changeFilterModeControlIcon(String value) {
+        if(!value.equals("")) {
+            if(value.equalsIgnoreCase("none")) {
+                value = "Off";
+            } else {
+                value = "On";
+            }
+            final IconListPreference pref = (IconListPreference) mPreferenceGroup
+                    .findPreference(CameraSettings.KEY_FILTER_MODE);
+            pref.setValue(value);
+            int index = pref.getCurrentIndex();
+            ImageView iv = (ImageView) mFilterModeSwitcher;
+            iv.setImageResource(((IconListPreference) pref).getLargeIconIds()[index]);
+        }
+    }
+
+    public void openFirstLevel() {
+        if (isMenuBeingShown() || CameraControls.isAnimating())
+            return;
+        if (mListMenu == null || mPopupStatus != POPUP_FIRST_LEVEL) {
+            initializePopup();
+            mPopupStatus = POPUP_FIRST_LEVEL;
+        }
+        mUI.showPopup(mListMenu, 1, true);
+    }
+
+    public void setPreference(String key, String value) {
+        ListPreference pref = mPreferenceGroup.findPreference(key);
+        if (pref != null && !value.equals(pref.getValue())) {
+            pref.setValue(value);
+            reloadPreferences();
+        }
+    }
+
+    private void overridePreferenceAccessibility() {
+        overrideMenuForLocation();
+        overrideMenuFor4K();
+    }
+
+    private void overrideMenuForLocation() {
+        if (mActivity.isSecureCamera()) {
+            // Prevent location preference from getting changed in secure camera
+            // mode
+            mListMenu.setPreferenceEnabled(CameraSettings.KEY_RECORD_LOCATION, false);
+        }
+    }
+    private void overrideMenuFor4K() {
+        if(mUI.is4KEnabled()) {
+            mListMenu.setPreferenceEnabled(
+                     CameraSettings.KEY_DIS,false);
+            mListMenu.overrideSettings(
+                     CameraSettings.KEY_DIS, "disable");
+
+            mListMenu.setPreferenceEnabled(
+                    CameraSettings.KEY_SEE_MORE, false);
+            mListMenu.overrideSettings(
+                    CameraSettings.KEY_SEE_MORE, mActivity.getString(R.string.pref_camera_see_more_value_off));
+        }
+    }
+
+    private void overrideMenuForVideoHighFrameRate() {
+        ListPreference disPref = mPreferenceGroup
+                .findPreference(CameraSettings.KEY_DIS);
+        ListPreference frameIntervalPref = mPreferenceGroup
+                .findPreference(CameraSettings.KEY_VIDEO_TIME_LAPSE_FRAME_INTERVAL);
+        ListPreference videoHDRPref = mPreferenceGroup
+                .findPreference(CameraSettings.KEY_VIDEO_HDR);
+        String disMode = disPref == null ? "disable" : disPref.getValue();
+        String videoHDR = videoHDRPref == null ? "off" : videoHDRPref.getValue();
+        String frameIntervalStr = frameIntervalPref.getValue();
+        int timeLapseInterval = Integer.parseInt(frameIntervalStr);
+        int PERSIST_EIS_MAX_FPS =  android.os.SystemProperties
+                .getInt("persist.camcorder.eis.maxfps", 30);
+        ListPreference hfrPref = mPreferenceGroup
+                .findPreference(CameraSettings.KEY_VIDEO_HIGH_FRAME_RATE);
+        String highFrameRate;
+        if (hfrPref == null) {
+            //If hfrPref is null, use whitespace instead.
+            highFrameRate = "     ";
+        } else {
+            highFrameRate = hfrPref.getValue();
+        }
+        boolean isHFR = "hfr".equals(highFrameRate.substring(0,3));
+        boolean isHSR = "hsr".equals(highFrameRate.substring(0,3));
+        int rate = 0;
+        if ( isHFR || isHSR ) {
+            String hfrRate = highFrameRate.substring(3);
+            rate = Integer.parseInt(hfrRate);
+        }
+
+        if ((disMode.equals("enable") && rate > PERSIST_EIS_MAX_FPS)
+                || !videoHDR.equals("off")
+                || timeLapseInterval != 0) {
+            mListMenu.setPreferenceEnabled(CameraSettings.KEY_VIDEO_HIGH_FRAME_RATE, false);
+            RotateTextToast.makeText(mActivity, R.string.error_app_unsupported_hfr_selection,
+                    Toast.LENGTH_LONG).show();
+        }
+
+    }
+
+    @Override
+    public void overrideSettings(final String... keyvalues) {
+        super.overrideSettings(keyvalues);
+        if (mListMenu == null) {
+            initializePopup();
+        } else {
+            overridePreferenceAccessibility();
+        }
+        mListMenu.overrideSettings(keyvalues);
+    }
+
+    @Override
+    // Hit when an item in the second-level popup gets selected
+    public void onListPrefChanged(ListPreference pref) {
+        onSettingChanged(pref);
+        closeView();
+    }
+
+    protected void initializePopup() {
+        LayoutInflater inflater = (LayoutInflater) mActivity.getSystemService(
+                Context.LAYOUT_INFLATER_SERVICE);
+
+        ListMenu popup1 = (ListMenu) inflater.inflate(
+                R.layout.list_menu, null, false);
+        popup1.setSettingChangedListener(this);
+        String[] keys = mOtherKeys1;
+        if (mActivity.isDeveloperMenuEnabled())
+            keys = mOtherKeys2;
+        popup1.initialize(mPreferenceGroup, keys);
+
+        mListMenu = popup1;
+
+        overridePreferenceAccessibility();
+        overrideMenuForVideoHighFrameRate();
+    }
+
+    public void popupDismissed(boolean topPopupOnly) {
+        // if the 2nd level popup gets dismissed
+        if (mPopupStatus == POPUP_SECOND_LEVEL) {
+            initializePopup();
+            mPopupStatus = POPUP_FIRST_LEVEL;
+            if (topPopupOnly) {
+                mUI.showPopup(mListMenu, 1, false);
+            }
+        } else {
+            initializePopup();
+        }
+    }
+
+    public void hideUI() {
+        mFrontBackSwitcher.setVisibility(View.INVISIBLE);
+        mFilterModeSwitcher.setVisibility(View.INVISIBLE);
+    }
+
+    public void showUI() {
+        mFrontBackSwitcher.setVisibility(View.VISIBLE);
+        final IconListPreference pref = (IconListPreference) mPreferenceGroup
+                .findPreference(CameraSettings.KEY_FILTER_MODE);
+        if (pref != null) {
+            mFilterModeSwitcher.setVisibility(View.VISIBLE);
+        }
+    }
+
+    @Override
+    // Hit when an item in the first-level popup gets selected, then bring up
+    // the second-level popup
+    public void onPreferenceClicked(ListPreference pref) {
+        onPreferenceClicked(pref, 0);
+    }
+
+    @Override
+    // Hit when an item in the first-level popup gets selected, then bring up
+    // the second-level popup
+    public void onPreferenceClicked(ListPreference pref, int y) {
+        LayoutInflater inflater = (LayoutInflater) mActivity.getSystemService(
+                Context.LAYOUT_INFLATER_SERVICE);
+
+        ListSubMenu basic = (ListSubMenu) inflater.inflate(
+                R.layout.list_sub_menu, null, false);
+        basic.initialize(pref, y);
+        basic.setSettingChangedListener(this);
+        mUI.removeLevel2();
+        mListSubMenu = basic;
+        if (mPopupStatus == POPUP_SECOND_LEVEL) {
+            mUI.showPopup(mListSubMenu, 2, false);
+        } else {
+            mUI.showPopup(mListSubMenu, 2, true);
+        }
+        mPopupStatus = POPUP_SECOND_LEVEL;
+
+        // Developer menu
+        if (pref.getKey().equals(CameraSettings.KEY_MAX_BRIGHTNESS)) {
+            mPrivateCounter++;
+            if (mPrivateCounter >= DEVELOPER_MENU_TOUCH_COUNT) {
+                SharedPreferences prefs = PreferenceManager
+                        .getDefaultSharedPreferences(mActivity);
+                if (!mActivity.isDeveloperMenuEnabled()) {
+                    mActivity.enableDeveloperMenu();
+                    prefs.edit().putBoolean(CameraSettings.KEY_DEVELOPER_MENU, true).apply();
+                    closeAllView();
+                    RotateTextToast.makeText(mActivity,
+                            R.string.developer_menu_enabled, Toast.LENGTH_SHORT).show();
+                } else {
+                    mActivity.disableDeveloperMenu();
+                    prefs.edit().putBoolean(CameraSettings.KEY_DEVELOPER_MENU, false).apply();
+                    closeAllView();
+                    RotateTextToast.makeText(mActivity,
+                            R.string.developer_menu_disabled, Toast.LENGTH_SHORT).show();
+                }
+                mPrivateCounter = 0;
+            }
+        } else {
+            mPrivateCounter = 0;
+        }
+    }
+
+    public void onListMenuTouched() {
+        mUI.removeLevel2();
+        mPopupStatus = POPUP_FIRST_LEVEL;
+    }
+
+    public void closeAllView() {
+        if (mUI != null)
+            mUI.removeLevel2();
+
+        if (mListMenu != null)
+            animateSlideOut(mListMenu, 1);
+        animateSlideOutPreviewMenu();
+    }
+
+    public void closeView() {
+        if (mUI != null)
+            mUI.removeLevel2();
+
+        if (mListMenu != null)
+            animateSlideOut(mListMenu, 1);
+    }
+
+    // Return true if the preference has the specified key but not the value.
+    private static boolean notSame(ListPreference pref, String key, String value) {
+        return (key.equals(pref.getKey()) && !value.equals(pref.getValue()));
+    }
+
+    @Override
+    public void onSettingChanged(ListPreference pref) {
+
+        if (notSame(pref, CameraSettings.KEY_VIDEO_TIME_LAPSE_FRAME_INTERVAL,
+                mActivity.getString(R.string.pref_video_time_lapse_frame_interval_default))) {
+            ListPreference hfrPref =
+                    mPreferenceGroup.findPreference(CameraSettings.KEY_VIDEO_HIGH_FRAME_RATE);
+            if (hfrPref != null && !"off".equals(hfrPref.getValue())) {
+                RotateTextToast.makeText(mActivity, R.string.error_app_unsupported_hfr_selection,
+                        Toast.LENGTH_LONG).show();
+            }
+            setPreference(CameraSettings.KEY_VIDEO_HIGH_FRAME_RATE, "off");
+        }
+        if (notSame(pref, CameraSettings.KEY_VIDEO_HIGH_FRAME_RATE, "off")) {
+            String defaultValue =
+                    mActivity.getString(R.string.pref_video_time_lapse_frame_interval_default);
+            ListPreference lapsePref = mPreferenceGroup
+                    .findPreference(CameraSettings.KEY_VIDEO_TIME_LAPSE_FRAME_INTERVAL);
+            if (lapsePref != null && !defaultValue.equals(lapsePref.getValue())) {
+                RotateTextToast.makeText(mActivity, R.string.error_app_unsupported_hfr_selection,
+                        Toast.LENGTH_LONG).show();
+            }
+            setPreference(CameraSettings.KEY_VIDEO_TIME_LAPSE_FRAME_INTERVAL, defaultValue);
+        }
+
+        if (notSame(pref, CameraSettings.KEY_RECORD_LOCATION, "off")) {
+            mActivity.requestLocationPermission();
+        }
+
+
+        super.onSettingChanged(pref);
+    }
+
+    public int getOrientation() {
+        return mUI == null ? 0 : mUI.getOrientation();
+    }
+}
diff --git a/src/com/android/camera/SVideoModule.java b/src/com/android/camera/SVideoModule.java
new file mode 100644
index 0000000..2d763cb
--- /dev/null
+++ b/src/com/android/camera/SVideoModule.java
@@ -0,0 +1,3284 @@
+/*
+ * Copyright (C) 2012 The Android Open Source Project
+ * Copyright (C) 2013-2015 The CyanogenMod Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.camera;
+
+import android.annotation.TargetApi;
+import android.app.Activity;
+import android.content.ActivityNotFoundException;
+import android.content.BroadcastReceiver;
+import android.content.ContentResolver;
+import android.content.ContentValues;
+import android.content.Context;
+import android.content.Intent;
+import android.content.IntentFilter;
+import android.content.SharedPreferences.Editor;
+import android.content.res.Configuration;
+import android.graphics.Bitmap;
+import android.graphics.ImageFormat;
+import android.hardware.Camera;
+import android.hardware.Camera.CameraInfo;
+import android.hardware.Camera.Parameters;
+import android.hardware.Camera.Size;
+import android.location.Location;
+import android.media.AudioManager;
+import android.media.CamcorderProfile;
+import android.media.CameraProfile;
+import android.media.MediaRecorder;
+import android.media.MediaMetadataRetriever;
+import android.net.Uri;
+import android.os.Build;
+import android.os.Bundle;
+import android.os.Handler;
+import android.os.Message;
+import android.os.SystemProperties;
+import android.os.ParcelFileDescriptor;
+import android.os.SystemClock;
+import android.provider.MediaStore;
+import android.provider.MediaStore.MediaColumns;
+import android.provider.MediaStore.Video;
+import android.util.Log;
+import android.view.KeyEvent;
+import android.view.OrientationEventListener;
+import android.view.SurfaceHolder;
+import android.view.View;
+import android.view.WindowManager;
+import android.widget.Toast;
+import android.media.EncoderCapabilities;
+import android.media.EncoderCapabilities.VideoEncoderCap;
+
+import com.android.camera.CameraManager.CameraAFCallback;
+import com.android.camera.CameraManager.CameraPictureCallback;
+import com.android.camera.CameraManager.CameraProxy;
+import com.android.camera.app.OrientationManager;
+import com.android.camera.exif.ExifInterface;
+import com.android.camera.ui.RotateImageView;
+import com.android.camera.ui.RotateTextToast;
+import com.android.camera.util.AccessibilityUtils;
+import com.android.camera.util.ApiHelper;
+import com.android.camera.util.CameraUtil;
+import com.android.camera.util.PersistUtil;
+import com.android.camera.util.UsageStatistics;
+import com.android.camera.SPhotoModule;
+
+import org.codeaurora.snapcam.R;
+import org.codeaurora.snapcam.wrapper.ParametersWrapper;
+import org.codeaurora.snapcam.wrapper.CamcorderProfileWrapper;
+
+import java.io.File;
+import java.io.IOException;
+import java.text.SimpleDateFormat;
+import java.util.Date;
+import java.util.Iterator;
+import java.util.List;
+import java.util.HashMap;
+import java.lang.reflect.Method;
+import java.util.regex.Pattern;
+
+public class SVideoModule implements CameraModule,
+    VideoController,
+    FocusOverlayManager.Listener,
+    CameraPreference.OnPreferenceChangedListener,
+    ShutterButton.OnShutterButtonListener,
+    LocationManager.Listener,
+    MediaRecorder.OnErrorListener,
+    MediaRecorder.OnInfoListener {
+
+    private static final String TAG = "CAM_SVideoModule";
+
+    private static final int CHECK_DISPLAY_ROTATION = 3;
+    private static final int CLEAR_SCREEN_DELAY = 4;
+    private static final int UPDATE_RECORD_TIME = 5;
+    private static final int ENABLE_SHUTTER_BUTTON = 6;
+    private static final int SHOW_TAP_TO_SNAPSHOT_TOAST = 7;
+    private static final int SWITCH_CAMERA = 8;
+    private static final int SWITCH_CAMERA_START_ANIMATION = 9;
+    private static final int HANDLE_FLASH_TORCH_DELAY = 10;
+    private static final int SET_FOCUS_RATIO = 11;
+
+    private static final int SCREEN_DELAY = 2 * 60 * 1000;
+
+    private static final long SDCARD_SIZE_LIMIT = 4000 * 1024 * 1024;
+
+    private static final long SHUTTER_BUTTON_TIMEOUT = 0L; // 0ms
+
+    /**
+     * An unpublished intent flag requesting to start recording straight away
+     * and return as soon as recording is stopped.
+     * TODO: consider publishing by moving into MediaStore.
+     */
+    private static final String EXTRA_QUICK_CAPTURE =
+            "android.intent.extra.quickCapture";
+
+    // module fields
+    private CameraActivity mActivity;
+    private boolean mPaused;
+    private int mCameraId;
+    private Parameters mParameters;
+    private boolean mFocusAreaSupported;
+    private boolean mMeteringAreaSupported;
+    private boolean mAeLockSupported;
+    private boolean mAwbLockSupported;
+
+    private boolean mIsInReviewMode;
+    private boolean mSnapshotInProgress = false;
+
+    private final CameraErrorCallback mErrorCallback = new CameraErrorCallback();
+
+    private ComboPreferences mPreferences;
+    private PreferenceGroup mPreferenceGroup;
+    private boolean mSaveToSDCard = false;
+
+    // Preference must be read before starting preview. We check this before starting
+    // preview.
+    private boolean mPreferenceRead;
+
+    private boolean mIsVideoCaptureIntent;
+    private boolean mQuickCapture;
+
+    private MediaRecorder mMediaRecorder;
+
+    private boolean mSwitchingCamera;
+    private boolean mMediaRecorderRecording = false;
+    private boolean mMediaRecorderPausing = false;
+    private long mRecordingStartTime;
+    private long mRecordingTotalTime;
+    private boolean mRecordingTimeCountsDown = false;
+    private long mOnResumeTime;
+    // The video file that the hardware camera is about to record into
+    // (or is recording into.)
+    private String mVideoFilename;
+    private ParcelFileDescriptor mVideoFileDescriptor;
+
+    // The video file that has already been recorded, and that is being
+    // examined by the user.
+    private String mCurrentVideoFilename;
+    private Uri mCurrentVideoUri;
+    private boolean mCurrentVideoUriFromMediaSaved;
+    private ContentValues mCurrentVideoValues;
+
+    private CamcorderProfile mProfile;
+
+    // The video duration limit. 0 menas no limit.
+    private int mMaxVideoDurationInMs;
+
+    // Time Lapse parameters.
+    private boolean mCaptureTimeLapse = false;
+    // Default 0. If it is larger than 0, the camcorder is in time lapse mode.
+    private int mTimeBetweenTimeLapseFrameCaptureMs = 0;
+
+    boolean mPreviewing = false; // True if preview is started.
+    // The display rotation in degrees. This is only valid when mPreviewing is
+    // true.
+    private int mDisplayRotation;
+    private int mCameraDisplayOrientation;
+    private int mOrientationOffset;
+
+    private int mDesiredPreviewWidth;
+    private int mDesiredPreviewHeight;
+    private ContentResolver mContentResolver;
+
+    private final AutoFocusCallback mAutoFocusCallback =
+            new AutoFocusCallback();
+
+    // This handles everything about focus.
+    private FocusOverlayManager mFocusManager;
+
+    private LocationManager mLocationManager;
+    private OrientationManager mOrientationManager;
+    private int mPendingSwitchCameraId;
+    private final Handler mHandler = new MainHandler();
+    private SVideoUI mUI;
+    private CameraProxy mCameraDevice;
+    private static final String KEY_PREVIEW_FORMAT = "preview-format";
+    private static final String FORMAT_NV12_VENUS = "nv12-venus";
+    private static final String FORMAT_NV21 = "yuv420sp";
+
+    // The degrees of the device rotated clockwise from its natural orientation.
+    private int mOrientation = OrientationEventListener.ORIENTATION_UNKNOWN;
+
+    private int mZoomValue;  // The current zoom value.
+
+    private boolean mStartRecPending = false;
+    private boolean mStopRecPending = false;
+    private boolean mStartPrevPending = false;
+    private boolean mStopPrevPending = false;
+
+    //settings, which if enabled, need to turn off low power mode
+    private boolean mIsFlipEnabled = false;
+    private boolean mIsDISEnabled = false;
+
+    // The preview window is on focus
+    private boolean mPreviewFocused = false;
+
+    private boolean mIsMute = false;
+    private boolean mWasMute = false;
+
+    private boolean mFaceDetectionEnabled = false;
+    private boolean mFaceDetectionStarted = false;
+
+    private static final int MAX_ZOOM = 10;
+    private int[] mZoomIdxTbl = {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1};
+
+    private final MediaSaveService.OnMediaSavedListener mOnVideoSavedListener =
+            new MediaSaveService.OnMediaSavedListener() {
+                @Override
+                public void onMediaSaved(Uri uri) {
+                    if (uri != null) {
+                        mCurrentVideoUri = uri;
+                        mCurrentVideoUriFromMediaSaved = true;
+                        onVideoSaved();
+                        mActivity.notifyNewMedia(uri);
+                    }
+                }
+            };
+
+    private final MediaSaveService.OnMediaSavedListener mOnPhotoSavedListener =
+            new MediaSaveService.OnMediaSavedListener() {
+                @Override
+                public void onMediaSaved(Uri uri) {
+                    if (uri != null) {
+                        mActivity.notifyNewMedia(uri);
+                    }
+                }
+            };
+
+    public void setMute(boolean enable, boolean isValue)
+    {
+        AudioManager am = (AudioManager)mActivity.getSystemService(Context.AUDIO_SERVICE);
+        am.setMicrophoneMute(enable);
+        if(isValue) {
+            mIsMute = enable;
+        }
+    }
+
+    public boolean isAudioMute()
+    {
+        return mIsMute;
+    }
+
+    protected class CameraOpenThread extends Thread {
+        @Override
+        public void run() {
+            openCamera();
+            if (mFocusManager == null) initializeFocusManager();
+        }
+    }
+
+    private void openCamera() {
+        if (mCameraDevice == null) {
+            mCameraDevice = CameraUtil.openCamera(
+                    mActivity, mCameraId, mHandler,
+                    mActivity.getCameraOpenErrorCallback());
+        }
+        if (mCameraDevice == null) {
+            // Error.
+            return;
+        }
+        mParameters = mCameraDevice.getParameters();
+        initializeCapabilities();
+        mPreviewFocused = arePreviewControlsVisible();
+    }
+
+    //QCOM data Members Starts here
+    static class DefaultHashMap<K, V> extends HashMap<K, V> {
+        private V mDefaultValue;
+
+        public void putDefault(V defaultValue) {
+            mDefaultValue = defaultValue;
+        }
+
+        @Override
+        public V get(Object key) {
+            V value = super.get(key);
+            return (value == null) ? mDefaultValue : value;
+        }
+        public K getKey(V toCheck) {
+            Iterator<K> it = this.keySet().iterator();
+            V val;
+            K key;
+            while(it.hasNext()) {
+                key = it.next();
+                val = this.get(key);
+                if (val.equals(toCheck)) {
+                    return key;
+                }
+            }
+        return null;
+        }
+    }
+
+
+    private static final DefaultHashMap<String, Integer>
+            OUTPUT_FORMAT_TABLE = new DefaultHashMap<String, Integer>();
+    private static final DefaultHashMap<String, Integer>
+            VIDEO_ENCODER_TABLE = new DefaultHashMap<String, Integer>();
+    private static final DefaultHashMap<String, Integer>
+            AUDIO_ENCODER_TABLE = new DefaultHashMap<String, Integer>();
+    private static final DefaultHashMap<String, Integer>
+            VIDEOQUALITY_BITRATE_TABLE = new DefaultHashMap<String, Integer>();
+
+    static {
+        OUTPUT_FORMAT_TABLE.put("3gp", MediaRecorder.OutputFormat.THREE_GPP);
+        OUTPUT_FORMAT_TABLE.put("mp4", MediaRecorder.OutputFormat.MPEG_4);
+        OUTPUT_FORMAT_TABLE.putDefault(MediaRecorder.OutputFormat.DEFAULT);
+
+        VIDEO_ENCODER_TABLE.put("h263", MediaRecorder.VideoEncoder.H263);
+        VIDEO_ENCODER_TABLE.put("h264", MediaRecorder.VideoEncoder.H264);
+        int h265 = ApiHelper.getIntFieldIfExists(MediaRecorder.VideoEncoder.class,
+                       "HEVC", null, MediaRecorder.VideoEncoder.DEFAULT);
+        if (h265 == MediaRecorder.VideoEncoder.DEFAULT) {
+            h265 = ApiHelper.getIntFieldIfExists(MediaRecorder.VideoEncoder.class,
+                       "H265", null, MediaRecorder.VideoEncoder.DEFAULT);
+        }
+        VIDEO_ENCODER_TABLE.put("h265", h265);
+        VIDEO_ENCODER_TABLE.put("m4v", MediaRecorder.VideoEncoder.MPEG_4_SP);
+        VIDEO_ENCODER_TABLE.putDefault(MediaRecorder.VideoEncoder.DEFAULT);
+
+        AUDIO_ENCODER_TABLE.put("amrnb", MediaRecorder.AudioEncoder.AMR_NB);
+        // Enabled once support is added in MediaRecorder.
+        // AUDIO_ENCODER_TABLE.put("qcelp", MediaRecorder.AudioEncoder.QCELP);
+        // AUDIO_ENCODER_TABLE.put("evrc", MediaRecorder.AudioEncoder.EVRC);
+        AUDIO_ENCODER_TABLE.put("amrwb", MediaRecorder.AudioEncoder.AMR_WB);
+        AUDIO_ENCODER_TABLE.put("aac", MediaRecorder.AudioEncoder.AAC);
+        AUDIO_ENCODER_TABLE.putDefault(MediaRecorder.AudioEncoder.DEFAULT);
+
+    }
+
+    private int mVideoEncoder;
+    private int mAudioEncoder;
+    private boolean mRestartPreview = false;
+    private int videoWidth;
+    private int videoHeight;
+    boolean mUnsupportedResolution = false;
+    private boolean mUnsupportedHFRVideoSize = false;
+    private boolean mUnsupportedHSRVideoSize = false;
+    private boolean mUnsupportedHFRVideoCodec = false;
+    boolean mUnsupportedProfile = false;
+
+    public void onScreenSizeChanged(int width, int height) {
+        if (mFocusManager != null) mFocusManager.setPreviewSize(width, height);
+    }
+
+    // This Handler is used to post message back onto the main thread of the
+    // application
+    private class MainHandler extends Handler {
+        @Override
+        public void handleMessage(Message msg) {
+            switch (msg.what) {
+
+                case ENABLE_SHUTTER_BUTTON:
+                    mUI.enableShutter(true);
+                    break;
+
+                case CLEAR_SCREEN_DELAY: {
+                    mActivity.getWindow().clearFlags(
+                            WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON);
+                    break;
+                }
+
+                case UPDATE_RECORD_TIME: {
+                    updateRecordingTime();
+                    break;
+                }
+
+                case CHECK_DISPLAY_ROTATION: {
+                    // Restart the preview if display rotation has changed.
+                    // Sometimes this happens when the device is held upside
+                    // down and camera app is opened. Rotation animation will
+                    // take some time and the rotation value we have got may be
+                    // wrong. Framework does not have a callback for this now.
+                    if ((CameraUtil.getDisplayRotation(mActivity) != mDisplayRotation)
+                            && !mMediaRecorderRecording && !mSwitchingCamera) {
+                        startPreview();
+                    }
+                    if (SystemClock.uptimeMillis() - mOnResumeTime < 5000) {
+                        mHandler.sendEmptyMessageDelayed(CHECK_DISPLAY_ROTATION, 100);
+                    }
+                    break;
+                }
+
+                case SHOW_TAP_TO_SNAPSHOT_TOAST: {
+                    showTapToSnapshotToast();
+                    break;
+                }
+
+                case SWITCH_CAMERA: {
+                    switchCamera();
+                    break;
+                }
+
+                case SWITCH_CAMERA_START_ANIMATION: {
+                    //TODO:
+                    //((CameraScreenNail) mActivity.mCameraScreenNail).animateSwitchCamera();
+
+                    // Enable all camera controls.
+                    mSwitchingCamera = false;
+                    break;
+                }
+
+                case HANDLE_FLASH_TORCH_DELAY: {
+                    forceFlashOff(!mPreviewFocused);
+                    break;
+                }
+
+                case SET_FOCUS_RATIO: {
+                    mUI.getFocusRing().setRadiusRatio((Float)msg.obj);
+                    break;
+                }
+
+                default:
+                    Log.v(TAG, "Unhandled message: " + msg.what);
+                    break;
+            }
+        }
+    }
+
+    private BroadcastReceiver mReceiver = null;
+
+    private class MyBroadcastReceiver extends BroadcastReceiver {
+        @Override
+        public void onReceive(Context context, Intent intent) {
+            String action = intent.getAction();
+            if (action.equals(Intent.ACTION_MEDIA_EJECT) ||
+                    action.equals(Intent.ACTION_SCREEN_OFF)) {
+                stopVideoRecording();
+                RotateTextToast.makeText(mActivity,
+                        mActivity.getResources().getString(R.string.video_recording_stopped),
+                                Toast.LENGTH_SHORT).show();
+            }
+        }
+    }
+
+    private String createName(long dateTaken) {
+        Date date = new Date(dateTaken);
+        SimpleDateFormat dateFormat = new SimpleDateFormat(
+                mActivity.getString(R.string.video_file_name_format));
+
+        return dateFormat.format(date);
+    }
+
+    private int getPreferredCameraId(ComboPreferences preferences) {
+        int intentCameraId = CameraUtil.getCameraFacingIntentExtras(mActivity);
+        if (intentCameraId != -1) {
+            // Testing purpose. Launch a specific camera through the intent
+            // extras.
+            return intentCameraId;
+        } else {
+            return CameraSettings.readPreferredCameraId(preferences);
+        }
+    }
+
+    private void initializeSurfaceView() {
+        if (!ApiHelper.HAS_SURFACE_TEXTURE_RECORDING) {  // API level < 16
+            mUI.initializeSurfaceView();
+        }
+    }
+
+    public void reinit() {
+        mPreferences = ComboPreferences.get(mActivity);
+        if (mPreferences == null) {
+            mPreferences = new ComboPreferences(mActivity);
+        }
+
+        CameraSettings.upgradeGlobalPreferences(mPreferences.getGlobal(), mActivity);
+        mCameraId = getPreferredCameraId(mPreferences);
+        mPreferences.setLocalId(mActivity, mCameraId);
+        CameraSettings.upgradeLocalPreferences(mPreferences.getLocal());
+    }
+
+    @Override
+    public void init(CameraActivity activity, View root) {
+        mActivity = activity;
+        mUI = new SVideoUI(activity, this, root);
+        mOrientationOffset = CameraUtil.isDefaultToPortrait(mActivity) ? 0 : 90;
+
+        mPreferences = ComboPreferences.get(mActivity);
+        if (mPreferences == null) {
+            mPreferences = new ComboPreferences(mActivity);
+        }
+
+        CameraSettings.upgradeGlobalPreferences(mPreferences.getGlobal(), activity);
+        mCameraId = getPreferredCameraId(mPreferences);
+
+        mPreferences.setLocalId(mActivity, mCameraId);
+        CameraSettings.upgradeLocalPreferences(mPreferences.getLocal());
+        // we need to reset exposure for the preview
+        resetExposureCompensation();
+
+        mOrientationManager = new OrientationManager(mActivity);
+
+        // Power shutter
+        mActivity.initPowerShutter(mPreferences);
+
+        // Max brightness
+        mActivity.initMaxBrightness(mPreferences);
+
+        /*
+         * To reduce startup time, we start the preview in another thread.
+         * We make sure the preview is started at the end of onCreate.
+         */
+        CameraOpenThread cameraOpenThread = new CameraOpenThread();
+        cameraOpenThread.start();
+
+        mContentResolver = mActivity.getContentResolver();
+
+        Storage.setSaveSDCard(
+            mPreferences.getString(CameraSettings.KEY_CAMERA_SAVEPATH, "0").equals("1"));
+        mSaveToSDCard = Storage.isSaveSDCard();
+        // Surface texture is from camera screen nail and startPreview needs it.
+        // This must be done before startPreview.
+        mIsVideoCaptureIntent = isVideoCaptureIntent();
+        initializeSurfaceView();
+
+        // Make sure camera device is opened.
+        try {
+            cameraOpenThread.join();
+            if (mCameraDevice == null) {
+                return;
+            }
+        } catch (InterruptedException ex) {
+            // ignore
+        }
+
+        readVideoPreferences();
+        mUI.setPrefChangedListener(this);
+
+        mQuickCapture = mActivity.getIntent().getBooleanExtra(EXTRA_QUICK_CAPTURE, false);
+        mLocationManager = new LocationManager(mActivity, this);
+
+        mUI.setOrientationIndicator(0, false);
+        setDisplayOrientation();
+
+        mUI.showTimeLapseUI(mCaptureTimeLapse);
+        initializeVideoSnapshot();
+        resizeForPreviewAspectRatio();
+
+        initializeVideoControl();
+        mPendingSwitchCameraId = -1;
+    }
+
+    @TargetApi(Build.VERSION_CODES.JELLY_BEAN)
+    private void setAutoExposureLockIfSupported() {
+        if (mAeLockSupported) {
+            mParameters.setAutoExposureLock(mFocusManager.getAeAwbLock());
+        }
+    }
+
+    @TargetApi(Build.VERSION_CODES.JELLY_BEAN)
+    private void setAutoWhiteBalanceLockIfSupported() {
+        if (mAwbLockSupported) {
+            mParameters.setAutoWhiteBalanceLock(mFocusManager.getAeAwbLock());
+        }
+    }
+
+    @Override
+    public void waitingLocationPermissionResult(boolean result) {
+        mLocationManager.waitingLocationPermissionResult(result);
+    }
+
+    @Override
+    public void enableRecordingLocation(boolean enable) {
+        String value = (enable ? RecordLocationPreference.VALUE_ON
+                        : RecordLocationPreference.VALUE_OFF);
+        if (mPreferences != null) {
+            mPreferences.edit()
+                .putString(CameraSettings.KEY_RECORD_LOCATION, value)
+                .apply();
+        }
+        mLocationManager.recordLocation(enable);
+     }
+
+    @Override
+    public void autoFocus() {
+        Log.e(TAG, "start autoFocus.");
+        mCameraDevice.autoFocus(mHandler, mAutoFocusCallback);
+    }
+
+    @Override
+    public void cancelAutoFocus() {
+        if (null != mCameraDevice) {
+            setFocusParameters();
+        }
+    }
+
+    @Override
+    public boolean capture() {
+       return true;
+    }
+
+    @Override
+    public void setFocusParameters() {
+        if (mFocusAreaSupported)
+            mParameters.setFocusAreas(mFocusManager.getFocusAreas());
+        if (mMeteringAreaSupported)
+            mParameters.setMeteringAreas(mFocusManager.getMeteringAreas());
+        setAutoExposureLockIfSupported();
+        setAutoWhiteBalanceLockIfSupported();
+        if (mFocusAreaSupported || mMeteringAreaSupported) {
+            mParameters.setFocusMode(mFocusManager.getFocusMode(true));
+            mCameraDevice.setParameters(mParameters);
+        }
+    }
+
+    @Override
+    public void setPreferenceForTest(String key, String value) {
+        mUI.setPreference(key, value);
+        onSharedPreferenceChanged();
+    }
+
+    // SingleTapListener
+    // Preview area is touched. Take a picture.
+    @Override
+    public void onSingleTapUp(View view, int x, int y) {
+        if (mMediaRecorderPausing) return;
+        boolean snapped = takeASnapshot();
+        if (!snapped) {
+            // Do not trigger touch focus if popup window is opened.
+            if (mUI.removeTopLevelPopup()) {
+                return;
+            }
+
+            // Check if metering area or focus area is supported.
+            if ((mFocusAreaSupported || mMeteringAreaSupported) && !mSnapshotInProgress) {
+                mFocusManager.onSingleTapUp(x, y);
+            }
+        }
+    }
+
+    private boolean takeASnapshot() {
+        // Only take snapshots if video snapshot is supported by device
+        if (CameraUtil.isVideoSnapshotSupported(mParameters) && !mIsVideoCaptureIntent) {
+            if (!mMediaRecorderRecording || mPaused || mSnapshotInProgress) {
+                return false;
+            }
+            MediaSaveService s = mActivity.getMediaSaveService();
+            if (s == null || s.isQueueFull()) {
+                return false;
+            }
+
+            // Set rotation and gps data.
+            int orientation = (mOrientation + mOrientationOffset) % 360;
+            int rotation = CameraUtil.getJpegRotation(mCameraId, orientation);
+            mParameters.setRotation(rotation);
+            Location loc = mLocationManager.getCurrentLocation();
+            CameraUtil.setGpsParameters(mParameters, loc);
+            mCameraDevice.setParameters(mParameters);
+
+            Log.v(TAG, "Video snapshot start");
+            mCameraDevice.takePicture(mHandler,
+                    null, null, null, new JpegPictureCallback(loc));
+            showVideoSnapshotUI(true);
+            mSnapshotInProgress = true;
+            UsageStatistics.onEvent(UsageStatistics.COMPONENT_CAMERA,
+                    UsageStatistics.ACTION_CAPTURE_DONE, "VideoSnapshot");
+
+            return true;
+        }
+        return false;
+    }
+
+    @Override
+    public void onStop() {}
+
+    @Override
+    public void onDestroy() {}
+
+    private void loadCameraPreferences() {
+        CameraSettings settings = new CameraSettings(mActivity, mParameters,
+                mCameraId, CameraHolder.instance().getCameraInfo());
+        // Remove the video quality preference setting when the quality is given in the intent.
+        mPreferenceGroup = filterPreferenceScreenByIntent(
+                settings.getPreferenceGroup(R.xml.video_preferences));
+
+        int numOfCams = Camera.getNumberOfCameras();
+
+        //TODO: If numOfCams > 2 then corresponding entries needs to be added to the media_profiles.xml
+
+        Log.e(TAG,"loadCameraPreferences() updating camera_id pref");
+
+        IconListPreference switchIconPref =
+                (IconListPreference)mPreferenceGroup.findPreference(
+                CameraSettings.KEY_CAMERA_ID);
+
+        //if numOfCams < 2 then switchIconPref will be null as there is no switch icon in this case
+        if (switchIconPref == null)
+            return;
+
+        int[] iconIds = new int[numOfCams];
+        String[] entries = new String[numOfCams];
+        String[] labels = new String[numOfCams];
+        int[] largeIconIds = new int[numOfCams];
+
+        for(int i=0;i<numOfCams;i++) {
+            CameraInfo info = CameraHolder.instance().getCameraInfo()[i];
+            if(info.facing == CameraInfo.CAMERA_FACING_BACK) {
+                iconIds[i] = R.drawable.ic_switch_back;
+                entries[i] = mActivity.getResources().getString(R.string.pref_camera_id_entry_back);
+                labels[i] = mActivity.getResources().getString(R.string.pref_camera_id_label_back);
+                largeIconIds[i] = R.drawable.ic_switch_back;
+            } else {
+                iconIds[i] = R.drawable.ic_switch_front;
+                entries[i] = mActivity.getResources().getString(R.string.pref_camera_id_entry_front);
+                labels[i] = mActivity.getResources().getString(R.string.pref_camera_id_label_front);
+                largeIconIds[i] = R.drawable.ic_switch_front;
+            }
+        }
+
+        switchIconPref.setIconIds(iconIds);
+        switchIconPref.setEntries(entries);
+        switchIconPref.setLabels(labels);
+        switchIconPref.setLargeIconIds(largeIconIds);
+
+    }
+
+    private void initializeVideoControl() {
+        loadCameraPreferences();
+        mUI.initializePopup(mPreferenceGroup);
+    }
+
+    @Override
+    public void onOrientationChanged(int orientation) {
+        // We keep the last known orientation. So if the user first orient
+        // the camera then point the camera to floor or sky, we still have
+        // the correct orientation.
+        if (orientation == OrientationEventListener.ORIENTATION_UNKNOWN) return;
+        orientation = (orientation - mOrientationOffset + 360) % 360;
+        int newOrientation = CameraUtil.roundOrientation(orientation, mOrientation);
+
+        if (mOrientation != newOrientation) {
+            mOrientation = newOrientation;
+            Log.v(TAG, "onOrientationChanged, update parameters");
+            if ((mCameraDevice != null) && (mParameters != null)
+                    && (true == mPreviewing) && !mMediaRecorderRecording){
+                setFlipValue();
+                updatePowerMode();
+                mCameraDevice.setParameters(mParameters);
+            }
+            mUI.tryToCloseSubList();
+            mUI.setOrientation(newOrientation, true);
+        }
+
+        // Show the toast after getting the first orientation changed.
+        if (mHandler.hasMessages(SHOW_TAP_TO_SNAPSHOT_TOAST)) {
+            mHandler.removeMessages(SHOW_TAP_TO_SNAPSHOT_TOAST);
+            showTapToSnapshotToast();
+        }
+    }
+
+    private void startPlayVideoActivity() {
+        Intent intent = new Intent(Intent.ACTION_VIEW);
+        intent.setFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION);
+        intent.setDataAndType(mCurrentVideoUri, convertOutputFormatToMimeType(mProfile.fileFormat));
+        try {
+            mActivity
+                    .startActivityForResult(intent, CameraActivity.REQ_CODE_DONT_SWITCH_TO_PREVIEW);
+        } catch (ActivityNotFoundException ex) {
+            Log.e(TAG, "Couldn't view video " + mCurrentVideoUri, ex);
+        }
+    }
+
+    @Override
+    @OnClickAttr
+    public void onReviewPlayClicked(View v) {
+        startPlayVideoActivity();
+    }
+
+    @Override
+    @OnClickAttr
+    public void onReviewDoneClicked(View v) {
+        mIsInReviewMode = false;
+        doReturnToCaller(true);
+    }
+
+    @Override
+    @OnClickAttr
+    public void onReviewCancelClicked(View v) {
+        // TODO: It should be better to not even insert the URI at all before we
+        // confirm done in review, which means we need to handle temporary video
+        // files in a quite different way than we currently had.
+        // Make sure we don't delete the Uri sent from the video capture intent.
+        if (mCurrentVideoUriFromMediaSaved) {
+            mContentResolver.delete(mCurrentVideoUri, null, null);
+        }
+        mIsInReviewMode = false;
+        doReturnToCaller(false);
+    }
+
+    @Override
+    public boolean isInReviewMode() {
+        return mIsInReviewMode;
+    }
+
+    private void onStopVideoRecording() {
+        boolean recordFail = stopVideoRecording();
+        if (mIsVideoCaptureIntent) {
+            if (mQuickCapture) {
+                doReturnToCaller(!recordFail);
+            } else if (!recordFail) {
+                showCaptureResult();
+            }
+        } else if (!recordFail){
+            // Start capture animation.
+            if (!mPaused && ApiHelper.HAS_SURFACE_TEXTURE_RECORDING) {
+                // The capture animation is disabled on ICS because we use SurfaceView
+                // for preview during recording. When the recording is done, we switch
+                // back to use SurfaceTexture for preview and we need to stop then start
+                // the preview. This will cause the preview flicker since the preview
+                // will not be continuous for a short period of time.
+
+                mUI.animateFlash();
+                mUI.animateCapture();
+            }
+        }
+        mUI.showUIafterRecording();
+    }
+
+    public void onVideoSaved() {
+        if (mIsVideoCaptureIntent) {
+            showCaptureResult();
+        }
+    }
+
+    public void onProtectiveCurtainClick(View v) {
+        // Consume clicks
+    }
+
+    public boolean isPreviewReady() {
+        if ((mStartPrevPending == true || mStopPrevPending == true))
+            return false;
+        else
+            return true;
+    }
+
+    public boolean isRecorderReady() {
+        if ((mStartRecPending == true || mStopRecPending == true))
+            return false;
+        else
+            return true;
+    }
+
+    @Override
+    public void onShutterButtonClick() {
+        if (mPaused || mUI.collapseCameraControls() ||
+                mSwitchingCamera) return;
+
+        boolean stop = mMediaRecorderRecording;
+
+        if (isPreviewReady() == false)
+            return;
+
+        if (isRecorderReady() == false)
+            return;
+
+        mUI.enableShutter(false);
+
+        if (stop) {
+            onStopVideoRecording();
+        } else {
+            if (!startVideoRecording()) {
+                // Show ui when start recording failed.
+                mUI.showUIafterRecording();
+            }
+        }
+
+        // Keep the shutter button disabled when in video capture intent
+        // mode and recording is stopped. It'll be re-enabled when
+        // re-take button is clicked.
+        if (!(mIsVideoCaptureIntent && stop)) {
+            mHandler.sendEmptyMessageDelayed(
+                    ENABLE_SHUTTER_BUTTON, SHUTTER_BUTTON_TIMEOUT);
+        }
+    }
+
+    @Override
+    public void onShutterButtonFocus(boolean pressed) {
+        mUI.setShutterPressed(pressed);
+    }
+
+    @Override
+    public void onShutterButtonLongClick() {}
+
+    private void qcomReadVideoPreferences() {
+        String videoEncoder = mPreferences.getString(
+               CameraSettings.KEY_VIDEO_ENCODER,
+               mActivity.getString(R.string.pref_camera_videoencoder_default));
+        mVideoEncoder = VIDEO_ENCODER_TABLE.get(videoEncoder);
+
+        Log.v(TAG, "Video Encoder selected = " +mVideoEncoder);
+
+        String audioEncoder = mPreferences.getString(
+               CameraSettings.KEY_AUDIO_ENCODER,
+               mActivity.getString(R.string.pref_camera_audioencoder_default));
+        mAudioEncoder = AUDIO_ENCODER_TABLE.get(audioEncoder);
+
+        Log.v(TAG, "Audio Encoder selected = " +mAudioEncoder);
+
+        if(ParametersWrapper.isPowerModeSupported(mParameters)) {
+            String powermode = mPreferences.getString(
+                    CameraSettings.KEY_POWER_MODE,
+                    mActivity.getString(R.string.pref_camera_powermode_default));
+            Log.v(TAG, "read videopreferences power mode =" +powermode);
+            String old_mode = ParametersWrapper.getPowerMode(mParameters);
+            if(!old_mode.equals(powermode) && mPreviewing)
+                mRestartPreview = true;
+
+            ParametersWrapper.setPowerMode(mParameters, powermode);
+        }
+   }
+
+    private final class AutoFocusCallback
+            implements CameraAFCallback {
+        @Override
+        public void onAutoFocus(
+                boolean focused, CameraProxy camera) {
+            Log.v(TAG, "AutoFocusCallback, mPaused=" + mPaused);
+            if (mPaused) return;
+
+            //setCameraState(IDLE);
+            mCameraDevice.refreshParameters();
+            mFocusManager.setParameters(mCameraDevice.getParameters());
+            mFocusManager.onAutoFocus(focused, false);
+        }
+    }
+
+    @Override
+    public void setFocusRatio(float ratio) {
+        mHandler.removeMessages(SET_FOCUS_RATIO);
+        Message m = mHandler.obtainMessage(SET_FOCUS_RATIO);
+        m.obj = ratio;
+        mHandler.sendMessage(m);
+    }
+
+    private void readVideoPreferences() {
+        // The preference stores values from ListPreference and is thus string type for all values.
+        // We need to convert it to int manually.
+        String videoQuality = mPreferences.getString(CameraSettings.KEY_VIDEO_QUALITY, null);
+        if (videoQuality == null || (videoQuality.length() < 3 && !videoQuality.contains("x"))) {
+            mParameters = mCameraDevice.getParameters();
+            String defaultQuality = mActivity.getResources().getString(
+                    R.string.pref_video_quality_default);
+            if (!defaultQuality.equals("") &&
+                    CameraUtil.isSupported(defaultQuality,
+                            CameraSettings.getSupportedVideoQualities(
+                                                    mCameraId, mParameters))){
+                videoQuality = defaultQuality;
+            } else {
+                // check for highest quality supported
+                videoQuality = CameraSettings.getSupportedHighestVideoQuality(
+                        mActivity, mCameraId, mParameters);
+            }
+            mPreferences.edit().putString(CameraSettings.KEY_VIDEO_QUALITY, videoQuality).apply();
+        }
+
+        int quality = CameraSettings.VIDEO_QUALITY_TABLE.get(videoQuality);
+
+        // Set video quality.
+        Intent intent = mActivity.getIntent();
+        if (intent.hasExtra(MediaStore.EXTRA_VIDEO_QUALITY)) {
+            int extraVideoQuality =
+                    intent.getIntExtra(MediaStore.EXTRA_VIDEO_QUALITY, 0);
+            if (extraVideoQuality > 0) {
+                quality = CamcorderProfile.QUALITY_HIGH;
+            } else {  // 0 is mms.
+                quality = CamcorderProfile.QUALITY_LOW;
+            }
+        }
+
+        // Read time lapse recording interval.
+        String frameIntervalStr = mPreferences.getString(
+                CameraSettings.KEY_VIDEO_TIME_LAPSE_FRAME_INTERVAL,
+                mActivity.getString(R.string.pref_video_time_lapse_frame_interval_default));
+        mTimeBetweenTimeLapseFrameCaptureMs = Integer.parseInt(frameIntervalStr);
+        mCaptureTimeLapse = (mTimeBetweenTimeLapseFrameCaptureMs != 0);
+
+        int hfrRate = 0;
+        String highFrameRate = mPreferences.getString(
+            CameraSettings.KEY_VIDEO_HIGH_FRAME_RATE,
+            mActivity. getString(R.string.pref_camera_hfr_default));
+        if (("hfr".equals(highFrameRate.substring(0,3))) ||
+                ("hsr".equals(highFrameRate.substring(0,3)))) {
+            String rate = highFrameRate.substring(3);
+            Log.i(TAG,"HFR :"  + highFrameRate + " : rate = " + rate);
+            try {
+                hfrRate = Integer.parseInt(rate);
+            } catch (NumberFormatException nfe) {
+                Log.e(TAG, "Invalid hfr rate " + rate);
+            }
+        }
+
+        int mappedQuality = quality;
+        if (mCaptureTimeLapse) {
+            mappedQuality = CameraSettings.getTimeLapseQualityFor(quality);
+        } else if (hfrRate > 0) {
+            mappedQuality = CameraSettings.getHighSpeedQualityFor(quality);
+            Log.i(TAG,"NOTE: HighSpeed quality (" + mappedQuality + ") for (" + quality + ")");
+        }
+
+        if (CamcorderProfile.hasProfile(mCameraId, mappedQuality)) {
+            quality = mappedQuality;
+        } else {
+            Log.e(TAG,"NOTE: Quality " + mappedQuality + " is not supported ! Will use " + quality);
+        }
+        mProfile = CamcorderProfile.get(mCameraId, quality);
+        getDesiredPreviewSize();
+        qcomReadVideoPreferences();
+
+        // Set video duration limit. The limit is read from the preference,
+        // unless it is specified in the intent.
+        if (intent.hasExtra(MediaStore.EXTRA_DURATION_LIMIT)) {
+            int seconds =
+                    intent.getIntExtra(MediaStore.EXTRA_DURATION_LIMIT, 0);
+            mMaxVideoDurationInMs = 1000 * seconds;
+        }
+        mPreferenceRead = true;
+    }
+
+    public boolean is4KEnabled() {
+       if (mProfile.quality == CamcorderProfile.QUALITY_2160P ||
+           mProfile.quality == CamcorderProfile.QUALITY_TIME_LAPSE_2160P ||
+           mProfile.quality == CamcorderProfileWrapper.QUALITY_4KDCI ) {
+           return true;
+       } else {
+           return false;
+       }
+    }
+
+    private boolean is1080pEnabled() {
+       if (mProfile.quality == CamcorderProfile.QUALITY_1080P) {
+           return true;
+       } else {
+           return false;
+       }
+    }
+
+    private boolean is720pEnabled() {
+       if (mProfile.quality == CamcorderProfile.QUALITY_720P) {
+           return true;
+       } else {
+           return false;
+       }
+    }
+
+    private boolean isSessionSupportedByEncoder(int w, int h, int fps) {
+        int expectedMBsPerSec = w * h * fps;
+
+        List<VideoEncoderCap> videoEncoders = EncoderCapabilities.getVideoEncoders();
+        for (VideoEncoderCap videoEncoder: videoEncoders) {
+            if (videoEncoder.mCodec == mVideoEncoder) {
+                int maxMBsPerSec = (videoEncoder.mMaxFrameWidth * videoEncoder.mMaxFrameHeight
+                        * videoEncoder.mMaxFrameRate);
+                if (expectedMBsPerSec > maxMBsPerSec) {
+                    Log.e(TAG,"Selected codec " + mVideoEncoder
+                            + " does not support width(" + w
+                            + ") X height ("+ h
+                            + "@ " + fps +" fps");
+                    Log.e(TAG, "Max capabilities: " +
+                            "MaxFrameWidth = " + videoEncoder.mMaxFrameWidth + " , " +
+                            "MaxFrameHeight = " + videoEncoder.mMaxFrameHeight + " , " +
+                            "MaxFrameRate = " + videoEncoder.mMaxFrameRate);
+                    return false;
+                } else {
+                    return true;
+                }
+            }
+        }
+        return false;
+    }
+
+    boolean isHFREnabled(int videoWidth, int videoHeight) {
+        if ((null == mPreferences) || (null == mParameters)) {
+            return false;
+        }
+
+        String HighFrameRate = mPreferences.getString(
+                CameraSettings.KEY_VIDEO_HIGH_FRAME_RATE,
+                mActivity. getString(R.string.pref_camera_hfr_default));
+
+        if(!("off".equals(HighFrameRate))) {
+            Size size = null;
+            try {
+                if (isSupported(HighFrameRate.substring(3),
+                        ParametersWrapper.getSupportedVideoHighFrameRateModes(mParameters))) {
+                    int index = ParametersWrapper.
+                            getSupportedVideoHighFrameRateModes(mParameters).indexOf(
+                            HighFrameRate.substring(3));
+                    size = ParametersWrapper.getSupportedHfrSizes(mParameters).get(index);
+                } else {
+                    return false;
+                }
+            } catch (NullPointerException e) {
+                return false;
+            } catch (IndexOutOfBoundsException e) {
+                return false;
+            }
+
+            if (size != null) {
+                if (videoWidth > size.width || videoHeight > size.height) {
+                    return false;
+                }
+            } else {
+                return false;
+            }
+
+            int hfrFps = Integer.parseInt(HighFrameRate.substring(3));
+            return isSessionSupportedByEncoder(videoWidth, videoHeight, hfrFps);
+        }
+
+        return false;
+    }
+
+    @TargetApi(Build.VERSION_CODES.HONEYCOMB)
+    private void getDesiredPreviewSize() {
+        if (mCameraDevice == null) {
+            return;
+        }
+        mParameters = mCameraDevice.getParameters();
+        if (mParameters.getSupportedVideoSizes() == null ||
+                isHFREnabled(mProfile.videoFrameWidth, mProfile.videoFrameHeight)) {
+            mDesiredPreviewWidth = mProfile.videoFrameWidth;
+            mDesiredPreviewHeight = mProfile.videoFrameHeight;
+        } else { // Driver supports separates outputs for preview and video.
+            List<Size> sizes = mParameters.getSupportedPreviewSizes();
+            Size preferred = mParameters.getPreferredPreviewSizeForVideo();
+            int product = preferred.width * preferred.height;
+            Iterator<Size> it = sizes.iterator();
+            // Remove the preview sizes that are not preferred.
+            while (it.hasNext()) {
+                Size size = it.next();
+                if (size.width * size.height > product) {
+                    it.remove();
+                }
+            }
+            Size optimalSize = CameraUtil.getOptimalPreviewSize(mActivity, sizes,
+                    (double) mProfile.videoFrameWidth / mProfile.videoFrameHeight);
+            mDesiredPreviewWidth = optimalSize.width;
+            mDesiredPreviewHeight = optimalSize.height;
+        }
+        mUI.setPreviewSize(mDesiredPreviewWidth, mDesiredPreviewHeight);
+        Log.v(TAG, "mDesiredPreviewWidth=" + mDesiredPreviewWidth +
+                ". mDesiredPreviewHeight=" + mDesiredPreviewHeight);
+    }
+
+    private void resetExposureCompensation() {
+        String value = mPreferences.getString(CameraSettings.KEY_EXPOSURE,
+                CameraSettings.EXPOSURE_DEFAULT_VALUE);
+        if (!CameraSettings.EXPOSURE_DEFAULT_VALUE.equals(value)) {
+            Editor editor = mPreferences.edit();
+            editor.putString(CameraSettings.KEY_EXPOSURE, "0");
+            editor.apply();
+        }
+    }
+
+    void setPreviewFrameLayoutCameraOrientation(){
+        CameraInfo info = CameraHolder.instance().getCameraInfo()[mCameraId];
+
+        //if camera mount angle is 0 or 180, we want to resize preview
+        if (info.orientation % 180 == 0)
+            mUI.cameraOrientationPreviewResize(true);
+        else
+            mUI.cameraOrientationPreviewResize(false);
+    }
+
+    @Override
+    public void resizeForPreviewAspectRatio() {
+        setPreviewFrameLayoutCameraOrientation();
+        mUI.setAspectRatio(
+                (double) mProfile.videoFrameWidth / mProfile.videoFrameHeight);
+    }
+
+    @Override
+    public void onSwitchSavePath() {
+        mUI.setPreference(CameraSettings.KEY_CAMERA_SAVEPATH, "1");
+        RotateTextToast.makeText(mActivity, R.string.on_switch_save_path_to_sdcard,
+                Toast.LENGTH_SHORT).show();
+    }
+
+    @Override
+    public void installIntentFilter() {
+        if(mReceiver != null)
+            return;
+        // install an intent filter to receive SD card related events.
+        IntentFilter intentFilter =
+                new IntentFilter(Intent.ACTION_MEDIA_EJECT);
+        intentFilter.addAction(Intent.ACTION_SCREEN_OFF);
+        intentFilter.addAction(Intent.ACTION_MEDIA_SCANNER_STARTED);
+        intentFilter.addDataScheme("file");
+        mReceiver = new MyBroadcastReceiver();
+        mActivity.registerReceiver(mReceiver, intentFilter);
+    }
+
+    @Override
+    public void onResumeBeforeSuper() {
+        mPaused = false;
+        if (mFocusManager == null) initializeFocusManager();
+    }
+
+    @Override
+    public void onResumeAfterSuper() {
+        mUI.enableShutter(false);
+        mZoomValue = 0;
+        mUI.showSurfaceView();
+        AudioManager am = (AudioManager)mActivity.getSystemService(Context.AUDIO_SERVICE);
+        mWasMute = am.isMicrophoneMute();
+        if(mWasMute != mIsMute) {
+            setMute(mIsMute, false);
+        }
+        resetExposureCompensation();
+        showVideoSnapshotUI(false);
+        installIntentFilter();
+
+        if (!mPreviewing) {
+            openCamera();
+            if (mCameraDevice == null) {
+                return;
+            }
+            readVideoPreferences();
+            resizeForPreviewAspectRatio();
+            startPreview();
+        } else {
+            // preview already started
+            mUI.enableShutter(true);
+        }
+
+        initializeVideoControl();
+        mUI.applySurfaceChange(SVideoUI.SURFACE_STATUS.SURFACE_VIEW);
+
+        mUI.initDisplayChangeListener();
+        // Initializing it here after the preview is started.
+        mUI.initializeZoom(mParameters);
+        mUI.setPreviewGesturesVideoUI();
+        mUI.setSwitcherIndex();
+        keepScreenOnAwhile();
+
+        mOrientationManager.resume();
+        // Initialize location service.
+        boolean recordLocation = RecordLocationPreference.get(mPreferences,
+                CameraSettings.KEY_RECORD_LOCATION);
+        mLocationManager.recordLocation(recordLocation);
+
+        if (mPreviewing) {
+            mOnResumeTime = SystemClock.uptimeMillis();
+            mHandler.sendEmptyMessageDelayed(CHECK_DISPLAY_ROTATION, 100);
+        }
+
+        UsageStatistics.onContentViewChanged(
+                UsageStatistics.COMPONENT_CAMERA, "SVideoModule");
+        mHandler.post(new Runnable(){
+            @Override
+            public void run(){
+                mActivity.updateStorageSpaceAndHint();
+            }
+        });
+    }
+
+    private void setDisplayOrientation() {
+        mDisplayRotation = CameraUtil.getDisplayRotation(mActivity);
+        mCameraDisplayOrientation = CameraUtil.getDisplayOrientation(mDisplayRotation, mCameraId);
+        if (mFocusManager != null) {
+            mFocusManager.setDisplayOrientation(mCameraDisplayOrientation);
+        }
+        mUI.setDisplayOrientation(mCameraDisplayOrientation);
+        // Change the camera display orientation
+        if (mCameraDevice != null) {
+            mCameraDevice.setDisplayOrientation(mCameraDisplayOrientation);
+        }
+    }
+
+    @Override
+    public void updateCameraOrientation() {
+        if (mMediaRecorderRecording) return;
+        if (mDisplayRotation != CameraUtil.getDisplayRotation(mActivity)) {
+            setDisplayOrientation();
+        }
+    }
+
+    @Override
+    public int onZoomChanged(int index) {
+        // Not useful to change zoom value when the activity is paused.
+        if (mPaused) return index;
+        mZoomValue = index;
+        if (mParameters == null || mCameraDevice == null) return index;
+        // Set zoom parameters asynchronously
+        mParameters.setZoom(mZoomValue);
+        mCameraDevice.setParameters(mParameters);
+        Parameters p = mCameraDevice.getParameters();
+        if (p != null) return p.getZoom();
+        return index;
+    }
+
+    private void startPreview() {
+        Log.v(TAG, "startPreview");
+        mStartPrevPending = true;
+
+        SurfaceHolder sh = null;
+        Log.v(TAG, "startPreview: SurfaceHolder (MDP path)");
+        sh = mUI.getSurfaceHolder();
+
+        if (!mPreferenceRead || mPaused == true || mCameraDevice == null) {
+            mStartPrevPending = false;
+            return;
+        }
+        mErrorCallback.setActivity(mActivity);
+        mCameraDevice.setErrorCallback(mErrorCallback);
+        if (mPreviewing == true) {
+            stopPreview();
+        }
+
+        setDisplayOrientation();
+        mCameraDevice.setDisplayOrientation(mCameraDisplayOrientation);
+        setCameraParameters(true);
+
+        try {
+            mCameraDevice.setPreviewDisplay(sh);
+            mCameraDevice.setOneShotPreviewCallback(mHandler,
+                new CameraManager.CameraPreviewDataCallback() {
+                    @Override
+                    public void onPreviewFrame(byte[] data, CameraProxy camera) {
+                        mUI.hidePreviewCover();
+                    }
+                });
+            mCameraDevice.startPreview();
+            mPreviewing = true;
+            onPreviewStarted();
+        } catch (Throwable ex) {
+            closeCamera();
+            throw new RuntimeException("startPreview failed", ex);
+        }
+        mStartPrevPending = false;
+
+        mFocusManager.onPreviewStarted();
+    }
+
+    private void onPreviewStarted() {
+        mUI.enableShutter(true);
+        startFaceDetection();
+    }
+
+    @Override
+    public void stopPreview() {
+        mStopPrevPending = true;
+
+        if (mFocusManager != null) mFocusManager.onPreviewStopped();
+
+        if (!mPreviewing) {
+            mStopPrevPending = false;
+            return;
+        }
+        mCameraDevice.stopPreview();
+        mPreviewing = false;
+        mStopPrevPending = false;
+        mUI.enableShutter(false);
+        stopFaceDetection();
+    }
+
+    private void closeCamera() {
+        Log.v(TAG, "closeCamera");
+        if (mCameraDevice == null) {
+            Log.d(TAG, "already stopped.");
+            return;
+        }
+        mCameraDevice.setZoomChangeListener(null);
+        mCameraDevice.setErrorCallback(null);
+        mCameraDevice.setFaceDetectionCallback(null, null);
+        if (mActivity.isForceReleaseCamera()) {
+            CameraHolder.instance().strongRelease();
+        } else {
+            CameraHolder.instance().release();
+        }
+        mCameraDevice = null;
+        mPreviewing = false;
+        mSnapshotInProgress = false;
+        mFocusManager.onCameraReleased();
+        mPreviewFocused = false;
+        mFaceDetectionStarted = false;
+    }
+
+    private void releasePreviewResources() {
+        if (!ApiHelper.HAS_SURFACE_TEXTURE_RECORDING) {
+            mUI.hideSurfaceView();
+        }
+    }
+
+    @Override
+    public void onPauseBeforeSuper() {
+        mPaused = true;
+
+        mUI.showPreviewCover();
+        mUI.hideSurfaceView();
+        if (mMediaRecorderRecording) {
+            // Camera will be released in onStopVideoRecording.
+            onStopVideoRecording();
+        } else {
+            closeCamera();
+            releaseMediaRecorder();
+        }
+
+        closeVideoFileDescriptor();
+
+
+        releasePreviewResources();
+
+        if (mReceiver != null) {
+            mActivity.unregisterReceiver(mReceiver);
+            mReceiver = null;
+        }
+        resetScreenOn();
+
+        if (mLocationManager != null) mLocationManager.recordLocation(false);
+        mOrientationManager.pause();
+
+        mHandler.removeMessages(CHECK_DISPLAY_ROTATION);
+        mHandler.removeMessages(SWITCH_CAMERA);
+        mHandler.removeMessages(SWITCH_CAMERA_START_ANIMATION);
+        mHandler.removeMessages(HANDLE_FLASH_TORCH_DELAY);
+        mPendingSwitchCameraId = -1;
+        mSwitchingCamera = false;
+        mPreferenceRead = false;
+
+        mUI.collapseCameraControls();
+        mUI.removeDisplayChangeListener();
+
+        if(mWasMute != mIsMute) {
+            setMute(mWasMute, false);
+        }
+        mUI.applySurfaceChange(SVideoUI.SURFACE_STATUS.HIDE);
+    }
+
+    @Override
+    public void onPauseAfterSuper() {
+        if (mFocusManager != null) mFocusManager.removeMessages();
+    }
+
+    /**
+     * The focus manager is the first UI related element to get initialized,
+     * and it requires the RenderOverlay, so initialize it here
+     */
+    private void initializeFocusManager() {
+        // Create FocusManager object. startPreview needs it.
+        // if mFocusManager not null, reuse it
+        // otherwise create a new instance
+        if (mFocusManager != null) {
+            mFocusManager.removeMessages();
+        } else {
+            CameraInfo info = CameraHolder.instance().getCameraInfo()[mCameraId];
+            boolean mirror = (info.facing == CameraInfo.CAMERA_FACING_FRONT);
+            String[] defaultFocusModes = mActivity.getResources().getStringArray(
+                    R.array.pref_video_focusmode_default_array);
+            mFocusManager = new FocusOverlayManager(mPreferences, defaultFocusModes,
+                    mParameters, this, mirror,
+                    mActivity.getMainLooper(), mUI.getFocusRing(), mActivity);
+        }
+    }
+
+    @Override
+    public void onUserInteraction() {
+        if (!mMediaRecorderRecording && !mActivity.isFinishing()) {
+            keepScreenOnAwhile();
+        }
+    }
+
+    @Override
+    public boolean onBackPressed() {
+        if (mPaused) return true;
+        if (mMediaRecorderRecording) {
+            onStopVideoRecording();
+            return true;
+        } else if (mUI.hideSwitcherPopup()) {
+            return true;
+        } else {
+            return mUI.onBackPressed();
+        }
+    }
+
+    @Override
+    public boolean onKeyDown(int keyCode, KeyEvent event) {
+        // Do not handle any key if the activity is paused.
+        if (mPaused) {
+            return true;
+        }
+
+        switch (keyCode) {
+            case KeyEvent.KEYCODE_VOLUME_UP:
+            case KeyEvent.KEYCODE_MEDIA_NEXT:
+                if (event.getRepeatCount() == 0 && !CameraActivity.mPowerShutter &&
+                        !CameraUtil.hasCameraKey()) {
+                    mUI.clickShutter();
+                } else {
+                    mUI.onScaleStepResize(true);
+                }
+                return true;
+            case KeyEvent.KEYCODE_VOLUME_DOWN:
+            case KeyEvent.KEYCODE_MEDIA_PREVIOUS:
+                if (event.getRepeatCount() == 0 && !CameraActivity.mPowerShutter &&
+                        !CameraUtil.hasCameraKey()) {
+                    mUI.clickShutter();
+                } else {
+                    mUI.onScaleStepResize(false);
+                }
+                return true;
+            case KeyEvent.KEYCODE_CAMERA:
+            case KeyEvent.KEYCODE_HEADSETHOOK:
+                if (event.getRepeatCount() == 0) {
+                    mUI.clickShutter();
+                }
+                return true;
+            case KeyEvent.KEYCODE_DPAD_CENTER:
+                if (event.getRepeatCount() == 0) {
+                    mUI.clickShutter();
+                }
+                return true;
+            case KeyEvent.KEYCODE_POWER:
+                if (event.getRepeatCount() == 0 && CameraActivity.mPowerShutter &&
+                        !CameraUtil.hasCameraKey()) {
+                    mUI.clickShutter();
+                }
+                return true;
+            case KeyEvent.KEYCODE_MENU:
+                if (mMediaRecorderRecording) {
+                    return true;
+                }
+                break;
+        }
+        return false;
+    }
+
+    @Override
+    public boolean onKeyUp(int keyCode, KeyEvent event) {
+        switch (keyCode) {
+            case KeyEvent.KEYCODE_VOLUME_UP:
+            case KeyEvent.KEYCODE_MEDIA_NEXT:
+                if (!CameraActivity.mPowerShutter && !CameraUtil.hasCameraKey()) {
+                    mUI.pressShutter(false);
+                }
+                return true;
+            case KeyEvent.KEYCODE_VOLUME_DOWN:
+            case KeyEvent.KEYCODE_MEDIA_PREVIOUS:
+                if (!CameraActivity.mPowerShutter && !CameraUtil.hasCameraKey()) {
+                    mUI.pressShutter(false);
+                }
+                return true;
+            case KeyEvent.KEYCODE_CAMERA:
+            case KeyEvent.KEYCODE_HEADSETHOOK:
+                mUI.pressShutter(false);
+                return true;
+            case KeyEvent.KEYCODE_POWER:
+                if (CameraActivity.mPowerShutter && !CameraUtil.hasCameraKey()) {
+                    mUI.pressShutter(false);
+                }
+                return true;
+        }
+        return false;
+    }
+
+    @Override
+    public boolean isVideoCaptureIntent() {
+        String action = mActivity.getIntent().getAction();
+        return (MediaStore.ACTION_VIDEO_CAPTURE.equals(action));
+    }
+
+    private void doReturnToCaller(boolean valid) {
+        Intent resultIntent = new Intent();
+        int resultCode;
+        if (valid) {
+            resultCode = Activity.RESULT_OK;
+            resultIntent.setData(mCurrentVideoUri);
+            resultIntent.setFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION);
+        } else {
+            resultCode = Activity.RESULT_CANCELED;
+        }
+        mActivity.setResultEx(resultCode, resultIntent);
+        mActivity.finish();
+    }
+
+    private void cleanupEmptyFile() {
+        if (mVideoFilename != null) {
+            File f = new File(mVideoFilename);
+            if (f.length() == 0 && f.delete()) {
+                Log.v(TAG, "Empty video file deleted: " + mVideoFilename);
+                mVideoFilename = null;
+            }
+        }
+    }
+
+    private void setupMediaRecorderPreviewDisplay() {
+        mFocusManager.resetTouchFocus();
+        // Nothing to do here if using SurfaceTexture.
+        if (!ApiHelper.HAS_SURFACE_TEXTURE_RECORDING) {
+            // We stop the preview here before unlocking the device because we
+            // need to change the SurfaceTexture to SurfaceView for preview.
+            stopPreview();
+            mCameraDevice.setPreviewDisplay(mUI.getSurfaceHolder());
+            // The orientation for SurfaceTexture is different from that for
+            // SurfaceView. For SurfaceTexture we don't need to consider the
+            // display rotation. Just consider the sensor's orientation and we
+            // will set the orientation correctly when showing the texture.
+            // Gallery will handle the orientation for the preview. For
+            // SurfaceView we will have to take everything into account so the
+            // display rotation is considered.
+            mCameraDevice.setDisplayOrientation(
+                    CameraUtil.getDisplayOrientation(mDisplayRotation, mCameraId));
+            mCameraDevice.startPreview();
+            mPreviewing = true;
+            mMediaRecorder.setPreviewDisplay(mUI.getSurfaceHolder().getSurface());
+        }
+    }
+    private int getHighSpeedVideoEncoderBitRate(CamcorderProfile profile, int targetRate) {
+        int bitRate;
+        String key = profile.videoFrameWidth+"x"+profile.videoFrameHeight+":"+targetRate;
+        String resolutionFpsEncoder = key + ":" + profile.videoCodec;
+        if (CameraSettings.VIDEO_ENCODER_BITRATE.containsKey(resolutionFpsEncoder)) {
+            bitRate = CameraSettings.VIDEO_ENCODER_BITRATE.get(resolutionFpsEncoder);
+        }else if (CameraSettings.VIDEO_ENCODER_BITRATE.containsKey(key)) {
+            bitRate = CameraSettings.VIDEO_ENCODER_BITRATE.get(key);
+        } else {
+            Log.i(TAG, "No pre-defined bitrate for "+key);
+            bitRate = profile.videoBitRate * (targetRate / profile.videoFrameRate);
+        }
+        return bitRate;
+    }
+
+    // Prepares media recorder.
+    private void initializeRecorder() {
+        Log.v(TAG, "initializeRecorder");
+        // If the mCameraDevice is null, then this activity is going to finish
+        if (mCameraDevice == null) return;
+
+        if (!ApiHelper.HAS_SURFACE_TEXTURE_RECORDING) {
+            // Set the SurfaceView to visible so the surface gets created.
+            // surfaceCreated() is called immediately when the visibility is
+            // changed to visible. Thus, mSurfaceViewReady should become true
+            // right after calling setVisibility().
+            mUI.showSurfaceView();
+        }
+
+        Intent intent = mActivity.getIntent();
+        Bundle myExtras = intent.getExtras();
+
+        videoWidth = mProfile.videoFrameWidth;
+        videoHeight = mProfile.videoFrameHeight;
+        mUnsupportedResolution = false;
+
+        //check if codec supports the resolution, otherwise throw toast
+        List<VideoEncoderCap> videoEncoders = EncoderCapabilities.getVideoEncoders();
+        for (VideoEncoderCap videoEncoder: videoEncoders) {
+            if (videoEncoder.mCodec == mVideoEncoder) {
+                if (videoWidth > videoEncoder.mMaxFrameWidth ||
+                        videoWidth < videoEncoder.mMinFrameWidth ||
+                        videoHeight > videoEncoder.mMaxFrameHeight ||
+                        videoHeight < videoEncoder.mMinFrameHeight) {
+                    Log.e(TAG, "Selected codec " + mVideoEncoder +
+                            " does not support "+ videoWidth + "x" + videoHeight
+                            + " resolution");
+                    Log.e(TAG, "Codec capabilities: " +
+                            "mMinFrameWidth = " + videoEncoder.mMinFrameWidth + " , " +
+                            "mMinFrameHeight = " + videoEncoder.mMinFrameHeight + " , " +
+                            "mMaxFrameWidth = " + videoEncoder.mMaxFrameWidth + " , " +
+                            "mMaxFrameHeight = " + videoEncoder.mMaxFrameHeight);
+                    mUnsupportedResolution = true;
+                    RotateTextToast.makeText(mActivity, R.string.error_app_unsupported,
+                            Toast.LENGTH_LONG).show();
+                    return;
+                }
+                break;
+            }
+        }
+
+        long requestedSizeLimit = 0;
+        closeVideoFileDescriptor();
+        mCurrentVideoUriFromMediaSaved = false;
+        if (mIsVideoCaptureIntent && myExtras != null) {
+            Uri saveUri = (Uri) myExtras.getParcelable(MediaStore.EXTRA_OUTPUT);
+            if (saveUri != null) {
+                try {
+                    mVideoFileDescriptor =
+                            mContentResolver.openFileDescriptor(saveUri, "rw");
+                    mCurrentVideoUri = saveUri;
+                } catch (java.io.FileNotFoundException ex) {
+                    // invalid uri
+                    Log.e(TAG, ex.toString());
+                }
+            }
+            requestedSizeLimit = myExtras.getLong(MediaStore.EXTRA_SIZE_LIMIT);
+        }
+        mMediaRecorder = new MediaRecorder();
+
+        // Unlock the camera object before passing it to media recorder.
+        mCameraDevice.unlock();
+        mMediaRecorder.setCamera(mCameraDevice.getCamera());
+
+        String hfr = ParametersWrapper.getVideoHighFrameRate(mParameters);
+        String hsr =  mParameters.get(CameraSettings.KEY_VIDEO_HSR);
+        Log.i(TAG,"NOTE: hfr = " + hfr + " : hsr = " + hsr);
+
+        int captureRate = 0;
+        boolean isHFR = (hfr != null && !hfr.equals("off"));
+        boolean isHSR = (hsr != null && !hsr.equals("off"));
+
+        try {
+            captureRate = isHFR ? Integer.parseInt(hfr) :
+                    isHSR ? Integer.parseInt(hsr) : 0;
+        } catch (NumberFormatException nfe) {
+            Log.e(TAG, "Invalid hfr(" + hfr + ") or hsr(" + hsr + ")");
+        }
+
+        mMediaRecorder.setVideoSource(MediaRecorder.VideoSource.CAMERA);
+
+        mProfile.videoCodec = mVideoEncoder;
+        mProfile.audioCodec = mAudioEncoder;
+        mProfile.duration = mMaxVideoDurationInMs;
+
+        if ((mProfile.audioCodec == MediaRecorder.AudioEncoder.AMR_NB) &&
+            !mCaptureTimeLapse && !isHFR) {
+            mProfile.fileFormat = MediaRecorder.OutputFormat.THREE_GPP;
+        }
+        // Set params individually for HFR case, as we do not want to encode audio
+        if ((isHFR || isHSR) && captureRate > 0) {
+            if (isHSR) {
+                Log.i(TAG, "Enabling audio for HSR");
+                mMediaRecorder.setAudioSource(MediaRecorder.AudioSource.CAMCORDER);
+            }
+            mMediaRecorder.setOutputFormat(mProfile.fileFormat);
+            mMediaRecorder.setVideoFrameRate(mProfile.videoFrameRate);
+            mMediaRecorder.setVideoEncodingBitRate(mProfile.videoBitRate *
+                                                ((isHSR ? captureRate : 30) / 30));
+            mMediaRecorder.setVideoEncoder(mProfile.videoCodec);
+            if (isHSR) {
+                Log.i(TAG, "Configuring audio for HSR");
+                mMediaRecorder.setAudioEncodingBitRate(mProfile.audioBitRate);
+                mMediaRecorder.setAudioChannels(mProfile.audioChannels);
+                mMediaRecorder.setAudioSamplingRate(mProfile.audioSampleRate);
+                mMediaRecorder.setAudioEncoder(mProfile.audioCodec);
+            }
+        } else {
+            if (!mCaptureTimeLapse) {
+                mMediaRecorder.setAudioSource(MediaRecorder.AudioSource.CAMCORDER);
+            }
+
+            mMediaRecorder.setProfile(mProfile);
+        }
+
+        mMediaRecorder.setVideoSize(mProfile.videoFrameWidth, mProfile.videoFrameHeight);
+        mMediaRecorder.setMaxDuration(mMaxVideoDurationInMs);
+        if (mCaptureTimeLapse) {
+            double fps = 1000 / (double) mTimeBetweenTimeLapseFrameCaptureMs;
+            setCaptureRate(mMediaRecorder, fps);
+        } else if (captureRate > 0) {
+            Log.i(TAG, "Setting capture-rate = " + captureRate);
+            mMediaRecorder.setCaptureRate(captureRate);
+
+            // for HSR, encoder's target-framerate = capture-rate
+            // for HFR, encoder's taget-framerate = 30fps (from profile)
+            int targetFrameRate = isHSR ? captureRate :
+                    isHFR ? 30 : mProfile.videoFrameRate;
+
+            Log.i(TAG, "Setting target fps = " + targetFrameRate);
+            mMediaRecorder.setVideoFrameRate(targetFrameRate);
+
+            // Profiles advertizes bitrate corresponding to published framerate.
+            // In case framerate is different, scale the bitrate
+            int scaledBitrate = getHighSpeedVideoEncoderBitRate(mProfile, targetFrameRate);
+            Log.i(TAG, "Scaled Video bitrate : " + scaledBitrate);
+            if (scaledBitrate > 0) {
+                mMediaRecorder.setVideoEncodingBitRate(scaledBitrate);
+            } else {
+                Log.e(TAG, "Cannot set Video bitrate because its negative");
+            }
+        }
+
+        setRecordLocation();
+
+        // Set output file.
+        // Try Uri in the intent first. If it doesn't exist, use our own
+        // instead.
+        if (mVideoFileDescriptor != null) {
+            mMediaRecorder.setOutputFile(mVideoFileDescriptor.getFileDescriptor());
+        } else {
+            generateVideoFilename(mProfile.fileFormat);
+            mMediaRecorder.setOutputFile(mVideoFilename);
+        }
+
+        // Set maximum file size.
+        long maxFileSize = mActivity.getStorageSpaceBytes() - Storage.LOW_STORAGE_THRESHOLD_BYTES;
+        if (requestedSizeLimit > 0 && requestedSizeLimit < maxFileSize) {
+            maxFileSize = requestedSizeLimit;
+        }
+
+        if (Storage.isSaveSDCard() && maxFileSize > SDCARD_SIZE_LIMIT) {
+            maxFileSize = SDCARD_SIZE_LIMIT;
+        }
+
+        try {
+            mMediaRecorder.setMaxFileSize(maxFileSize);
+        } catch (RuntimeException exception) {
+            // We are going to ignore failure of setMaxFileSize here, as
+            // a) The composer selected may simply not support it, or
+            // b) The underlying media framework may not handle 64-bit range
+            // on the size restriction.
+        }
+
+        // See android.hardware.Camera.Parameters.setRotation for
+        // documentation.
+        // Note that mOrientation here is the device orientation, which is the opposite of
+        // what activity.getWindowManager().getDefaultDisplay().getRotation() would return,
+        // which is the orientation the graphics need to rotate in order to render correctly.
+        int rotation = 0;
+        if (mOrientation != OrientationEventListener.ORIENTATION_UNKNOWN) {
+            CameraInfo info = CameraHolder.instance().getCameraInfo()[mCameraId];
+            if (info.facing == CameraInfo.CAMERA_FACING_FRONT) {
+                rotation = (info.orientation - mOrientation - mOrientationOffset + 360) % 360;
+            } else {  // back-facing camera
+                rotation = (info.orientation + mOrientation + mOrientationOffset) % 360;
+            }
+        }
+        mMediaRecorder.setOrientationHint(rotation);
+        setupMediaRecorderPreviewDisplay();
+
+        try {
+            mMediaRecorder.prepare();
+        } catch (IOException e) {
+            Log.e(TAG, "prepare failed for " + mVideoFilename, e);
+            releaseMediaRecorder();
+            throw new RuntimeException(e);
+        }
+
+        mMediaRecorder.setOnErrorListener(this);
+        mMediaRecorder.setOnInfoListener(this);
+    }
+
+    private static void setCaptureRate(MediaRecorder recorder, double fps) {
+        recorder.setCaptureRate(fps);
+    }
+
+    private void setRecordLocation() {
+        Location loc = mLocationManager.getCurrentLocation();
+        if (loc != null) {
+            mMediaRecorder.setLocation((float) loc.getLatitude(),
+                    (float) loc.getLongitude());
+        }
+    }
+
+    private void releaseMediaRecorder() {
+        Log.v(TAG, "Releasing media recorder.");
+        if (mMediaRecorder != null) {
+            cleanupEmptyFile();
+            mMediaRecorder.reset();
+            mMediaRecorder.release();
+            mMediaRecorder = null;
+        }
+        mVideoFilename = null;
+    }
+
+    private void generateVideoFilename(int outputFileFormat) {
+        long dateTaken = System.currentTimeMillis();
+        String title = createName(dateTaken);
+        // Used when emailing.
+        String filename = title + convertOutputFormatToFileExt(outputFileFormat);
+        String mime = convertOutputFormatToMimeType(outputFileFormat);
+        String path = null;
+        if (Storage.isSaveSDCard() && SDCard.instance().isWriteable()) {
+            path = SDCard.instance().getDirectory() + '/' + filename;
+        } else {
+            path = Storage.DIRECTORY + '/' + filename;
+        }
+        mCurrentVideoValues = new ContentValues(9);
+        mCurrentVideoValues.put(Video.Media.TITLE, title);
+        mCurrentVideoValues.put(Video.Media.DISPLAY_NAME, filename);
+        mCurrentVideoValues.put(Video.Media.DATE_TAKEN, dateTaken);
+        mCurrentVideoValues.put(MediaColumns.DATE_MODIFIED, dateTaken / 1000);
+        mCurrentVideoValues.put(Video.Media.MIME_TYPE, mime);
+        mCurrentVideoValues.put(Video.Media.DATA, path);
+        mCurrentVideoValues.put(Video.Media.RESOLUTION,
+                Integer.toString(mProfile.videoFrameWidth) + "x" +
+                Integer.toString(mProfile.videoFrameHeight));
+        Location loc = mLocationManager.getCurrentLocation();
+        if (loc != null) {
+            mCurrentVideoValues.put(Video.Media.LATITUDE, loc.getLatitude());
+            mCurrentVideoValues.put(Video.Media.LONGITUDE, loc.getLongitude());
+        }
+        mVideoFilename = path;
+        Log.v(TAG, "New video filename: " + mVideoFilename);
+    }
+
+    private void saveVideo() {
+        if (mVideoFileDescriptor == null) {
+            File origFile = new File(mCurrentVideoFilename);
+            if (!origFile.exists() || origFile.length() <= 0) {
+                Log.e(TAG, "Invalid file");
+                mCurrentVideoValues = null;
+                return;
+            }
+
+            long duration = 0L;
+            MediaMetadataRetriever retriever = new MediaMetadataRetriever();
+
+            try {
+                retriever.setDataSource(mCurrentVideoFilename);
+                duration = Long.valueOf(retriever.extractMetadata(
+                            MediaMetadataRetriever.METADATA_KEY_DURATION));
+            } catch (IllegalArgumentException e) {
+                Log.e(TAG, "cannot access the file");
+            }
+            retriever.release();
+
+            mActivity.getMediaSaveService().addVideo(mCurrentVideoFilename,
+                    duration, mCurrentVideoValues,
+                    mOnVideoSavedListener, mContentResolver);
+        }
+        mCurrentVideoValues = null;
+    }
+
+    private void deleteVideoFile(String fileName) {
+        Log.v(TAG, "Deleting video " + fileName);
+        File f = new File(fileName);
+        if (!f.delete()) {
+            Log.v(TAG, "Could not delete " + fileName);
+        }
+    }
+
+    private PreferenceGroup filterPreferenceScreenByIntent(
+            PreferenceGroup screen) {
+        Intent intent = mActivity.getIntent();
+        if (intent.hasExtra(MediaStore.EXTRA_VIDEO_QUALITY)) {
+            CameraSettings.removePreferenceFromScreen(screen,
+                    CameraSettings.KEY_VIDEO_QUALITY);
+        }
+
+        if (intent.hasExtra(MediaStore.EXTRA_DURATION_LIMIT)) {
+            CameraSettings.removePreferenceFromScreen(screen,
+                    CameraSettings.KEY_VIDEO_QUALITY);
+        }
+        return screen;
+    }
+
+    // from MediaRecorder.OnErrorListener
+    @Override
+    public void onError(MediaRecorder mr, int what, int extra) {
+        Log.e(TAG, "MediaRecorder error. what=" + what + ". extra=" + extra);
+        stopVideoRecording();
+        mUI.showUIafterRecording();
+        if (what == MediaRecorder.MEDIA_RECORDER_ERROR_UNKNOWN) {
+            // We may have run out of space on the sdcard.
+            mActivity.updateStorageSpaceAndHint();
+        }
+    }
+
+    // from MediaRecorder.OnInfoListener
+    @Override
+    public void onInfo(MediaRecorder mr, int what, int extra) {
+        if (what == MediaRecorder.MEDIA_RECORDER_INFO_MAX_DURATION_REACHED) {
+            if (mMediaRecorderRecording) onStopVideoRecording();
+        } else if (what == MediaRecorder.MEDIA_RECORDER_INFO_MAX_FILESIZE_REACHED) {
+            if (mMediaRecorderRecording) onStopVideoRecording();
+
+            // Show the toast.
+            RotateTextToast.makeText(mActivity, R.string.video_reach_size_limit,
+                    Toast.LENGTH_LONG).show();
+        }
+    }
+
+    /*
+     * Make sure we're not recording music playing in the background, ask the
+     * MediaPlaybackService to pause playback.
+     */
+    private void requestAudioFocus() {
+        AudioManager am = (AudioManager)mActivity.getSystemService(Context.AUDIO_SERVICE);
+
+        // Send request to obtain audio focus. This will stop other
+        // music stream.
+        int result = am.requestAudioFocus(null, AudioManager.STREAM_MUSIC,
+                                 AudioManager.AUDIOFOCUS_GAIN_TRANSIENT);
+
+        if (result == AudioManager.AUDIOFOCUS_REQUEST_FAILED) {
+            Log.v(TAG, "Audio focus request failed");
+        }
+    }
+
+    private void releaseAudioFocus() {
+        AudioManager am = (AudioManager)mActivity.getSystemService(Context.AUDIO_SERVICE);
+
+        int result = am.abandonAudioFocus(null);
+
+        if (result == AudioManager.AUDIOFOCUS_REQUEST_FAILED) {
+            Log.v(TAG, "Audio focus release failed");
+        }
+    }
+
+    // For testing.
+    public boolean isRecording() {
+        return mMediaRecorderRecording;
+    }
+
+    private boolean startVideoRecording() {
+        Log.v(TAG, "startVideoRecording");
+        mStartRecPending = true;
+        mUI.cancelAnimations();
+        mUI.setSwipingEnabled(false);
+        // When recording request is sent before starting preview, onPreviewFrame()
+        // callback doesn't happen so removing preview cover here, instead.
+        if (mUI.isPreviewCoverVisible()) {
+            mUI.hidePreviewCover();
+        }
+        mActivity.updateStorageSpaceAndHint();
+        if (mActivity.getStorageSpaceBytes() <= Storage.LOW_STORAGE_THRESHOLD_BYTES) {
+            Log.v(TAG, "Storage issue, ignore the start request");
+            mStartRecPending = false;
+            return false;
+        }
+
+        if( mUnsupportedHFRVideoSize == true) {
+            Log.e(TAG, "Unsupported HFR and video size combinations");
+            RotateTextToast.makeText(mActivity,R.string.error_app_unsupported_hfr,
+                    Toast.LENGTH_SHORT).show();
+            mStartRecPending = false;
+            return false;
+        }
+
+        if (mUnsupportedHSRVideoSize == true) {
+            Log.e(TAG, "Unsupported HSR and video size combinations");
+            RotateTextToast.makeText(mActivity,R.string.error_app_unsupported_hsr,
+                    Toast.LENGTH_SHORT).show();
+            mStartRecPending = false;
+            return false;
+        }
+
+        if( mUnsupportedHFRVideoCodec == true) {
+            Log.e(TAG, "Unsupported HFR and video codec combinations");
+            RotateTextToast.makeText(mActivity, R.string.error_app_unsupported_hfr_codec,
+                    Toast.LENGTH_SHORT).show();
+            mStartRecPending = false;
+            return false;
+        }
+        if (mUnsupportedProfile == true) {
+            Log.e(TAG, "Unsupported video profile");
+            RotateTextToast.makeText(mActivity, R.string.error_app_unsupported_profile,
+                    Toast.LENGTH_SHORT).show();
+            mStartRecPending = false;
+            return false;
+        }
+        //??
+        //if (!mCameraDevice.waitDone()) return;
+        mCurrentVideoUri = null;
+
+        initializeRecorder();
+        if (mUnsupportedResolution == true) {
+              Log.v(TAG, "Unsupported Resolution according to target");
+              mStartRecPending = false;
+              return false;
+        }
+        if (mMediaRecorder == null) {
+            Log.e(TAG, "Fail to initialize media recorder");
+            mStartRecPending = false;
+            return false;
+        }
+
+        requestAudioFocus();
+
+        try {
+            mMediaRecorder.start(); // Recording is now started
+        } catch (RuntimeException e) {
+            Toast.makeText(mActivity,"Could not start media recorder.\n Can't start video recording.", Toast.LENGTH_LONG).show();
+            releaseMediaRecorder();
+            releaseAudioFocus();
+            // If start fails, frameworks will not lock the camera for us.
+            mCameraDevice.lock();
+            mStartRecPending = false;
+            return false;
+        }
+
+        mUI.hideUIwhileRecording();
+
+        // Make sure the video recording has started before announcing
+        // this in accessibility.
+        AccessibilityUtils.makeAnnouncement(mUI.getShutterButton(),
+                mActivity.getString(R.string.video_recording_started));
+
+        // The parameters might have been altered by MediaRecorder already.
+        // We need to force mCameraDevice to refresh before getting it.
+        mCameraDevice.refreshParameters();
+        // The parameters may have been changed by MediaRecorder upon starting
+        // recording. We need to alter the parameters if we support camcorder
+        // zoom. To reduce latency when setting the parameters during zoom, we
+        // update mParameters here once.
+        mParameters = mCameraDevice.getParameters();
+
+        mUI.enableCameraControls(false);
+
+        mMediaRecorderRecording = true;
+        mMediaRecorderPausing = false;
+        mUI.resetPauseButton();
+        mRecordingTotalTime = 0L;
+        mRecordingStartTime = SystemClock.uptimeMillis();
+        mUI.showRecordingUI(true);
+
+        updateRecordingTime();
+        keepScreenOn();
+        UsageStatistics.onEvent(UsageStatistics.COMPONENT_CAMERA,
+                UsageStatistics.ACTION_CAPTURE_START, "Video");
+        mStartRecPending = false;
+        return true;
+    }
+
+    private Bitmap getVideoThumbnail() {
+        Bitmap bitmap = null;
+        if (mVideoFileDescriptor != null) {
+            bitmap = Thumbnail.createVideoThumbnailBitmap(mVideoFileDescriptor.getFileDescriptor(),
+                    mDesiredPreviewWidth);
+        } else if (mCurrentVideoUri != null) {
+            try {
+                mVideoFileDescriptor = mContentResolver.openFileDescriptor(mCurrentVideoUri, "r");
+                bitmap = Thumbnail.createVideoThumbnailBitmap(
+                        mVideoFileDescriptor.getFileDescriptor(), mDesiredPreviewWidth);
+            } catch (java.io.FileNotFoundException ex) {
+                // invalid uri
+                Log.e(TAG, ex.toString());
+            }
+        }
+
+        if (bitmap != null) {
+            // MetadataRetriever already rotates the thumbnail. We should rotate
+            // it to match the UI orientation (and mirror if it is front-facing camera).
+            CameraInfo[] info = CameraHolder.instance().getCameraInfo();
+            boolean mirror = (info[mCameraId].facing == CameraInfo.CAMERA_FACING_FRONT);
+            bitmap = CameraUtil.rotateAndMirror(bitmap, 0, mirror);
+        }
+        return bitmap;
+    }
+
+    private void showCaptureResult() {
+        mIsInReviewMode = true;
+        Bitmap bitmap = getVideoThumbnail();
+        if (bitmap != null) {
+            mUI.showReviewImage(bitmap);
+        }
+        mUI.showReviewControls();
+        mUI.enableCameraControls(false);
+        mUI.showTimeLapseUI(false);
+    }
+
+    private void pauseVideoRecording() {
+        Log.v(TAG, "pauseVideoRecording");
+        mMediaRecorderPausing = true;
+        mRecordingTotalTime += SystemClock.uptimeMillis() - mRecordingStartTime;
+        mMediaRecorder.pause();
+    }
+
+    private void resumeVideoRecording() {
+        Log.v(TAG, "resumeVideoRecording");
+        mMediaRecorderPausing = false;
+        mRecordingStartTime = SystemClock.uptimeMillis();
+        updateRecordingTime();
+        if (!ApiHelper.HAS_RESUME_SUPPORTED){
+            mMediaRecorder.start();
+        } else {
+            try {
+                Method resumeRec = Class.forName("android.media.MediaRecorder").getMethod("resume");
+                resumeRec.invoke(mMediaRecorder);
+            } catch (Exception e) {
+                Log.v(TAG, "resume method not implemented");
+            }
+        }
+    }
+
+    private boolean stopVideoRecording() {
+        Log.v(TAG, "stopVideoRecording");
+        mStopRecPending = true;
+        mUI.setSwipingEnabled(true);
+        if (!isVideoCaptureIntent()) {
+            mUI.showSwitcher();
+        }
+
+        boolean fail = false;
+        if (mMediaRecorderRecording) {
+            boolean shouldAddToMediaStoreNow = false;
+
+            try {
+                mMediaRecorder.setOnErrorListener(null);
+                mMediaRecorder.setOnInfoListener(null);
+                mMediaRecorder.stop();
+                shouldAddToMediaStoreNow = true;
+                mCurrentVideoFilename = mVideoFilename;
+                Log.v(TAG, "stopVideoRecording: Setting current video filename: "
+                        + mCurrentVideoFilename);
+                AccessibilityUtils.makeAnnouncement(mUI.getShutterButton(),
+                        mActivity.getString(R.string.video_recording_stopped));
+            } catch (RuntimeException e) {
+                Log.e(TAG, "stop fail",  e);
+                if (mVideoFilename != null) deleteVideoFile(mVideoFilename);
+                fail = true;
+            }
+            mMediaRecorderRecording = false;
+
+            //If recording stops while snapshot is in progress, we might not get jpeg callback
+            //because cameraservice will disable picture related messages. Hence reset the
+            //flag here so that we can take liveshots in the next recording session.
+            mSnapshotInProgress = false;
+            showVideoSnapshotUI(false);
+
+            // If the activity is paused, this means activity is interrupted
+            // during recording. Release the camera as soon as possible because
+            // face unlock or other applications may need to use the camera.
+            if (mPaused) {
+                closeCamera();
+            }
+
+            mUI.showRecordingUI(false);
+            if (!mIsVideoCaptureIntent) {
+                mUI.enableCameraControls(true);
+            }
+            // The orientation was fixed during video recording. Now make it
+            // reflect the device orientation as video recording is stopped.
+            mUI.setOrientationIndicator(0, true);
+            keepScreenOnAwhile();
+            if (shouldAddToMediaStoreNow && !fail) {
+                if (mVideoFileDescriptor == null) {
+                    saveVideo();
+                } else if (mIsVideoCaptureIntent) {
+                    // if no file save is needed, we can show the post capture UI now
+                    showCaptureResult();
+                }
+            }
+        }
+        // release media recorder
+        releaseMediaRecorder();
+        releaseAudioFocus();
+        if (!mPaused) {
+            mCameraDevice.lock();
+            if (!ApiHelper.HAS_SURFACE_TEXTURE_RECORDING) {
+                stopPreview();
+                mUI.hideSurfaceView();
+                // Switch back to use SurfaceTexture for preview.
+                startPreview();
+            } else {
+                if (is4KEnabled()) {
+                    int fps = CameraUtil.getMaxPreviewFps(mParameters);
+                    if (fps > 0) {
+                        mParameters.setPreviewFrameRate(fps);
+                    } else {
+                        mParameters.setPreviewFrameRate(30);
+                    }
+                    mCameraDevice.setParameters(mParameters);
+                }
+            }
+        }
+        // Update the parameters here because the parameters might have been altered
+        // by MediaRecorder.
+        if (!mPaused) mParameters = mCameraDevice.getParameters();
+        UsageStatistics.onEvent(UsageStatistics.COMPONENT_CAMERA,
+                fail ? UsageStatistics.ACTION_CAPTURE_FAIL :
+                        UsageStatistics.ACTION_CAPTURE_DONE, "Video",
+                mMediaRecorderPausing ? mRecordingTotalTime :
+                        SystemClock.uptimeMillis() - mRecordingStartTime + mRecordingTotalTime);
+        mStopRecPending = false;
+        return fail;
+    }
+
+    private void resetScreenOn() {
+        mHandler.removeMessages(CLEAR_SCREEN_DELAY);
+        mActivity.getWindow().clearFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON);
+    }
+
+    private void keepScreenOnAwhile() {
+        mHandler.removeMessages(CLEAR_SCREEN_DELAY);
+        mActivity.getWindow().addFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON);
+        mHandler.sendEmptyMessageDelayed(CLEAR_SCREEN_DELAY, SCREEN_DELAY);
+    }
+
+    private void keepScreenOn() {
+        mHandler.removeMessages(CLEAR_SCREEN_DELAY);
+        mActivity.getWindow().addFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON);
+    }
+
+    private static String millisecondToTimeString(long milliSeconds, boolean displayCentiSeconds) {
+        long seconds = milliSeconds / 1000; // round down to compute seconds
+        long minutes = seconds / 60;
+        long hours = minutes / 60;
+        long remainderMinutes = minutes - (hours * 60);
+        long remainderSeconds = seconds - (minutes * 60);
+
+        StringBuilder timeStringBuilder = new StringBuilder();
+
+        // Hours
+        if (hours > 0) {
+            if (hours < 10) {
+                timeStringBuilder.append('0');
+            }
+            timeStringBuilder.append(hours);
+
+            timeStringBuilder.append(':');
+        }
+
+        // Minutes
+        if (remainderMinutes < 10) {
+            timeStringBuilder.append('0');
+        }
+        timeStringBuilder.append(remainderMinutes);
+        timeStringBuilder.append(':');
+
+        // Seconds
+        if (remainderSeconds < 10) {
+            timeStringBuilder.append('0');
+        }
+        timeStringBuilder.append(remainderSeconds);
+
+        // Centi seconds
+        if (displayCentiSeconds) {
+            timeStringBuilder.append('.');
+            long remainderCentiSeconds = (milliSeconds - seconds * 1000) / 10;
+            if (remainderCentiSeconds < 10) {
+                timeStringBuilder.append('0');
+            }
+            timeStringBuilder.append(remainderCentiSeconds);
+        }
+
+        return timeStringBuilder.toString();
+    }
+
+    private long getTimeLapseVideoLength(long deltaMs) {
+        // For better approximation calculate fractional number of frames captured.
+        // This will update the video time at a higher resolution.
+        double numberOfFrames = (double) deltaMs / mTimeBetweenTimeLapseFrameCaptureMs;
+        return (long) (numberOfFrames / mProfile.videoFrameRate * 1000);
+    }
+
+    private void updateRecordingTime() {
+        if (!mMediaRecorderRecording) {
+            return;
+        }
+        if (mMediaRecorderPausing) {
+            return;
+        }
+
+        long now = SystemClock.uptimeMillis();
+        long delta = now - mRecordingStartTime + mRecordingTotalTime;
+
+        // Starting a minute before reaching the max duration
+        // limit, we'll countdown the remaining time instead.
+        boolean countdownRemainingTime = (mMaxVideoDurationInMs != 0
+                && delta >= mMaxVideoDurationInMs - 60000);
+
+        long deltaAdjusted = delta;
+        if (countdownRemainingTime) {
+            deltaAdjusted = Math.max(0, mMaxVideoDurationInMs - deltaAdjusted) + 999;
+        }
+        String text;
+
+        long targetNextUpdateDelay;
+        if (!mCaptureTimeLapse) {
+            text = millisecondToTimeString(deltaAdjusted, false);
+            targetNextUpdateDelay = 1000;
+        } else {
+            // The length of time lapse video is different from the length
+            // of the actual wall clock time elapsed. Display the video length
+            // only in format hh:mm:ss.dd, where dd are the centi seconds.
+            text = millisecondToTimeString(getTimeLapseVideoLength(delta), true);
+            targetNextUpdateDelay = mTimeBetweenTimeLapseFrameCaptureMs;
+        }
+
+        mUI.setRecordingTime(text);
+
+        if (mRecordingTimeCountsDown != countdownRemainingTime) {
+            // Avoid setting the color on every update, do it only
+            // when it needs changing.
+            mRecordingTimeCountsDown = countdownRemainingTime;
+
+            int color = mActivity.getResources().getColor(countdownRemainingTime
+                    ? R.color.recording_time_remaining_text
+                    : R.color.recording_time_elapsed_text);
+
+            mUI.setRecordingTimeTextColor(color);
+        }
+
+        long actualNextUpdateDelay = targetNextUpdateDelay - (delta % targetNextUpdateDelay);
+        mHandler.sendEmptyMessageDelayed(
+                UPDATE_RECORD_TIME, actualNextUpdateDelay);
+    }
+
+    private static boolean isSupported(String value, List<String> supported) {
+        return supported == null ? false : supported.indexOf(value) >= 0;
+    }
+
+    private void setFlipValue() {
+
+        // Read Flip mode from adb command
+        //value: 0(default) - FLIP_MODE_OFF
+        //value: 1 - FLIP_MODE_H
+        //value: 2 - FLIP_MODE_V
+        //value: 3 - FLIP_MODE_VH
+
+        PersistUtil myUtil     = new PersistUtil();
+        int preview_flip_value = myUtil.getPreviewFlip();
+        int video_flip_value   = myUtil.getVideoFlip();
+        int picture_flip_value = myUtil.getPictureFlip();
+
+        int rotation = CameraUtil.getJpegRotation(mCameraId, mOrientation);
+        mParameters.setRotation(rotation);
+        if (rotation == 90 || rotation == 270) {
+            // in case of 90 or 270 degree, V/H flip should reverse
+            if (preview_flip_value == 1) {
+                preview_flip_value = 2;
+            } else if (preview_flip_value == 2) {
+                preview_flip_value = 1;
+            }
+            if (video_flip_value == 1) {
+                video_flip_value = 2;
+            } else if (video_flip_value == 2) {
+                video_flip_value = 1;
+            }
+            if (picture_flip_value == 1) {
+                picture_flip_value = 2;
+            } else if (picture_flip_value == 2) {
+                picture_flip_value = 1;
+            }
+        }
+        String preview_flip = CameraUtil.getFilpModeString(preview_flip_value);
+        String video_flip = CameraUtil.getFilpModeString(video_flip_value);
+        String picture_flip = CameraUtil.getFilpModeString(picture_flip_value);
+
+        if(CameraUtil.isSupported(preview_flip, CameraSettings.getSupportedFlipMode(mParameters))){
+            mParameters.set(CameraSettings.KEY_QC_PREVIEW_FLIP, preview_flip);
+        }
+        if(CameraUtil.isSupported(video_flip, CameraSettings.getSupportedFlipMode(mParameters))){
+            mParameters.set(CameraSettings.KEY_QC_VIDEO_FLIP, video_flip);
+        }
+        if(CameraUtil.isSupported(picture_flip, CameraSettings.getSupportedFlipMode(mParameters))){
+            mParameters.set(CameraSettings.KEY_QC_SNAPSHOT_PICTURE_FLIP, picture_flip);
+        }
+
+        if ((preview_flip_value != 0) || (video_flip_value != 0) || (picture_flip_value != 0)) {
+            mIsFlipEnabled = true;
+        } else {
+            mIsFlipEnabled = false;
+        }
+    }
+    private void setZoomMenuValue() {
+        String zoomMenuValue = mPreferences.getString(CameraSettings.KEY_ZOOM,
+                                mActivity.getString(R.string.pref_camera_zoom_default));
+        if (!zoomMenuValue.equals("0")) {
+            int zoomValue = Integer.parseInt(zoomMenuValue);
+            if (mZoomIdxTbl[0] == -1) {
+                /* update the index table once */
+                Log.d(TAG, "Update the zoom index table.");
+                List<Integer> zoomRatios = mParameters.getZoomRatios();
+                int lastZoomIdx = 0;
+                for (int zoom = 1; zoom <= MAX_ZOOM; zoom++) {
+                    int zoomIdx = zoomRatios.indexOf(zoom*100);
+                    if (zoomIdx == -1) {
+                       Log.d(TAG, "Can't find matching zoom value "+zoom);
+                       int nextZoom = 0;
+                       while ((++lastZoomIdx < zoomRatios.size()) &&
+                              (nextZoom < (zoom*100))){
+                           nextZoom = zoomRatios.get(lastZoomIdx);
+                           zoomIdx = lastZoomIdx;
+                       }
+                       if (lastZoomIdx < zoomRatios.size()) {
+                           zoomIdx = lastZoomIdx - 1;
+                       } else {
+                           break;
+                       }
+                    }
+                    mZoomIdxTbl[zoom-1] = zoomIdx;
+                    lastZoomIdx = zoomIdx;
+                }
+            }
+
+            if ((zoomValue <= mZoomIdxTbl.length) &&
+                (mZoomIdxTbl[zoomValue-1] != -1)) {
+                int step = 1;
+                int cur_zoom = mParameters.getZoom();
+                Log.d(TAG, "zoom index = "+mZoomIdxTbl[zoomValue-1]+", cur index = "+cur_zoom);
+                if (cur_zoom > mZoomIdxTbl[zoomValue-1]) {
+                    step = -1;
+                }
+
+                /* move zoom slowly */
+                while (cur_zoom != mZoomIdxTbl[zoomValue-1]) {
+                    cur_zoom += step;
+                    mParameters.setZoom(cur_zoom);
+                    try {
+                        Thread.sleep(25);
+                    } catch(InterruptedException e) {
+                    }
+                }
+
+                mParameters.setZoom(mZoomIdxTbl[zoomValue-1]);
+            } else {
+                Log.e(TAG, "Zoom value "+zoomValue+" is not supported!");
+            }
+        }
+    }
+
+     private void qcomSetCameraParameters(){
+        // add QCOM Parameters here
+        // Set color effect parameter.
+        Log.i(TAG,"NOTE: qcomSetCameraParameters " + videoWidth + " x " + videoHeight);
+
+        setZoomMenuValue();
+        String colorEffect = mPreferences.getString(
+            CameraSettings.KEY_VIDEOCAMERA_COLOR_EFFECT,
+            mActivity.getString(R.string.pref_camera_coloreffect_default));
+        Log.v(TAG, "Color effect value =" + colorEffect);
+        if (isSupported(colorEffect, mParameters.getSupportedColorEffects())) {
+            mParameters.setColorEffect(colorEffect);
+        }
+
+        String disMode = mPreferences.getString(
+                CameraSettings.KEY_DIS,
+                mActivity.getString(R.string.pref_camera_dis_default));
+        Log.v(TAG, "DIS value =" + disMode);
+        mIsDISEnabled = disMode.equals("enable");
+
+        if (is4KEnabled()) {
+            if (isSupported(mActivity.getString(R.string.pref_camera_dis_value_disable),
+                    CameraSettings.getSupportedDISModes(mParameters))) {
+                mParameters.set(CameraSettings.KEY_QC_DIS_MODE,
+                        mActivity.getString(R.string.pref_camera_dis_value_disable));
+                mUI.overrideSettings(CameraSettings.KEY_DIS,
+                        mActivity.getString(R.string.pref_camera_dis_value_disable));
+                mIsDISEnabled = false;
+            } else {
+                Log.e(TAG, "Not supported IS mode = " +
+                        mActivity.getString(R.string.pref_camera_dis_value_disable));
+            }
+        } else {
+            if (isSupported(disMode,
+                    CameraSettings.getSupportedDISModes(mParameters))) {
+                mParameters.set(CameraSettings.KEY_QC_DIS_MODE, disMode);
+            } else {
+                Log.e(TAG, "Not supported IS mode = " + disMode);
+            }
+        }
+
+        // Set anti banding parameter.
+        String antiBanding = mPreferences.getString(
+                 CameraSettings.KEY_ANTIBANDING,
+                 mActivity.getString(R.string.pref_camera_antibanding_default));
+        Log.v(TAG, "antiBanding value =" + antiBanding);
+        if (CameraUtil.isSupported(antiBanding, mParameters.getSupportedAntibanding())) {
+            mParameters.setAntibanding(antiBanding);
+        }
+
+        mUnsupportedHFRVideoSize = false;
+        mUnsupportedHFRVideoCodec = false;
+        mUnsupportedHSRVideoSize = false;
+        // To set preview format as YV12 , run command
+        // "adb shell setprop "debug.camera.yv12 true
+        if( PersistUtil.isYv12FormatEnable() ) {
+            Log.v(TAG, "preview format set to YV12");
+            mParameters.setPreviewFormat (ImageFormat.YV12);
+        }
+
+        mParameters.set(KEY_PREVIEW_FORMAT, FORMAT_NV21);
+        Log.v(TAG, "preview format set to NV21");
+
+        // Set High Frame Rate.
+        String highFrameRate = mPreferences.getString(
+            CameraSettings.KEY_VIDEO_HIGH_FRAME_RATE,
+            mActivity. getString(R.string.pref_camera_hfr_default));
+        boolean isHFR = "hfr".equals(highFrameRate.substring(0,3));
+        boolean isHSR = "hsr".equals(highFrameRate.substring(0,3));
+
+        if (isHFR || isHSR) {
+            String hfrRate = highFrameRate.substring(3);
+            if (isHFR) {
+                mUnsupportedHFRVideoSize = true;
+            } else {
+                mUnsupportedHSRVideoSize = true;
+            }
+            String hfrsize = videoWidth+"x"+videoHeight;
+            Log.v(TAG, "current set resolution is : "+hfrsize+ " : Rate is : " + hfrRate );
+            try {
+                Size size = null;
+                if (isSupported(hfrRate,
+                        ParametersWrapper.getSupportedVideoHighFrameRateModes(mParameters))) {
+                    int index = ParametersWrapper.
+                            getSupportedVideoHighFrameRateModes(mParameters).indexOf(hfrRate);
+                    size = ParametersWrapper.getSupportedHfrSizes(mParameters).get(index);
+                }
+                if (size != null) {
+                    if (videoWidth <= size.width && videoHeight <= size.height) {
+                        if (isHFR) {
+                            mUnsupportedHFRVideoSize = false;
+                        } else {
+                            mUnsupportedHSRVideoSize = false;
+                        }
+                        Log.v(TAG,"Current hfr resolution is supported");
+                    }
+                }
+            } catch (NullPointerException e){
+                Log.e(TAG, "supported hfr sizes is null");
+            }
+
+            int hfrFps = Integer.parseInt(hfrRate);
+            if (!isSessionSupportedByEncoder(videoWidth, videoHeight, hfrFps)) {
+                if (isHFR) {
+                            mUnsupportedHFRVideoSize = true;
+                        } else {
+                            mUnsupportedHSRVideoSize = true;
+                        }
+                    }
+
+            if (isHFR) {
+                mParameters.set(CameraSettings.KEY_VIDEO_HSR, "off");
+                if (mUnsupportedHFRVideoSize) {
+                    ParametersWrapper.setVideoHighFrameRate(mParameters, "off");
+                    Log.v(TAG,"Unsupported hfr resolution");
+                } else {
+                    ParametersWrapper.setVideoHighFrameRate(mParameters, hfrRate);
+                }
+            } else {
+                ParametersWrapper.setVideoHighFrameRate(mParameters, "off");
+                if (mUnsupportedHSRVideoSize) {
+                    Log.v(TAG,"Unsupported hsr resolution");
+                    mParameters.set(CameraSettings.KEY_VIDEO_HSR, "off");
+                } else {
+                    mParameters.set(CameraSettings.KEY_VIDEO_HSR, hfrRate);
+                }
+            }
+        } else {
+            ParametersWrapper.setVideoHighFrameRate(mParameters, "off");
+            mParameters.set(CameraSettings.KEY_VIDEO_HSR, "off");
+        }
+        setFlipValue();
+
+        // Set Video HDR.
+        String videoHDR = mPreferences.getString(
+                CameraSettings.KEY_VIDEO_HDR,
+                mActivity.getString(R.string.pref_camera_video_hdr_default));
+        Log.v(TAG, "Video HDR Setting =" + videoHDR);
+        if (isSupported(videoHDR,
+                ParametersWrapper.getSupportedVideoHDRModes(mParameters))) {
+            ParametersWrapper.setVideoHDRMode(mParameters, videoHDR);
+        } else
+            ParametersWrapper.setVideoHDRMode(mParameters, "off");
+
+        //HFR/HSR recording not supported with DIS,TimeLapse,HDR option
+        String hfr = ParametersWrapper.getVideoHighFrameRate(mParameters);
+        String hsr = mParameters.get(CameraSettings.KEY_VIDEO_HSR);
+        String hdr = ParametersWrapper.getVideoHDRMode(mParameters);
+         if ( !"off".equals(highFrameRate) ) {
+             // Read time lapse recording interval.
+             String frameIntervalStr = mPreferences.getString(
+                    CameraSettings.KEY_VIDEO_TIME_LAPSE_FRAME_INTERVAL,
+                    mActivity.getString(R.string.pref_video_time_lapse_frame_interval_default));
+             int timeLapseInterval = Integer.parseInt(frameIntervalStr);
+             int rate = 0;
+             if ( isDigit(highFrameRate.substring(3)) ) {
+                 rate = Integer.parseInt(highFrameRate.substring(3));
+             }
+             Log.v(TAG, "rate = "+rate);
+             if ( (timeLapseInterval != 0) ||
+                  (disMode.equals("enable")) ||
+                  ((hdr != null) && (!hdr.equals("off"))) ) {
+                Log.v(TAG,"HDR/DIS/Time Lapse ON for HFR/HSR selection, turning HFR/HSR off");
+                ParametersWrapper.setVideoHighFrameRate(mParameters, "off");
+                mParameters.set(CameraSettings.KEY_VIDEO_HSR, "off");
+                mUI.overrideSettings(CameraSettings.KEY_VIDEO_HIGH_FRAME_RATE, "off");
+             }
+        }
+
+        //getSupportedPictureSizes will always send a sorted a list in descending order
+        Size biggestSize = mParameters.getSupportedPictureSizes().get(0);
+
+        if (biggestSize.width <= videoWidth || biggestSize.height <= videoHeight) {
+            if (disMode.equals("enable")) {
+                Log.v(TAG,"DIS is not supported for this video quality");
+                RotateTextToast.makeText(mActivity, R.string.error_app_unsupported_dis,
+                               Toast.LENGTH_LONG).show();
+                mParameters.set(CameraSettings.KEY_QC_DIS_MODE, "disable");
+                mUI.overrideSettings(CameraSettings.KEY_DIS,"disable");
+                mIsDISEnabled = false;
+            }
+        }
+        //setting video rotation
+        String videoRotation = mPreferences.getString(
+            CameraSettings.KEY_VIDEO_ROTATION,
+            mActivity.getString(R.string.pref_camera_video_rotation_default));
+        if (isSupported(videoRotation,
+                ParametersWrapper.getSupportedVideoRotationValues(mParameters))) {
+            ParametersWrapper.setVideoRotation(mParameters, videoRotation);
+        }
+
+        //set power mode settings
+        updatePowerMode();
+
+        // Set focus mode
+        mParameters.setFocusMode(mFocusManager.getFocusMode(true));
+
+        // Set focus time.
+        mFocusManager.setFocusTime(Integer.decode(
+                mPreferences.getString(CameraSettings.KEY_VIDEOCAMERA_FOCUS_TIME,
+                mActivity.getString(R.string.pref_camera_video_focustime_default))));
+
+        // Set face detetction parameter.
+        String faceDetection = mPreferences.getString(
+            CameraSettings.KEY_FACE_DETECTION,
+            mActivity.getString(R.string.pref_camera_facedetection_default));
+
+        if (CameraUtil.isSupported(faceDetection,
+                ParametersWrapper.getSupportedFaceDetectionModes(mParameters))) {
+            Log.d(TAG, "setFaceDetectionMode "+faceDetection);
+            ParametersWrapper.setFaceDetectionMode(mParameters, faceDetection);
+            if(faceDetection.equals("on") && mFaceDetectionEnabled == false) {
+                mFaceDetectionEnabled = true;
+                startFaceDetection();
+            } else if(faceDetection.equals("off") && mFaceDetectionEnabled == true) {
+                stopFaceDetection();
+                mFaceDetectionEnabled = false;
+            }
+        }
+    }
+
+    private boolean isDigit(String input) {
+        String ruler = "[1-9][0-9]*";
+        Pattern pattern = Pattern.compile(ruler);
+        return pattern.matcher(input).matches();
+    }
+
+    @SuppressWarnings("deprecation")
+    private void setCameraParameters(boolean isFlashDelay) {
+        Log.d(TAG,"Preview dimension in App->"+mDesiredPreviewWidth+"X"+mDesiredPreviewHeight);
+        mParameters.setPreviewSize(mDesiredPreviewWidth, mDesiredPreviewHeight);
+        mParameters.set("video-size", mProfile.videoFrameWidth+"x"+mProfile.videoFrameHeight);
+        int[] fpsRange = CameraUtil.getMaxPreviewFpsRange(mParameters);
+        if (fpsRange.length > 0) {
+            mParameters.setPreviewFpsRange(
+                    fpsRange[Parameters.PREVIEW_FPS_MIN_INDEX],
+                    fpsRange[Parameters.PREVIEW_FPS_MAX_INDEX]);
+        } else {
+            mParameters.setPreviewFrameRate(mProfile.videoFrameRate);
+        }
+
+        if (isFlashDelay) {
+            mHandler.sendEmptyMessageDelayed(HANDLE_FLASH_TORCH_DELAY, 800);
+        } else {
+            forceFlashOffIfSupported(!mPreviewFocused);
+        }
+        videoWidth = mProfile.videoFrameWidth;
+        videoHeight = mProfile.videoFrameHeight;
+
+        Log.i(TAG,"NOTE: SetCameraParameters " + videoWidth + " x " + videoHeight);
+        String recordSize = videoWidth + "x" + videoHeight;
+        Log.e(TAG,"Video dimension in App->"+recordSize);
+        if (CameraUtil.isSupported(mParameters, "video-size")) {
+            mParameters.set("video-size", recordSize);
+        }
+        // Set exposure compensation
+        int value = CameraSettings.readExposure(mPreferences);
+        int max = mParameters.getMaxExposureCompensation();
+        int min = mParameters.getMinExposureCompensation();
+        if (value >= min && value <= max) {
+            mParameters.setExposureCompensation(value);
+        } else {
+            Log.w(TAG, "invalid exposure range: " + value);
+        }
+        // Set white balance parameter.
+        String whiteBalance = mPreferences.getString(
+                CameraSettings.KEY_WHITE_BALANCE,
+                mActivity.getString(R.string.pref_camera_whitebalance_default));
+        if (isSupported(whiteBalance,
+                mParameters.getSupportedWhiteBalance())) {
+            mParameters.setWhiteBalance(whiteBalance);
+        } else {
+            whiteBalance = mParameters.getWhiteBalance();
+            if (whiteBalance == null) {
+                whiteBalance = Parameters.WHITE_BALANCE_AUTO;
+            }
+        }
+
+        // Set zoom.
+        if (mParameters.isZoomSupported()) {
+            Parameters p = mCameraDevice.getParameters();
+            mZoomValue = p.getZoom();
+            mParameters.setZoom(mZoomValue);
+        }
+
+        // Set continuous autofocus.
+        // Set focus mode
+        mParameters.setFocusMode(mFocusManager.getFocusMode(true));
+
+        mParameters.set(CameraUtil.RECORDING_HINT, CameraUtil.TRUE);
+
+        // Enable video stabilization. Convenience methods not available in API
+        // level <= 14
+        String vstabSupported = mParameters.get("video-stabilization-supported");
+        if ("true".equals(vstabSupported)) {
+            mParameters.set("video-stabilization", "true");
+        }
+
+        // Set picture size.
+        // The logic here is different from the logic in still-mode camera.
+        // There we determine the preview size based on the picture size, but
+        // here we determine the picture size based on the preview size.
+        String videoSnapshotSize = mPreferences.getString(
+                CameraSettings.KEY_VIDEO_SNAPSHOT_SIZE,
+                mActivity.getString(R.string.pref_camera_videosnapsize_default));
+        Size optimalSize;
+        if(videoSnapshotSize.equals("auto")) {
+            List<Size> supported = mParameters.getSupportedPictureSizes();
+            optimalSize = CameraUtil.getOptimalVideoSnapshotPictureSize(supported,
+                    (double) mDesiredPreviewWidth / mDesiredPreviewHeight);
+            Size original = mParameters.getPictureSize();
+            if (!original.equals(optimalSize)) {
+                mParameters.setPictureSize(optimalSize.width, optimalSize.height);
+            }
+        } else {
+            CameraSettings.setCameraPictureSize(
+                videoSnapshotSize,
+                mParameters.getSupportedPictureSizes(),
+                mParameters);
+            optimalSize = mParameters.getPictureSize();
+        }
+
+        Log.v(TAG, "Video snapshot size is " + optimalSize.width + "x" +
+                optimalSize.height);
+
+        // Set jpegthumbnail size
+        // Set a jpegthumbnail size that is closest to the Picture height and has
+        // the right aspect ratio.
+        Size size = mParameters.getPictureSize();
+        List<Size> sizes = mParameters.getSupportedJpegThumbnailSizes();
+        optimalSize = CameraUtil.getOptimalJpegThumbnailSize(sizes,
+                (double) size.width / size.height);
+        Size original = mParameters.getJpegThumbnailSize();
+        if (!original.equals(optimalSize)) {
+            mParameters.setJpegThumbnailSize(optimalSize.width, optimalSize.height);
+        }
+        Log.v(TAG, "Thumbnail size is " + optimalSize.width + "x" + optimalSize.height);
+
+        // Set JPEG quality.
+        int jpegQuality = CameraProfile.getJpegEncodingQualityParameter(mCameraId,
+                CameraProfile.QUALITY_HIGH);
+        mParameters.setJpegQuality(jpegQuality);
+
+        CameraUtil.dumpParameters(mParameters);
+
+        //Call Qcom related Camera Parameters
+        qcomSetCameraParameters();
+
+        boolean flag = false;
+        if (mPreviewing) {
+            stopPreview();
+            flag = true;
+        }
+        mCameraDevice.setParameters(mParameters);
+        if (flag) {
+            startPreview();
+        }
+        // Keep preview size up to date.
+        mParameters = mCameraDevice.getParameters();
+
+        mFocusManager.setPreviewSize(videoWidth, videoHeight);
+    }
+
+    @Override
+    public void onActivityResult(int requestCode, int resultCode, Intent data) {
+        // Do nothing.
+    }
+
+    @Override
+    public void onConfigurationChanged(Configuration newConfig) {
+        Log.v(TAG, "onConfigurationChanged");
+        setDisplayOrientation();
+        resizeForPreviewAspectRatio();
+    }
+
+    @Override
+    public void onOverriddenPreferencesClicked() {
+    }
+
+    @Override
+    // TODO: Delete this after old camera code is removed
+    public void onRestorePreferencesClicked() {
+    }
+
+    @Override
+    public void onSharedPreferenceChanged(ListPreference pref) {
+        if (pref != null && CameraSettings.KEY_VIDEO_QUALITY.equals(pref.getKey())) {
+            String videoQuality = pref.getValue();
+            if (CameraSettings.VIDEO_QUALITY_TABLE.containsKey(videoQuality)) {
+                int quality = CameraSettings.VIDEO_QUALITY_TABLE.get(videoQuality);
+                if ((quality == CamcorderProfile.QUALITY_2160P
+                        || quality == CamcorderProfileWrapper.QUALITY_4KDCI)
+                        && mPreferences != null) {
+                    String disDisable = mActivity.getString(R.string.pref_camera_dis_value_disable);
+                    if (!disDisable.equals(
+                            mPreferences.getString(CameraSettings.KEY_DIS, disDisable))) {
+                        RotateTextToast.makeText(mActivity, R.string.video_quality_4k_disable_IS,
+                                Toast.LENGTH_LONG).show();
+                    }
+                }
+            }
+        }
+        onSharedPreferenceChanged();
+    }
+
+    @Override
+    public void onSharedPreferenceChanged() {
+        // ignore the events after "onPause()" or preview has not started yet
+        if (mPaused) {
+            return;
+        }
+        synchronized (mPreferences) {
+            // If mCameraDevice is not ready then we can set the parameter in
+            // startPreview().
+            if (mCameraDevice == null) return;
+
+            boolean recordLocation = RecordLocationPreference.get(mPreferences,
+                    CameraSettings.KEY_RECORD_LOCATION);
+            mLocationManager.recordLocation(recordLocation);
+
+            readVideoPreferences();
+            mUI.showTimeLapseUI(mCaptureTimeLapse);
+            // We need to restart the preview if preview size is changed.
+            Size size = mParameters.getPreviewSize();
+            if (size.width != mDesiredPreviewWidth
+                    || size.height != mDesiredPreviewHeight || mRestartPreview) {
+
+                stopPreview();
+                resizeForPreviewAspectRatio();
+                startPreview(); // Parameters will be set in startPreview().
+            } else {
+                setCameraParameters(false);
+            }
+            mRestartPreview = false;
+            Storage.setSaveSDCard(
+                mPreferences.getString(CameraSettings.KEY_CAMERA_SAVEPATH, "0").equals("1"));
+            mActivity.updateStorageSpaceAndHint();
+            mActivity.initPowerShutter(mPreferences);
+            mActivity.initMaxBrightness(mPreferences);
+        }
+    }
+
+    protected void setCameraId(int cameraId) {
+        ListPreference pref = mPreferenceGroup.findPreference(CameraSettings.KEY_CAMERA_ID);
+        pref.setValue("" + cameraId);
+    }
+
+    private void switchCamera() {
+        if (mPaused)  {
+            return;
+        }
+
+        Log.d(TAG, "Start to switch camera.");
+        mUI.applySurfaceChange(SVideoUI.SURFACE_STATUS.HIDE);
+        mCameraId = mPendingSwitchCameraId;
+        mPendingSwitchCameraId = -1;
+        setCameraId(mCameraId);
+
+        closeCamera();
+        mUI.collapseCameraControls();
+        if (mFocusManager != null) mFocusManager.removeMessages();
+        // Restart the camera and initialize the UI. From onCreate.
+        mPreferences.setLocalId(mActivity, mCameraId);
+        CameraSettings.upgradeLocalPreferences(mPreferences.getLocal());
+        openCamera();
+
+        CameraInfo info = CameraHolder.instance().getCameraInfo()[mCameraId];
+        boolean mirror = (info.facing == CameraInfo.CAMERA_FACING_FRONT);
+        mParameters = mCameraDevice.getParameters();
+        mFocusManager.setMirror(mirror);
+        mFocusManager.setParameters(mParameters);
+
+        readVideoPreferences();
+        mUI.applySurfaceChange(SVideoUI.SURFACE_STATUS.SURFACE_VIEW);
+        startPreview();
+        initializeVideoSnapshot();
+        resizeForPreviewAspectRatio();
+        initializeVideoControl();
+
+        initializeCapabilities();
+
+        // From onResume
+        mZoomValue = 0;
+        mUI.initializeZoom(mParameters);
+        mUI.setOrientationIndicator(0, false);
+
+        // Start switch camera animation. Post a message because
+        // onFrameAvailable from the old camera may already exist.
+        mHandler.sendEmptyMessage(SWITCH_CAMERA_START_ANIMATION);
+
+        //Display timelapse msg depending upon selection in front/back camera.
+        mUI.showTimeLapseUI(mCaptureTimeLapse);
+
+    }
+
+    private void initializeCapabilities() {
+        mFocusAreaSupported = CameraUtil.isFocusAreaSupported(mParameters);
+        mMeteringAreaSupported = CameraUtil.isMeteringAreaSupported(mParameters);
+        mAeLockSupported = CameraUtil.isAutoExposureLockSupported(mParameters);
+        mAwbLockSupported = CameraUtil.isAutoWhiteBalanceLockSupported(mParameters);
+    }
+
+    // Preview texture has been copied. Now camera can be released and the
+    // animation can be started.
+    @Override
+    public void onPreviewTextureCopied() {
+        mHandler.sendEmptyMessage(SWITCH_CAMERA);
+    }
+
+    @Override
+    public void onCaptureTextureCopied() {
+    }
+
+    private void initializeVideoSnapshot() {
+        if (mParameters == null) return;
+        if (CameraUtil.isVideoSnapshotSupported(mParameters) && !mIsVideoCaptureIntent) {
+            // Show the tap to focus toast if this is the first start.
+            if (mPreferences.getBoolean(
+                        CameraSettings.KEY_VIDEO_FIRST_USE_HINT_SHOWN, true)) {
+                // Delay the toast for one second to wait for orientation.
+                mHandler.sendEmptyMessageDelayed(SHOW_TAP_TO_SNAPSHOT_TOAST, 1000);
+            }
+        }
+    }
+
+    void showVideoSnapshotUI(boolean enabled) {
+        if (mParameters == null) return;
+        if (CameraUtil.isVideoSnapshotSupported(mParameters) && !mIsVideoCaptureIntent) {
+            if (enabled) {
+                mUI.animateFlash();
+                mUI.animateCapture();
+            } else {
+                mUI.showPreviewBorder(enabled);
+            }
+            mUI.enableShutter(!enabled);
+        }
+    }
+
+    private void forceFlashOffIfSupported(boolean forceOff) {
+        String flashMode;
+        if (!forceOff) {
+            flashMode = mPreferences.getString(
+                    CameraSettings.KEY_VIDEOCAMERA_FLASH_MODE,
+                    mActivity.getString(R.string.pref_camera_video_flashmode_default));
+        } else {
+            flashMode = Parameters.FLASH_MODE_OFF;
+        }
+        List<String> supportedFlash = mParameters.getSupportedFlashModes();
+        if (isSupported(flashMode, supportedFlash)) {
+            mParameters.setFlashMode(flashMode);
+        } else {
+            flashMode = mParameters.getFlashMode();
+            if (flashMode == null) {
+                flashMode = mActivity.getString(
+                        R.string.pref_camera_flashmode_no_flash);
+            }
+        }
+    }
+
+    /**
+     * Used to update the flash mode. Video mode can turn on the flash as torch
+     * mode, which we would like to turn on and off when we switching in and
+     * out to the preview.
+     *
+     * @param forceOff whether we want to force the flash off.
+     */
+    private void forceFlashOff(boolean forceOff) {
+        if (!mPreviewing || mParameters.getFlashMode() == null) {
+            return;
+        }
+        forceFlashOffIfSupported(forceOff);
+        mCameraDevice.setParameters(mParameters);
+    }
+
+    @Override
+    public void onPreviewFocusChanged(boolean previewFocused) {
+        mUI.onPreviewFocusChanged(previewFocused);
+        mHandler.sendEmptyMessageDelayed(HANDLE_FLASH_TORCH_DELAY, 800);
+        mPreviewFocused = previewFocused;
+    }
+
+    @Override
+    public boolean arePreviewControlsVisible() {
+        return mUI.arePreviewControlsVisible();
+    }
+
+    private final class JpegPictureCallback implements CameraPictureCallback {
+        Location mLocation;
+
+        public JpegPictureCallback(Location loc) {
+            mLocation = loc;
+        }
+
+        @Override
+        public void onPictureTaken(byte [] jpegData, CameraProxy camera) {
+            Log.v(TAG, "onPictureTaken");
+            if(!mSnapshotInProgress || mPaused || mCameraDevice == null) return;
+            mSnapshotInProgress = false;
+            showVideoSnapshotUI(false);
+            storeImage(jpegData, mLocation);
+        }
+    }
+
+    private void storeImage(final byte[] data, Location loc) {
+        long dateTaken = System.currentTimeMillis();
+        String title = CameraUtil.createJpegName(dateTaken);
+        ExifInterface exif = Exif.getExif(data);
+        int orientation = Exif.getOrientation(exif);
+        Size s = mParameters.getPictureSize();
+        mActivity.getMediaSaveService().addImage(
+                data, title, dateTaken, loc, s.width, s.height, orientation,
+                exif, mOnPhotoSavedListener, mContentResolver,
+                SPhotoModule.PIXEL_FORMAT_JPEG);
+    }
+
+    private String convertOutputFormatToMimeType(int outputFileFormat) {
+        if (outputFileFormat == MediaRecorder.OutputFormat.MPEG_4) {
+            return "video/mp4";
+        }
+        return "video/3gpp";
+    }
+
+    private String convertOutputFormatToFileExt(int outputFileFormat) {
+        if (outputFileFormat == MediaRecorder.OutputFormat.MPEG_4) {
+            return ".mp4";
+        }
+        return ".3gp";
+    }
+
+    private void closeVideoFileDescriptor() {
+        if (mVideoFileDescriptor != null) {
+            try {
+                mVideoFileDescriptor.close();
+            } catch (IOException e) {
+                Log.e(TAG, "Fail to close fd", e);
+            }
+            mVideoFileDescriptor = null;
+        }
+    }
+
+    private void showTapToSnapshotToast() {
+        new RotateTextToast(mActivity, R.string.video_snapshot_hint, 0).show();
+        // Clear the preference.
+        Editor editor = mPreferences.edit();
+        editor.putBoolean(CameraSettings.KEY_VIDEO_FIRST_USE_HINT_SHOWN, false);
+        editor.apply();
+    }
+
+    @Override
+    public boolean updateStorageHintOnResume() {
+        return true;
+    }
+
+    // required by OnPreferenceChangedListener
+    @Override
+    public void onCameraPickerClicked(int cameraId) {
+        if (mPaused || mPendingSwitchCameraId != -1) return;
+
+        mPendingSwitchCameraId = cameraId;
+        Log.d(TAG, "Start to copy texture.");
+        // We need to keep a preview frame for the animation before
+        // releasing the camera. This will trigger onPreviewTextureCopied.
+        // TODO: ((CameraScreenNail) mActivity.mCameraScreenNail).copyTexture();
+        // Disable all camera controls.
+        mSwitchingCamera = true;
+        switchCamera();
+
+    }
+
+    @Override
+    public void onShowSwitcherPopup() {
+        mUI.onShowSwitcherPopup();
+    }
+
+    @Override
+    public void onMediaSaveServiceConnected(MediaSaveService s) {
+        // do nothing.
+    }
+
+    @Override
+    public void onPreviewUIReady() {
+        if (mPaused || mCameraDevice == null) {
+            return;
+        }
+        Log.v(TAG, "onPreviewUIReady");
+        if (!mPreviewing) {
+            startPreview();
+        } else {
+            synchronized (mCameraDevice) {
+                SurfaceHolder sh = mUI.getSurfaceHolder();
+                if (sh == null) {
+                    Log.w(TAG, "holder for preview is not ready.");
+                    return;
+                }
+                mCameraDevice.setPreviewDisplay(sh);
+            }
+        }
+    }
+
+    @Override
+    public void onPreviewUIDestroyed() {
+        stopPreview();
+    }
+
+     @Override
+    public void onButtonPause() {
+        pauseVideoRecording();
+    }
+
+    @Override
+    public void onButtonContinue() {
+        resumeVideoRecording();
+    }
+
+    private void updatePowerMode() {
+        String lpmSupported = mParameters.get("low-power-mode-supported");
+        if ((lpmSupported != null) && "true".equals(lpmSupported)) {
+            if (!mIsDISEnabled && !mIsFlipEnabled) {
+                mParameters.set("low-power-mode", "enable");
+            } else {
+                mParameters.set("low-power-mode", "disable");
+            }
+        }
+    }
+
+
+    public void startFaceDetection() {
+        if (mCameraDevice == null) return;
+
+        if (mFaceDetectionEnabled == false
+               || mFaceDetectionStarted) return;
+        if (mParameters.getMaxNumDetectedFaces() > 0) {
+            mFaceDetectionStarted = true;
+            CameraInfo info = CameraHolder.instance().getCameraInfo()[mCameraId];
+            mUI.onStartFaceDetection(mCameraDisplayOrientation,
+                    (info.facing == CameraInfo.CAMERA_FACING_FRONT));
+            mCameraDevice.setFaceDetectionCallback(mHandler, mUI);
+            Log.d(TAG, "start face detection Video "+mParameters.getMaxNumDetectedFaces());
+            mCameraDevice.startFaceDetection();
+        }
+    }
+
+    public void stopFaceDetection() {
+        Log.d(TAG, "stop face detection");
+        if (mFaceDetectionEnabled == false || !mFaceDetectionStarted) return;
+        if (mParameters.getMaxNumDetectedFaces() > 0) {
+            mFaceDetectionStarted = false;
+            mCameraDevice.setFaceDetectionCallback(null, null);
+            mCameraDevice.stopFaceDetection();
+            mUI.onStopFaceDetection();
+        }
+    }
+
+    @Override
+    public void onErrorListener(int error) {
+        enableRecordingLocation(false);
+    }
+
+}
+
diff --git a/src/com/android/camera/SVideoUI.java b/src/com/android/camera/SVideoUI.java
new file mode 100755
index 0000000..8c0be96
--- /dev/null
+++ b/src/com/android/camera/SVideoUI.java
@@ -0,0 +1,1268 @@
+/*
+ * Copyright (C) 2012 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.camera;
+
+import java.util.List;
+
+import org.codeaurora.snapcam.R;
+
+import android.content.res.Configuration;
+import android.graphics.Bitmap;
+import android.graphics.Color;
+import android.graphics.Point;
+import android.graphics.drawable.ColorDrawable;
+import android.hardware.Camera.Parameters;
+import android.hardware.Camera.Face;
+import android.util.Log;
+import android.view.Gravity;
+import android.view.MotionEvent;
+import android.view.SurfaceHolder;
+import android.view.SurfaceView;
+import android.view.View;
+import android.view.View.OnClickListener;
+import android.view.View.OnLayoutChangeListener;
+import android.view.ViewGroup;
+import android.view.ViewStub;
+import android.widget.FrameLayout;
+import android.widget.FrameLayout.LayoutParams;
+import android.widget.ImageView;
+import android.widget.LinearLayout;
+import android.widget.ListView;
+import android.widget.PopupWindow;
+import android.widget.TextView;
+import android.view.View.OnLayoutChangeListener;
+
+import com.android.camera.CameraManager.CameraProxy;
+import com.android.camera.CameraPreference.OnPreferenceChangedListener;
+import com.android.camera.SPhotoUI.SurfaceTextureSizeChangedListener;
+import com.android.camera.ui.AbstractSettingPopup;
+import com.android.camera.ui.CameraControls;
+import com.android.camera.ui.CameraRootView;
+import com.android.camera.ui.FaceView;
+import com.android.camera.ui.ListSubMenu;
+import com.android.camera.ui.ModuleSwitcher;
+import com.android.camera.ui.PieRenderer;
+import com.android.camera.ui.RenderOverlay;
+import com.android.camera.ui.RotateImageView;
+import com.android.camera.ui.RotateLayout;
+import com.android.camera.ui.RotateTextToast;
+import com.android.camera.ui.ZoomRenderer;
+import com.android.camera.ui.focus.FocusRing;
+import com.android.camera.util.CameraUtil;
+
+public class SVideoUI implements PieRenderer.PieListener,
+        PreviewGestures.SingleTapListener,
+        CameraRootView.MyDisplayListener,
+        SurfaceHolder.Callback,
+        PauseButton.OnPauseButtonListener,
+        CameraManager.CameraFaceDetectionCallback{
+    private static final String TAG = "CAM_SVideoUI";
+    // module fields
+    private final FocusRing mFocusRing;
+    private CameraActivity mActivity;
+    private View mRootView;
+    private SurfaceHolder mSurfaceHolder;
+    // An review image having same size as preview. It is displayed when
+    // recording is stopped in capture intent.
+    private ImageView mReviewImage;
+    private View mReviewCancelButton;
+    private View mReviewDoneButton;
+    private View mReviewPlayButton;
+    private ShutterButton mShutterButton;
+    private PauseButton mPauseButton;
+    private ModuleSwitcher mSwitcher;
+    private TextView mRecordingTimeView;
+    private LinearLayout mLabelsLinearLayout;
+    private View mTimeLapseLabel;
+    private RenderOverlay mRenderOverlay;
+    private PieRenderer mPieRenderer;
+    private SVideoMenu mSVideoMenu;
+    private CameraControls mCameraControls;
+    private SettingsPopup mPopup;
+    private ZoomRenderer mZoomRenderer;
+    private PreviewGestures mGestures;
+    private View mMenuButton;
+    private RotateLayout mRecordingTimeRect;
+    private boolean mRecordingStarted = false;
+    private VideoController mController;
+    private int mZoomMax;
+    private List<Integer> mZoomRatios;
+    private ImageView mThumbnail;
+    private View mFlashOverlay;
+    private boolean mOrientationResize;
+    private boolean mPrevOrientationResize;
+    private boolean mIsTimeLapse = false;
+    private RotateLayout mMenuLayout;
+    private RotateLayout mSubMenuLayout;
+    private LinearLayout mPreviewMenuLayout;
+
+    private View mPreviewCover;
+    private SurfaceView mSurfaceView = null;
+    private int mMaxPreviewWidth = 0;
+    private int mMaxPreviewHeight = 0;
+    private float mAspectRatio = 4f / 3f;
+    private boolean mAspectRatioResize;
+    private final AnimationManager mAnimationManager;
+    private boolean mUIhidden = false;
+    private int mPreviewOrientation = -1;
+    private int mOrientation;
+
+    private int mScreenRatio = CameraUtil.RATIO_UNKNOWN;
+    private int mTopMargin = 0;
+    private int mBottomMargin = 0;
+    private RotateImageView mMuteButton;
+
+    //Face detection
+    private FaceView mFaceView;
+    private SurfaceTextureSizeChangedListener mSurfaceTextureSizeListener;
+    private float mSurfaceTextureUncroppedWidth;
+    private float mSurfaceTextureUncroppedHeight;
+
+    public enum SURFACE_STATUS {
+        HIDE,
+        SURFACE_VIEW;
+    }
+
+    public void showPreviewCover() {
+        mPreviewCover.setVisibility(View.VISIBLE);
+    }
+
+    public void hidePreviewCover() {
+        if (mPreviewCover != null && mPreviewCover.getVisibility() != View.GONE) {
+            mPreviewCover.setVisibility(View.GONE);
+        }
+    }
+
+    public boolean isPreviewCoverVisible() {
+        if ((mPreviewCover != null) &&
+            (mPreviewCover.getVisibility() == View.VISIBLE)) {
+            return true;
+        } else {
+            return false;
+        }
+    }
+
+    private class SettingsPopup extends PopupWindow {
+        public SettingsPopup(View popup) {
+            super(LayoutParams.WRAP_CONTENT, LayoutParams.WRAP_CONTENT);
+            setBackgroundDrawable(new ColorDrawable(Color.TRANSPARENT));
+            setOutsideTouchable(true);
+            setFocusable(true);
+            popup.setVisibility(View.VISIBLE);
+            setContentView(popup);
+            showAtLocation(mRootView, Gravity.CENTER, 0, 0);
+        }
+
+        public void dismiss(boolean topLevelOnly) {
+            super.dismiss();
+            popupDismissed();
+            showUI();
+            // mSVideoMenu.popupDismissed(topLevelOnly);
+
+            // Switch back into fullscreen/lights-out mode after popup
+            // is dimissed.
+            mActivity.setSystemBarsVisibility(false);
+        }
+
+        @Override
+        public void dismiss() {
+            // Called by Framework when touch outside the popup or hit back key
+            dismiss(true);
+        }
+    }
+
+    public synchronized void applySurfaceChange(SURFACE_STATUS status) {
+        if(status == SURFACE_STATUS.HIDE) {
+            mSurfaceView.setVisibility(View.GONE);
+            return;
+        }
+        mSurfaceView.setVisibility(View.VISIBLE);
+    }
+
+    public SVideoUI(CameraActivity activity, VideoController controller, View parent) {
+        mActivity = activity;
+        mController = controller;
+        mRootView = parent;
+        mActivity.getLayoutInflater().inflate(R.layout.video_module,
+                (ViewGroup) mRootView, true);
+        mPreviewCover = mRootView.findViewById(R.id.preview_cover);
+        // display the view
+        mSurfaceView = (SurfaceView) mRootView.findViewById(R.id.mdp_preview_content);
+        mSurfaceView.setVisibility(View.VISIBLE);
+        mSurfaceHolder = mSurfaceView.getHolder();
+        mSurfaceHolder.addCallback(this);
+        mSurfaceHolder.setType(SurfaceHolder.SURFACE_TYPE_PUSH_BUFFERS);
+        Log.v(TAG, "Using mdp_preview_content (MDP path)");
+        View surfaceContainer = mRootView.findViewById(R.id.preview_container);
+        surfaceContainer.addOnLayoutChangeListener(new OnLayoutChangeListener() {
+            @Override
+            public void onLayoutChange(View v, int left, int top, int right,
+                    int bottom, int oldLeft, int oldTop, int oldRight,
+                    int oldBottom) {
+                int width = right - left;
+                int height = bottom - top;
+
+                tryToCloseSubList();
+                if (mMaxPreviewWidth == 0 && mMaxPreviewHeight == 0) {
+                    mMaxPreviewWidth = width;
+                    mMaxPreviewHeight = height;
+                }
+
+                int orientation = mActivity.getResources().getConfiguration().orientation;
+                if ((orientation == Configuration.ORIENTATION_PORTRAIT && width > height)
+                        || (orientation == Configuration.ORIENTATION_LANDSCAPE && width < height)) {
+                    // The screen has rotated; swap SurfaceView width & height
+                    // to ensure correct preview
+                    int oldWidth = width;
+                    width = height;
+                    height = oldWidth;
+                    Log.d(TAG, "Swapping SurfaceView width & height dimensions");
+                    if (mMaxPreviewWidth != 0 && mMaxPreviewHeight != 0) {
+                        int temp = mMaxPreviewWidth;
+                        mMaxPreviewWidth = mMaxPreviewHeight;
+                        mMaxPreviewHeight = temp;
+                    }
+                }
+                if (mOrientationResize != mPrevOrientationResize
+                        || mAspectRatioResize) {
+                    layoutPreview(mAspectRatio);
+                    mAspectRatioResize = false;
+                }
+            }
+        });
+
+        mFocusRing = (FocusRing) mRootView.findViewById(R.id.focus_ring);
+        mFlashOverlay = mRootView.findViewById(R.id.flash_overlay);
+        mShutterButton = (ShutterButton) mRootView.findViewById(R.id.shutter_button);
+        mSwitcher = (ModuleSwitcher) mRootView.findViewById(R.id.camera_switcher);
+        mSwitcher.setCurrentIndex(ModuleSwitcher.SVIDEO_MODULE_INDEX);
+        mSwitcher.setSwitchListener(mActivity);
+        mSwitcher.setOnClickListener(new OnClickListener() {
+            @Override
+            public void onClick(View v) {
+                mSwitcher.showPopup();
+                mSwitcher.setOrientation(mOrientation, false);
+            }
+        });
+
+        mMuteButton = (RotateImageView)mRootView.findViewById(R.id.mute_button);
+        mMuteButton.setVisibility(View.VISIBLE);
+        if(!((SVideoModule)mController).isAudioMute()) {
+            mMuteButton.setImageResource(R.drawable.ic_unmuted_button);
+        } else {
+            mMuteButton.setImageResource(R.drawable.ic_muted_button);
+        }
+        mMuteButton.setOnClickListener(new OnClickListener() {
+            @Override
+            public void onClick(View v) {
+                boolean isEnabled = !((SVideoModule)mController).isAudioMute();
+                ((SVideoModule)mController).setMute(isEnabled, true);
+                if(!isEnabled)
+                    mMuteButton.setImageResource(R.drawable.ic_unmuted_button);
+                else
+                    mMuteButton.setImageResource(R.drawable.ic_muted_button);
+            }
+        });
+
+        initializeMiscControls();
+        initializeOverlay();
+        initializeControlByIntent();
+        initializePauseButton();
+
+        mCameraControls = (CameraControls) mRootView.findViewById(R.id.camera_controls);
+        ViewStub faceViewStub = (ViewStub) mRootView
+                .findViewById(R.id.face_view_stub);
+        if (faceViewStub != null) {
+            faceViewStub.inflate();
+            mFaceView = (FaceView) mRootView.findViewById(R.id.face_view);
+            setSurfaceTextureSizeChangedListener(mFaceView);
+        }
+        mAnimationManager = new AnimationManager();
+        mOrientationResize = false;
+        mPrevOrientationResize = false;
+
+        Point size = new Point();
+        mActivity.getWindowManager().getDefaultDisplay().getRealSize(size);
+        mScreenRatio = CameraUtil.determineRatio(size.x, size.y);
+        calculateMargins(size);
+        mCameraControls.setMargins(mTopMargin, mBottomMargin);
+        ((ViewGroup)mRootView).removeView(mRecordingTimeRect);
+    }
+
+    private void calculateMargins(Point size) {
+        int l = size.x > size.y ? size.x : size.y;
+        int tm = mActivity.getResources().getDimensionPixelSize(R.dimen.preview_top_margin);
+        int bm = mActivity.getResources().getDimensionPixelSize(R.dimen.preview_bottom_margin);
+        mTopMargin = l / 4 * tm / (tm + bm);
+        mBottomMargin = l / 4 - mTopMargin;
+    }
+
+    public void cameraOrientationPreviewResize(boolean orientation){
+       mPrevOrientationResize = mOrientationResize;
+       mOrientationResize = orientation;
+    }
+
+    public void setSurfaceTextureSizeChangedListener(SurfaceTextureSizeChangedListener listener) {
+        mSurfaceTextureSizeListener = listener;
+    }
+
+    public void initializeSurfaceView() {
+        if (mSurfaceView == null) {
+            mSurfaceView = new SurfaceView(mActivity);
+            ((ViewGroup) mRootView).addView(mSurfaceView, 0);
+            mSurfaceHolder = mSurfaceView.getHolder();
+            mSurfaceHolder.addCallback(this);
+        }
+    }
+
+    private void initializeControlByIntent() {
+        mMenuButton = mRootView.findViewById(R.id.menu);
+        mMenuButton.setOnClickListener(new OnClickListener() {
+            @Override
+            public void onClick(View v) {
+                mSVideoMenu.openFirstLevel();
+            }
+        });
+
+        mCameraControls = (CameraControls) mRootView.findViewById(R.id.camera_controls);
+        if (mController.isVideoCaptureIntent()) {
+            hideSwitcher();
+            mActivity.getLayoutInflater().inflate(R.layout.review_module_control,
+                    (ViewGroup) mCameraControls);
+            // Cannot use RotateImageView for "done" and "cancel" button because
+            // the tablet layout uses RotateLayout, which cannot be cast to
+            // RotateImageView.
+            mReviewDoneButton = mRootView.findViewById(R.id.done_button);
+            mReviewCancelButton = mRootView.findViewById(R.id.btn_cancel);
+            mReviewPlayButton = mRootView.findViewById(R.id.btn_play);
+            mReviewCancelButton.setVisibility(View.VISIBLE);
+            mReviewDoneButton.setOnClickListener(new OnClickListener() {
+                @Override
+                public void onClick(View v) {
+                    mController.onReviewDoneClicked(v);
+                }
+            });
+            mReviewCancelButton.setOnClickListener(new OnClickListener() {
+                @Override
+                public void onClick(View v) {
+                    mController.onReviewCancelClicked(v);
+                }
+            });
+            mReviewPlayButton.setOnClickListener(new OnClickListener() {
+                @Override
+                public void onClick(View v) {
+                    mController.onReviewPlayClicked(v);
+                }
+            });
+        }
+    }
+
+    public void setPreviewSize(int width, int height) {
+        if (width == 0 || height == 0) {
+            Log.w(TAG, "Preview size should not be 0.");
+            return;
+        }
+        float ratio;
+        if (width > height) {
+            ratio = (float) width / height;
+        } else {
+            ratio = (float) height / width;
+        }
+        if (mOrientationResize && CameraUtil.isScreenRotated(mActivity)) {
+            ratio = 1 / ratio;
+        }
+
+        if (ratio != mAspectRatio){
+            mAspectRatioResize = true;
+            mAspectRatio = ratio;
+        }
+
+        mCameraControls.setPreviewRatio(mAspectRatio, false);
+        layoutPreview((float) ratio);
+    }
+
+    private void layoutPreview(float ratio) {
+        FrameLayout.LayoutParams lp = null;
+
+        float scaledTextureWidth = 0.0f, scaledTextureHeight = 0.0f;
+        int rotation = CameraUtil.getDisplayRotation(mActivity);
+        if(!CameraUtil.isDefaultToPortrait(mActivity)) {
+        rotation = (rotation - 90) % 360;
+        }
+        mScreenRatio = CameraUtil.determineRatio(ratio);
+        if (mScreenRatio == CameraUtil.RATIO_16_9
+                && CameraUtil.determinCloseRatio(ratio) == CameraUtil.RATIO_4_3) {
+            int l = (mTopMargin + mBottomMargin) * 4;
+            int s = l * 9 / 16;
+            switch (rotation) {
+                case 90:
+                    lp = new FrameLayout.LayoutParams(l * 3 / 4, s);
+                    lp.setMargins(mTopMargin, 0, mBottomMargin, 0);
+                    scaledTextureWidth = l * 3 / 4;
+                    scaledTextureHeight = s;
+                    break;
+                case 180:
+                    lp = new FrameLayout.LayoutParams(s, l * 3 / 4);
+                    lp.setMargins(0, mBottomMargin, 0, mTopMargin);
+                    scaledTextureWidth = s;
+                    scaledTextureHeight = l * 3 / 4;
+                    break;
+                case 270:
+                    lp = new FrameLayout.LayoutParams(l * 3 / 4, s);
+                    lp.setMargins(mBottomMargin, 0, mTopMargin, 0);
+                    scaledTextureWidth = l * 3 / 4;
+                    scaledTextureHeight = s;
+                    break;
+                default:
+                    lp = new FrameLayout.LayoutParams(s, l * 3 / 4);
+                    lp.setMargins(0, mTopMargin, 0, mBottomMargin);
+                    scaledTextureWidth = s;
+                    scaledTextureHeight = l * 3 / 4;
+                    break;
+            }
+        } else {
+            float width = mMaxPreviewWidth, height = mMaxPreviewHeight;
+            if (width == 0 || height == 0) return;
+            if(mScreenRatio == CameraUtil.RATIO_4_3)
+                height -=  (mTopMargin + mBottomMargin);
+            if (mOrientationResize) {
+                scaledTextureWidth = height * mAspectRatio;
+                if (scaledTextureWidth > width) {
+                    scaledTextureWidth = width;
+                    scaledTextureHeight = scaledTextureWidth / mAspectRatio;
+                } else {
+                    scaledTextureHeight = height;
+                }
+            } else {
+                if (width > height) {
+                    if(Math.max(width, height * mAspectRatio) > width) {
+                        scaledTextureWidth = width;
+                        scaledTextureHeight = width / mAspectRatio;
+                    } else {
+                        scaledTextureWidth = height * mAspectRatio;
+                        scaledTextureHeight = height;
+                    }
+                } else {
+                    if(Math.max(height, width * mAspectRatio) > height) {
+                        scaledTextureWidth = height / mAspectRatio;
+                        scaledTextureHeight = height;
+                    } else {
+                        scaledTextureWidth = width;
+                        scaledTextureHeight = width * mAspectRatio;
+                    }
+                }
+            }
+
+            Log.v(TAG, "setTransformMatrix: scaledTextureWidth = " + scaledTextureWidth
+                    + ", scaledTextureHeight = " + scaledTextureHeight);
+
+            if (((rotation == 0 || rotation == 180) && scaledTextureWidth > scaledTextureHeight)
+                    || ((rotation == 90 || rotation == 270)
+                        && scaledTextureWidth < scaledTextureHeight)) {
+                lp = new FrameLayout.LayoutParams((int) scaledTextureHeight,
+                        (int) scaledTextureWidth, Gravity.CENTER);
+            } else {
+                lp = new FrameLayout.LayoutParams((int) scaledTextureWidth,
+                        (int) scaledTextureHeight, Gravity.CENTER);
+            }
+        }
+
+        if (mSurfaceTextureUncroppedWidth != scaledTextureWidth ||
+                mSurfaceTextureUncroppedHeight != scaledTextureHeight) {
+            mSurfaceTextureUncroppedWidth = scaledTextureWidth;
+            mSurfaceTextureUncroppedHeight = scaledTextureHeight;
+            if (mSurfaceTextureSizeListener != null) {
+                mSurfaceTextureSizeListener.onSurfaceTextureSizeChanged(
+                        (int) mSurfaceTextureUncroppedWidth,
+                        (int) mSurfaceTextureUncroppedHeight);
+                Log.d(TAG, "mSurfaceTextureUncroppedWidth=" + mSurfaceTextureUncroppedWidth
+                        + "mSurfaceTextureUncroppedHeight=" + mSurfaceTextureUncroppedHeight);
+            }
+        }
+
+
+        if(lp != null) {
+            mSurfaceView.setLayoutParams(lp);
+            mSurfaceView.requestLayout();
+            if (mFaceView != null) {
+                mFaceView.setLayoutParams(lp);
+            }
+
+        }
+
+        if (scaledTextureWidth > 0 && scaledTextureHeight > 0) {
+            mController.onScreenSizeChanged((int) scaledTextureWidth,
+                    (int) scaledTextureHeight);
+        }
+    }
+
+    /**
+     * Starts a flash animation
+     */
+    public void animateFlash() {
+        mAnimationManager.startFlashAnimation(mFlashOverlay);
+    }
+
+    /**
+     * Starts a capture animation
+     */
+    public void animateCapture() {
+        Bitmap bitmap = null;
+        animateCapture(bitmap);
+    }
+
+    /**
+     * Starts a capture animation
+     * @param bitmap the captured image that we shrink and slide in the animation
+     */
+    public void animateCapture(Bitmap bitmap) {
+        if (bitmap == null) {
+            Log.e(TAG, "No valid bitmap for capture animation.");
+            return;
+        }
+        mActivity.updateThumbnail(bitmap);
+        mAnimationManager.startCaptureAnimation(mThumbnail);
+    }
+
+    /**
+     * Cancels on-going animations
+     */
+    public void cancelAnimations() {
+        mAnimationManager.cancelAnimations();
+    }
+
+    public void hideUI() {
+        mSwitcher.closePopup();
+        if (mUIhidden)
+            return;
+        mUIhidden = true;
+        mCameraControls.hideUI();
+    }
+
+    public void showUI() {
+        if (!mUIhidden || (mSVideoMenu != null && mSVideoMenu.isMenuBeingShown()))
+            return;
+        mUIhidden = false;
+        mCameraControls.showUI();
+    }
+
+    public boolean arePreviewControlsVisible() {
+        return !mUIhidden;
+    }
+
+    public void hideSwitcher() {
+        mSwitcher.closePopup();
+        mSwitcher.setVisibility(View.INVISIBLE);
+    }
+
+    public void showSwitcher() {
+        mSwitcher.setVisibility(View.VISIBLE);
+    }
+
+    public void setSwitcherIndex() {
+        mSwitcher.setCurrentIndex(ModuleSwitcher.SVIDEO_MODULE_INDEX);
+    }
+
+    public boolean collapseCameraControls() {
+        boolean ret = false;
+        mSwitcher.closePopup();
+        if (mSVideoMenu != null) {
+            mSVideoMenu.closeAllView();
+        }
+        if (mPopup != null) {
+            dismissPopup(false);
+            ret = true;
+        }
+        return ret;
+    }
+
+    public boolean removeTopLevelPopup() {
+        if (mPopup != null) {
+            dismissPopup(true);
+            return true;
+        }
+        return false;
+    }
+
+    public void enableCameraControls(boolean enable) {
+        if (mGestures != null) {
+            mGestures.setZoomOnly(!enable);
+        }
+        if (mPieRenderer != null && mPieRenderer.showsItems()) {
+            mPieRenderer.hide();
+        }
+    }
+
+    public void initDisplayChangeListener() {
+        ((CameraRootView) mRootView).setDisplayChangeListener(this);
+    }
+
+    public void setDisplayOrientation(int orientation) {
+        if (mFaceView != null) {
+             mFaceView.setDisplayOrientation(orientation);
+        }
+
+        if ((mPreviewOrientation == -1 || mPreviewOrientation != orientation)
+                && mSVideoMenu != null && mSVideoMenu.isPreviewMenuBeingShown()) {
+            dismissSceneModeMenu();
+            mSVideoMenu.addModeBack();
+        }
+        mPreviewOrientation = orientation;
+    }
+
+    public void removeDisplayChangeListener() {
+        ((CameraRootView) mRootView).removeDisplayChangeListener();
+    }
+
+// no customvideo?
+    public void overrideSettings(final String... keyvalues) {
+        if (mSVideoMenu != null) {
+            mSVideoMenu.overrideSettings(keyvalues);
+        }
+    }
+
+    public void setOrientationIndicator(int orientation, boolean animation) {
+        // We change the orientation of the linearlayout only for phone UI
+        // because when in portrait the width is not enough.
+        if (mLabelsLinearLayout != null) {
+            if (((orientation / 90) & 1) == 0) {
+                mLabelsLinearLayout.setOrientation(LinearLayout.VERTICAL);
+            } else {
+                mLabelsLinearLayout.setOrientation(LinearLayout.HORIZONTAL);
+            }
+        }
+    }
+
+    public SurfaceHolder getSurfaceHolder() {
+        return mSurfaceHolder;
+    }
+
+    public void hideSurfaceView() {
+        mSurfaceView.setVisibility(View.INVISIBLE);
+    }
+
+    public void showSurfaceView() {
+        mSurfaceView.setVisibility(View.VISIBLE);
+    }
+
+    private void initializeOverlay() {
+        mRenderOverlay = (RenderOverlay) mRootView.findViewById(R.id.render_overlay);
+        if (mPieRenderer == null) {
+            mPieRenderer = new PieRenderer(mActivity);
+            // mSVideoMenu = new SVideoMenu(mActivity, this, mPieRenderer);
+            mPieRenderer.setPieListener(this);
+        }
+        if (mSVideoMenu == null) {
+            mSVideoMenu = new SVideoMenu(mActivity, this);
+        }
+        mRenderOverlay.addRenderer(mPieRenderer);
+        if (mZoomRenderer == null) {
+            mZoomRenderer = new ZoomRenderer(mActivity);
+        }
+        mRenderOverlay.addRenderer(mZoomRenderer);
+        if (mGestures == null) {
+            mGestures = new PreviewGestures(mActivity, this, mZoomRenderer, mPieRenderer, null);
+            mRenderOverlay.setGestures(mGestures);
+        }
+        mGestures.setSVideoMenu(mSVideoMenu);
+
+        mGestures.setRenderOverlay(mRenderOverlay);
+
+        if (!mActivity.isSecureCamera()) {
+            mThumbnail = (ImageView) mRootView.findViewById(R.id.preview_thumb);
+            mThumbnail.setOnClickListener(new OnClickListener() {
+                @Override
+                public void onClick(View v) {
+                    // Do not allow navigation to filmstrip during video recording
+                    if (!mRecordingStarted && !CameraControls.isAnimating()) {
+                        mActivity.gotoGallery();
+                    }
+                }
+            });
+        }
+    }
+
+    public void setPreviewGesturesVideoUI() {
+        mActivity.setPreviewGestures(mGestures);
+    }
+
+    public void setPrefChangedListener(OnPreferenceChangedListener listener) {
+        mSVideoMenu.setListener(listener);
+    }
+
+    private void initializeMiscControls() {
+        mReviewImage = (ImageView) mRootView.findViewById(R.id.review_image);
+        mShutterButton.setImageResource(R.drawable.btn_new_shutter_video);
+        mShutterButton.setOnShutterButtonListener(mController);
+        mShutterButton.setVisibility(View.VISIBLE);
+        mShutterButton.requestFocus();
+        mShutterButton.enableTouch(true);
+        mRecordingTimeView = (TextView) mRootView.findViewById(R.id.recording_time);
+        mRecordingTimeRect = (RotateLayout) mRootView.findViewById(R.id.recording_time_rect);
+        mTimeLapseLabel = mRootView.findViewById(R.id.time_lapse_label);
+        // The R.id.labels can only be found in phone layout.
+        // That is, mLabelsLinearLayout should be null in tablet layout.
+        mLabelsLinearLayout = (LinearLayout) mRootView.findViewById(R.id.labels);
+    }
+
+    private void initializePauseButton() {
+        mPauseButton = (PauseButton) mRootView.findViewById(R.id.video_pause);
+        mPauseButton.setOnPauseButtonListener(this);
+    }
+
+    public void setAspectRatio(double ratio) {
+        if (mOrientationResize && CameraUtil.isScreenRotated(mActivity)) {
+            ratio = 1 / ratio;
+        }
+
+        if (ratio != mAspectRatio) {
+            mAspectRatioResize = true;
+            mAspectRatio = (float)ratio;
+        }
+
+        mCameraControls.setPreviewRatio(mAspectRatio, false);
+        layoutPreview((float)ratio);
+    }
+
+    public void showTimeLapseUI(boolean enable) {
+        if (mTimeLapseLabel != null) {
+            mTimeLapseLabel.setVisibility(enable ? View.VISIBLE : View.GONE);
+        }
+        mIsTimeLapse = enable;
+    }
+
+    public void dismissPopup(boolean topLevelOnly) {
+        // In review mode, we do not want to bring up the camera UI
+        if (mController.isInReviewMode()) return;
+        if (mPopup != null) {
+            mPopup.dismiss(topLevelOnly);
+        }
+    }
+
+    public boolean is4KEnabled() {
+        if(mController != null)
+            return ((SVideoModule)mController).is4KEnabled();
+        else
+            return false;
+    }
+
+    private void popupDismissed() {
+        mPopup = null;
+    }
+
+    public boolean onBackPressed() {
+        if (mSVideoMenu != null && mSVideoMenu.handleBackKey()) {
+            return true;
+        }
+        if (hidePieRenderer()) {
+            return true;
+        } else {
+            return removeTopLevelPopup();
+        }
+    }
+
+    public void cleanupListview() {
+        showUI();
+        mActivity.setSystemBarsVisibility(false);
+    }
+
+    public void dismissLevel1() {
+        if (mMenuLayout != null) {
+            ((ViewGroup) mRootView).removeView(mMenuLayout);
+            mMenuLayout = null;
+        }
+    }
+
+    public void dismissLevel2() {
+        if (mSubMenuLayout != null) {
+            ((ViewGroup) mRootView).removeView(mSubMenuLayout);
+            mSubMenuLayout = null;
+        }
+    }
+
+    public boolean sendTouchToPreviewMenu(MotionEvent ev) {
+        return mPreviewMenuLayout.dispatchTouchEvent(ev);
+    }
+
+    public boolean sendTouchToMenu(MotionEvent ev) {
+        if (mMenuLayout != null) {
+            View v = mMenuLayout.getChildAt(0);
+            return v.dispatchTouchEvent(ev);
+        }
+        return false;
+    }
+
+    public void dismissSceneModeMenu() {
+        if (mPreviewMenuLayout != null) {
+            ((ViewGroup) mRootView).removeView(mPreviewMenuLayout);
+            mPreviewMenuLayout = null;
+        }
+    }
+
+    public void removeSceneModeMenu() {
+        if (mPreviewMenuLayout != null) {
+            ((ViewGroup) mRootView).removeView(mPreviewMenuLayout);
+            mPreviewMenuLayout = null;
+        }
+        cleanupListview();
+    }
+
+    public void removeLevel2() {
+        if (mSubMenuLayout != null) {
+            View v = mSubMenuLayout.getChildAt(0);
+            mSubMenuLayout.removeView(v);
+        }
+    }
+
+    public void showPopup(ListView popup, int level, boolean animate) {
+        FrameLayout.LayoutParams layoutParams;
+        hideUI();
+
+        popup.setVisibility(View.VISIBLE);
+        if (level == 1) {
+            if (mMenuLayout == null) {
+                mMenuLayout = new RotateLayout(mActivity, null);
+                if (mRootView.getLayoutDirection() != View.LAYOUT_DIRECTION_RTL) {
+                    layoutParams = new FrameLayout.LayoutParams(
+                            CameraActivity.SETTING_LIST_WIDTH_1, LayoutParams.WRAP_CONTENT,
+                            Gravity.LEFT | Gravity.TOP);
+                } else {
+                    layoutParams = new FrameLayout.LayoutParams(
+                            CameraActivity.SETTING_LIST_WIDTH_1, LayoutParams.WRAP_CONTENT,
+                            Gravity.RIGHT | Gravity.TOP);
+                }
+                mMenuLayout.setLayoutParams(layoutParams);
+                ((ViewGroup) mRootView).addView(mMenuLayout);
+            }
+            mMenuLayout.setOrientation(mOrientation, true);
+            mMenuLayout.addView(popup);
+        }
+        if (level == 2) {
+            if (mSubMenuLayout == null) {
+                mSubMenuLayout = new RotateLayout(mActivity, null);
+                ViewGroup.LayoutParams params = new ViewGroup.LayoutParams(
+                        CameraActivity.SETTING_LIST_WIDTH_2, LayoutParams.WRAP_CONTENT);
+                mSubMenuLayout.setLayoutParams(params);
+
+                ((ViewGroup) mRootView).addView(mSubMenuLayout);
+            }
+            if (mRootView.getLayoutDirection() != View.LAYOUT_DIRECTION_RTL) {
+                layoutParams = new FrameLayout.LayoutParams(
+                        CameraActivity.SETTING_LIST_WIDTH_2, LayoutParams.WRAP_CONTENT,
+                        Gravity.LEFT | Gravity.TOP);
+            } else {
+                layoutParams = new FrameLayout.LayoutParams(
+                        CameraActivity.SETTING_LIST_WIDTH_2, LayoutParams.WRAP_CONTENT,
+                        Gravity.RIGHT | Gravity.TOP);
+            }
+
+            int screenHeight = (mOrientation == 0 || mOrientation == 180)
+                    ? mRootView.getHeight() : mRootView.getWidth();
+            int height = ((ListSubMenu) popup).getPreCalculatedHeight();
+            int yBase = ((ListSubMenu) popup).getYBase();
+            int y = Math.max(0, yBase);
+            if (yBase + height > screenHeight)
+                y = Math.max(0, screenHeight - height);
+            if (mRootView.getLayoutDirection() != View.LAYOUT_DIRECTION_RTL) {
+                layoutParams.setMargins(CameraActivity.SETTING_LIST_WIDTH_1, y, 0, 0);
+            } else {
+                layoutParams.setMargins(0, y, CameraActivity.SETTING_LIST_WIDTH_1, 0);
+            }
+
+            mSubMenuLayout.setLayoutParams(layoutParams);
+            mSubMenuLayout.addView(popup);
+            mSubMenuLayout.setOrientation(mOrientation, true);
+        }
+        if (animate) {
+            if (level == 1)
+                mSVideoMenu.animateSlideIn(mMenuLayout, CameraActivity.SETTING_LIST_WIDTH_1, true);
+            if (level == 2)
+                mSVideoMenu.animateFadeIn(popup);
+        } else {
+            popup.setAlpha(1f);
+        }
+    }
+
+    public ViewGroup getMenuLayout() {
+        return mMenuLayout;
+    }
+
+    public void setPreviewMenuLayout(LinearLayout layout) {
+        mPreviewMenuLayout = layout;
+    }
+
+    public ViewGroup getPreviewMenuLayout() {
+        return mPreviewMenuLayout;
+    }
+
+    public void showPopup(AbstractSettingPopup popup) {
+        hideUI();
+
+        if (mPopup != null) {
+            mPopup.dismiss(false);
+        }
+        mPopup = new SettingsPopup(popup);
+    }
+
+    public void onShowSwitcherPopup() {
+        hidePieRenderer();
+    }
+
+    public boolean hidePieRenderer() {
+        if (mPieRenderer != null && mPieRenderer.showsItems()) {
+            mPieRenderer.hide();
+            return true;
+        }
+        return false;
+    }
+
+    // disable preview gestures after shutter is pressed
+    public void setShutterPressed(boolean pressed) {
+        if (mGestures == null) return;
+        mGestures.setEnabled(!pressed);
+    }
+
+    public void enableShutter(boolean enable) {
+        if (mShutterButton != null) {
+            if (enable) {
+                Log.v(TAG, "Shutter Button enabled !!");
+            } else {
+                Log.v(TAG, "Shutter Button disabled !!");
+            }
+            mShutterButton.setEnabled(enable);
+        }
+    }
+
+    // PieListener
+    @Override
+    public void onPieOpened(int centerX, int centerY) {
+        setSwipingEnabled(false);
+        // Close module selection menu when pie menu is opened.
+        mSwitcher.closePopup();
+    }
+
+    @Override
+    public void onPieClosed() {
+        setSwipingEnabled(true);
+    }
+
+    @Override
+    public void onPieMoved(int centerX, int centerY) {
+
+    }
+
+    public void setSwipingEnabled(boolean enable) {
+        mActivity.setSwipingEnabled(enable);
+    }
+
+    public void showPreviewBorder(boolean enable) {
+       // TODO: mPreviewFrameLayout.showBorder(enable);
+    }
+
+    // SingleTapListener
+    // Preview area is touched. Take a picture.
+    @Override
+    public void onSingleTapUp(View view, int x, int y) {
+        mController.onSingleTapUp(view, x, y);
+    }
+
+    public void showRecordingUI(boolean recording) {
+        mRecordingStarted = recording;
+        mMenuButton.setVisibility(recording ? View.GONE : View.VISIBLE);
+        if (recording) {
+            mShutterButton.setImageResource(R.drawable.shutter_button_video_stop);
+            hideSwitcher();
+            mRecordingTimeView.setText("");
+            ((ViewGroup)mRootView).addView(mRecordingTimeRect);
+        } else {
+            mShutterButton.setImageResource(R.drawable.btn_new_shutter_video);
+            if (!mController.isVideoCaptureIntent()) {
+                showSwitcher();
+            }
+            ((ViewGroup)mRootView).removeView(mRecordingTimeRect);
+        }
+    }
+
+    public void hideUIwhileRecording() {
+        mCameraControls.setWillNotDraw(true);
+        mSVideoMenu.hideUI();
+    }
+
+    public void showUIafterRecording() {
+        mCameraControls.setWillNotDraw(false);
+        if (!mController.isVideoCaptureIntent()) {
+            mSVideoMenu.showUI();
+        }
+    }
+
+    public void showReviewImage(Bitmap bitmap) {
+        mReviewImage.setImageBitmap(bitmap);
+        mReviewImage.setVisibility(View.VISIBLE);
+    }
+
+    public void showReviewControls() {
+        CameraUtil.fadeOut(mShutterButton);
+        CameraUtil.fadeIn(mReviewDoneButton);
+        CameraUtil.fadeIn(mReviewPlayButton);
+        mReviewImage.setVisibility(View.VISIBLE);
+        mMenuButton.setVisibility(View.GONE);
+        mCameraControls.hideUI();
+        mSVideoMenu.hideUI();
+    }
+
+    public void hideReviewUI() {
+        mReviewImage.setVisibility(View.GONE);
+        mShutterButton.setEnabled(true);
+        mMenuButton.setVisibility(View.VISIBLE);
+        mCameraControls.showUI();
+        mSVideoMenu.showUI();
+        CameraUtil.fadeOut(mReviewDoneButton);
+        CameraUtil.fadeOut(mReviewPlayButton);
+        CameraUtil.fadeIn(mShutterButton);
+    }
+
+    public void onPreviewFocusChanged(boolean previewFocused) {
+        if (previewFocused) {
+            showUI();
+        } else {
+            hideUI();
+        }
+        if (mGestures != null) {
+            mGestures.setEnabled(previewFocused);
+        }
+        if (mRenderOverlay != null) {
+            // this can not happen in capture mode
+            mRenderOverlay.setVisibility(previewFocused ? View.VISIBLE : View.GONE);
+        }
+    }
+
+    public void initializePopup(PreferenceGroup pref) {
+        mSVideoMenu.initialize(pref);
+    }
+
+    public void initializeZoom(Parameters param) {
+        if (param == null || !param.isZoomSupported()) {
+            mGestures.setZoomEnabled(false);
+            return;
+        }
+        mGestures.setZoomEnabled(true);
+        mZoomMax = param.getMaxZoom();
+        mZoomRatios = param.getZoomRatios();
+        // Currently we use immediate zoom for fast zooming to get better UX and
+        // there is no plan to take advantage of the smooth zoom.
+        mZoomRenderer.setZoomMax(mZoomMax);
+        mZoomRenderer.setZoom(param.getZoom());
+        mZoomRenderer.setZoomValue(mZoomRatios.get(param.getZoom()));
+        mZoomRenderer.setOnZoomChangeListener(new ZoomChangeListener());
+    }
+
+    public void clickShutter() {
+        mShutterButton.performClick();
+    }
+
+    public void pressShutter(boolean pressed) {
+        mShutterButton.setPressed(pressed);
+    }
+
+    public View getShutterButton() {
+        return mShutterButton;
+    }
+
+    public void setRecordingTime(String text) {
+        mRecordingTimeView.setText(text);
+    }
+
+    public void setRecordingTimeTextColor(int color) {
+        mRecordingTimeView.setTextColor(color);
+    }
+
+    public boolean isVisible() {
+        return mCameraControls.getVisibility() == View.VISIBLE;
+    }
+
+    public boolean onScaleStepResize(boolean direction) {
+        if(mGestures != null){
+            return mGestures.onScaleStepResize(direction);
+        }
+        return false;
+    }
+
+    @Override
+    public void onDisplayChanged() {
+        mCameraControls.checkLayoutFlip();
+        mController.updateCameraOrientation();
+    }
+
+    private class ZoomChangeListener implements ZoomRenderer.OnZoomChangedListener {
+        @Override
+        public void onZoomValueChanged(int index) {
+            int newZoom = mController.onZoomChanged(index);
+            if (mZoomRenderer != null) {
+                mZoomRenderer.setZoomValue(mZoomRatios.get(newZoom));
+            }
+        }
+
+        @Override
+        public void onZoomStart() {
+            if (mPieRenderer != null) {
+                if (!mRecordingStarted) mPieRenderer.hide();
+                mPieRenderer.setBlockFocus(true);
+            }
+        }
+
+        @Override
+        public void onZoomEnd() {
+            if (mPieRenderer != null) {
+                mPieRenderer.setBlockFocus(false);
+            }
+        }
+
+        @Override
+        public void onZoomValueChanged(float value) {
+
+        }
+    }
+
+    // SurfaceHolder callbacks
+    @Override
+    public void surfaceChanged(SurfaceHolder holder, int format, int width, int height) {
+        Log.v(TAG, "surfaceChanged: width = " + width + ", height = " + height);
+    }
+
+    @Override
+    public void surfaceCreated(SurfaceHolder holder) {
+        Log.v(TAG, "surfaceCreated");
+        mSurfaceHolder = holder;
+        mController.onPreviewUIReady();
+        mActivity.updateThumbnail(mThumbnail);
+    }
+
+    @Override
+    public void surfaceDestroyed(SurfaceHolder holder) {
+        Log.v(TAG, "surfaceDestroyed");
+        mSurfaceHolder = null;
+        mController.onPreviewUIDestroyed();
+    }
+
+    public View getRootView() {
+        return mRootView;
+    }
+
+     @Override
+    public void onButtonPause() {
+        mRecordingTimeView.setCompoundDrawablesWithIntrinsicBounds(
+                R.drawable.ic_pausing_indicator, 0, 0, 0);
+        mController.onButtonPause();
+    }
+
+    @Override
+    public void onButtonContinue() {
+        mRecordingTimeView.setCompoundDrawablesWithIntrinsicBounds(
+                R.drawable.ic_recording_indicator, 0, 0, 0);
+        mController.onButtonContinue();
+    }
+
+    public void resetPauseButton() {
+        mRecordingTimeView.setCompoundDrawablesWithIntrinsicBounds(
+            R.drawable.ic_recording_indicator, 0, 0, 0);
+        mPauseButton.setPaused(false);
+    }
+
+    public void setPreference(String key, String value) {
+        mSVideoMenu.setPreference(key, value);
+    }
+
+    public boolean hideSwitcherPopup() {
+        if (mSwitcher != null && mSwitcher.showsPopup()) {
+            mSwitcher.closePopup();
+            return true;
+        }
+        return false;
+    }
+
+    public void setOrientation(int orientation, boolean animation) {
+        mCameraControls.setOrientation(orientation, animation);
+        if (mMenuLayout != null)
+            mMenuLayout.setOrientation(orientation, animation);
+        if (mSubMenuLayout != null)
+            mSubMenuLayout.setOrientation(orientation, animation);
+        if (mRecordingTimeRect != null) {
+            if (orientation == 180) {
+                mRecordingTimeRect.setOrientation(0, false);
+                mRecordingTimeView.setRotation(180);
+            } else {
+                mRecordingTimeView.setRotation(0);
+                mRecordingTimeRect.setOrientation(orientation, false);
+            }
+        }
+        if (mPreviewMenuLayout != null) {
+            ViewGroup vg = (ViewGroup) mPreviewMenuLayout.getChildAt(0);
+            if (vg != null)
+                vg = (ViewGroup) vg.getChildAt(0);
+            if (vg != null) {
+                for (int i = vg.getChildCount() - 1; i >= 0; --i) {
+                    RotateLayout l = (RotateLayout) vg.getChildAt(i);
+                    l.setOrientation(orientation, animation);
+                }
+            }
+        }
+        if (mZoomRenderer != null) {
+            mZoomRenderer.setOrientation(orientation);
+        }
+        RotateTextToast.setOrientation(orientation);
+        mOrientation = orientation;
+    }
+
+    public void tryToCloseSubList() {
+        if (mSVideoMenu != null)
+            mSVideoMenu.tryToCloseSubList();
+    }
+
+    public int getOrientation() {
+        return mOrientation;
+    }
+
+    public void adjustOrientation() {
+        setOrientation(mOrientation, false);
+    }
+
+    @Override
+    public void onFaceDetection(Face[] faces, CameraProxy camera) {
+        Log.d(TAG, "onFacedetectopmn");
+        mFaceView.setFaces(faces);
+    }
+
+    public void onStartFaceDetection(int orientation, boolean mirror) {
+        mFaceView.setBlockDraw(false);
+        mFaceView.clear();
+        mFaceView.setVisibility(View.VISIBLE);
+        mFaceView.setDisplayOrientation(orientation);
+        mFaceView.setMirror(mirror);
+        mFaceView.resume();
+    }
+
+    public void onStopFaceDetection() {
+        if (mFaceView != null) {
+            mFaceView.setBlockDraw(true);
+            mFaceView.clear();
+        }
+    }
+
+    public FocusRing getFocusRing() {
+        return mFocusRing;
+    }
+}
diff --git a/src/com/android/camera/WideAnglePanoramaModule.java b/src/com/android/camera/WideAnglePanoramaModule.java
index 0e7d080..8d00178 100644
--- a/src/com/android/camera/WideAnglePanoramaModule.java
+++ b/src/com/android/camera/WideAnglePanoramaModule.java
@@ -45,6 +45,7 @@ import android.view.ViewGroup;
 import android.view.WindowManager;
 import android.widget.Toast;
 import com.android.camera.PhotoModule;
+import com.android.camera.SPhotoModule;
 import com.android.camera.CameraManager.CameraProxy;
 import com.android.camera.app.OrientationManager;
 import com.android.camera.data.LocalData;
@@ -863,7 +864,8 @@ public class WideAnglePanoramaModule
             String filename = PanoUtil.createName(
                     mActivity.getResources().getString(R.string.pano_file_name_format), mTimeTaken);
             String filepath = Storage.generateFilepath(filename,
-                              PhotoModule.PIXEL_FORMAT_JPEG);
+                              CameraUtil.HAS_EXYNOS5CAMERA ? SPhotoModule.PIXEL_FORMAT_JPEG
+                              :PhotoModule.PIXEL_FORMAT_JPEG);
 
             UsageStatistics.onEvent(UsageStatistics.COMPONENT_PANORAMA,
                     UsageStatistics.ACTION_CAPTURE_DONE, null, 0,
diff --git a/src/com/android/camera/imageprocessor/PostProcessor.java b/src/com/android/camera/imageprocessor/PostProcessor.java
index f133c66..4b76eba 100755
--- a/src/com/android/camera/imageprocessor/PostProcessor.java
+++ b/src/com/android/camera/imageprocessor/PostProcessor.java
@@ -58,6 +58,7 @@ import com.android.camera.CaptureModule;
 import com.android.camera.Exif;
 import com.android.camera.MediaSaveService;
 import com.android.camera.PhotoModule;
+import com.android.camera.SPhotoModule;
 import com.android.camera.SettingsManager;
 import com.android.camera.exif.ExifInterface;
 import com.android.camera.exif.Rational;
@@ -116,6 +117,7 @@ public class PostProcessor{
     private ImageFilter.ResultImage mDefaultResultImage;  //This is used only no filter is chosen.
     private Image[] mImages;
     private PhotoModule.NamedImages mNamedImages;
+    private SPhotoModule.SNamedImages mSNamedImages;
     private WatchdogThread mWatchdog;
     private int mOrientation = 0;
     private ImageWriter mImageWriter;
@@ -598,11 +600,21 @@ public class PostProcessor{
         if (isReadyToProcess()) {
             mController.unlockFocus(mController.getMainCameraId());
             long captureStartTime = System.currentTimeMillis();
-            mNamedImages.nameNewImage(captureStartTime);
-            PhotoModule.NamedImages.NamedEntity name = mNamedImages.getNextNameEntity();
-            String title = (name == null) ? null : name.title;
-            long date = (name == null) ? -1 : name.date;
-            processImage(title, date, mController.getMediaSavedListener(), mActivity.getContentResolver());
+            if(CameraUtil.HAS_EXYNOS5CAMERA) {
+                mSNamedImages.nameNewImage(captureStartTime);
+                SPhotoModule.SNamedImages.SNamedEntity name = mSNamedImages.getNextNameEntity();
+                String title = (name == null) ? null : name.title;
+                long date = (name == null) ? -1 : name.date;
+                processImage(title, date, mController.getMediaSavedListener(), mActivity.getContentResolver());
+
+            } else {
+                mNamedImages.nameNewImage(captureStartTime);
+                PhotoModule.NamedImages.NamedEntity name = mNamedImages.getNextNameEntity();
+                String title = (name == null) ? null : name.title;
+                long date = (name == null) ? -1 : name.date;
+                processImage(title, date, mController.getMediaSavedListener(), mActivity.getContentResolver());
+
+            }
         }
     }
 
@@ -611,10 +623,18 @@ public class PostProcessor{
         byte[] data = new byte[buffer.remaining()];
         buffer.get(data);
         long captureStartTime = System.currentTimeMillis();
-        mNamedImages.nameNewImage(captureStartTime);
-        PhotoModule.NamedImages.NamedEntity name = mNamedImages.getNextNameEntity();
-        String title = (name == null) ? null : name.title;
-        mActivity.getMediaSaveService().addRawImage(data, title, "raw");
+        if(CameraUtil.HAS_EXYNOS5CAMERA) {
+            mSNamedImages.nameNewImage(captureStartTime);
+            SPhotoModule.SNamedImages.SNamedEntity name = mSNamedImages.getNextNameEntity();
+            String title = (name == null) ? null : name.title;
+            mActivity.getMediaSaveService().addRawImage(data, title, "raw");
+
+        } else {
+            mNamedImages.nameNewImage(captureStartTime);
+            PhotoModule.NamedImages.NamedEntity name = mNamedImages.getNextNameEntity();
+            String title = (name == null) ? null : name.title;
+            mActivity.getMediaSaveService().addRawImage(data, title, "raw");
+        }
     }
 
     enum STATUS {
@@ -628,7 +648,11 @@ public class PostProcessor{
         mController = module;
         mActivity = activity;
         checkAndEnableZSL(mController.getMainCameraId());
-        mNamedImages = new PhotoModule.NamedImages();
+        if(CameraUtil.HAS_EXYNOS5CAMERA) {
+            mSNamedImages = new SPhotoModule.SNamedImages();
+        } else {
+            mNamedImages = new PhotoModule.NamedImages();
+        }
     }
 
     public boolean isItBusy() {
@@ -1176,29 +1200,56 @@ public class PostProcessor{
             mSavingHander.post(new Runnable() {
                 public void run() {
                     long captureStartTime = System.currentTimeMillis();
-                    mNamedImages.nameNewImage(captureStartTime);
-                    PhotoModule.NamedImages.NamedEntity name = mNamedImages.getNextNameEntity();
-                    String title = (name == null) ? null : name.title;
-                    long date = (name == null) ? -1 : name.date;
-                    image.getPlanes()[0].getBuffer().rewind();
-                    int size = image.getPlanes()[0].getBuffer().remaining();
-                    byte[] bytes = new byte[size];
-                    image.getPlanes()[0].getBuffer().get(bytes, 0, size);
-                    ExifInterface exif = Exif.getExif(bytes);
-                    int orientation = Exif.getOrientation(exif);
-                    if (mController.getCurrentIntentMode() != CaptureModule.INTENT_MODE_NORMAL) {
-                        mController.setJpegImageData(bytes);
-                        if (mController.isQuickCapture()) {
-                            mController.onCaptureDone();
+                    if(CameraUtil.HAS_EXYNOS5CAMERA) {
+                        mSNamedImages.nameNewImage(captureStartTime);
+                        SPhotoModule.SNamedImages.SNamedEntity name = mSNamedImages.getNextNameEntity();
+                        String title = (name == null) ? null : name.title;
+                        long date = (name == null) ? -1 : name.date;
+                        image.getPlanes()[0].getBuffer().rewind();
+                        int size = image.getPlanes()[0].getBuffer().remaining();
+                        byte[] bytes = new byte[size];
+                        image.getPlanes()[0].getBuffer().get(bytes, 0, size);
+                        ExifInterface exif = Exif.getExif(bytes);
+                        int orientation = Exif.getOrientation(exif);
+                        if (mController.getCurrentIntentMode() != CaptureModule.INTENT_MODE_NORMAL) {
+                            mController.setJpegImageData(bytes);
+                            if (mController.isQuickCapture()) {
+                                mController.onCaptureDone();
+                            } else {
+                                mController.showCapturedReview(bytes, orientation);
+                            }
                         } else {
-                            mController.showCapturedReview(bytes, orientation);
+                            mActivity.getMediaSaveService().addImage(
+                                    bytes, title, date, null, image.getCropRect().width(), image.getCropRect().height(),
+                                    orientation, null, mController.getMediaSavedListener(), mActivity.getContentResolver(), "jpeg");
+                            mController.updateThumbnailJpegData(bytes);
+                            image.close();
                         }
                     } else {
-                        mActivity.getMediaSaveService().addImage(
-                                bytes, title, date, null, image.getCropRect().width(), image.getCropRect().height(),
-                                orientation, null, mController.getMediaSavedListener(), mActivity.getContentResolver(), "jpeg");
-                        mController.updateThumbnailJpegData(bytes);
-                        image.close();
+                        mNamedImages.nameNewImage(captureStartTime);
+                        PhotoModule.NamedImages.NamedEntity name = mNamedImages.getNextNameEntity();
+                        String title = (name == null) ? null : name.title;
+                        long date = (name == null) ? -1 : name.date;
+                        image.getPlanes()[0].getBuffer().rewind();
+                        int size = image.getPlanes()[0].getBuffer().remaining();
+                        byte[] bytes = new byte[size];
+                        image.getPlanes()[0].getBuffer().get(bytes, 0, size);
+                        ExifInterface exif = Exif.getExif(bytes);
+                        int orientation = Exif.getOrientation(exif);
+                        if (mController.getCurrentIntentMode() != CaptureModule.INTENT_MODE_NORMAL) {
+                            mController.setJpegImageData(bytes);
+                            if (mController.isQuickCapture()) {
+                                mController.onCaptureDone();
+                            } else {
+                                mController.showCapturedReview(bytes, orientation);
+                            }
+                        } else {
+                            mActivity.getMediaSaveService().addImage(
+                                    bytes, title, date, null, image.getCropRect().width(), image.getCropRect().height(),
+                                    orientation, null, mController.getMediaSavedListener(), mActivity.getContentResolver(), "jpeg");
+                            mController.updateThumbnailJpegData(bytes);
+                            image.close();
+                        }
                     }
                 }
             });
diff --git a/src/com/android/camera/imageprocessor/filter/BestpictureFilter.java b/src/com/android/camera/imageprocessor/filter/BestpictureFilter.java
index 418bd03..46e2581 100644
--- a/src/com/android/camera/imageprocessor/filter/BestpictureFilter.java
+++ b/src/com/android/camera/imageprocessor/filter/BestpictureFilter.java
@@ -49,6 +49,7 @@ import com.android.camera.CameraActivity;
 import com.android.camera.CaptureModule;
 import com.android.camera.MediaSaveService;
 import com.android.camera.PhotoModule;
+import com.android.camera.SPhotoModule;
 import com.android.camera.imageprocessor.PostProcessor;
 import com.android.camera.util.CameraUtil;
 
@@ -78,6 +79,7 @@ public class BestpictureFilter implements ImageFilter {
     private final static int TIME_DELAY = 50;
     private int mSavedCount = 0;
     private PhotoModule.NamedImages mNamedImages;
+    private SPhotoModule.SNamedImages mSNamedImages;
     private ByteBuffer mBY;
     private ByteBuffer mBVU;
     private Object mClosingLock = new Object();
@@ -96,7 +98,11 @@ public class BestpictureFilter implements ImageFilter {
         mModule = module;
         mActivity = activity;
         mProcessor = processor;
-        mNamedImages = new PhotoModule.NamedImages();
+        if(CameraUtil.HAS_EXYNOS5CAMERA) {
+            mSNamedImages = new SPhotoModule.SNamedImages();
+        } else {
+            mNamedImages = new PhotoModule.NamedImages();
+        }
     }
 
     @Override
@@ -150,38 +156,73 @@ public class BestpictureFilter implements ImageFilter {
 
             byte[] bytes = getYUVBytes(bY, bVU, imageNum);
             long captureStartTime = System.currentTimeMillis();
-            mNamedImages.nameNewImage(captureStartTime);
-            PhotoModule.NamedImages.NamedEntity name = mNamedImages.getNextNameEntity();
-            String title = (name == null) ? null : name.title;
-            long date = (name == null) ? -1 : name.date;
-            mActivity.getMediaSaveService().addImage(
-                    bytes, title, date, null, mWidth, mHeight,
-                    mOrientation, null, new MediaSaveService.OnMediaSavedListener() {
-                        @Override
-                        public void onMediaSaved(final  Uri uri) {
-                            if (uri != null) {
-                                mActivity.notifyNewMedia(uri);
-                                new Thread() {
-                                    public void run() {
-                                        while(mSavedCount < NUM_REQUIRED_IMAGE) {
-                                            try {
-                                                Thread.sleep(10);
-                                            } catch (Exception e) {
+            if(CameraUtil.HAS_EXYNOS5CAMERA) {
+                mSNamedImages.nameNewImage(captureStartTime);
+                SPhotoModule.SNamedImages.SNamedEntity name = mSNamedImages.getNextNameEntity();
+                String title = (name == null) ? null : name.title;
+                long date = (name == null) ? -1 : name.date;
+                mActivity.getMediaSaveService().addImage(
+                        bytes, title, date, null, mWidth, mHeight,
+                        mOrientation, null, new MediaSaveService.OnMediaSavedListener() {
+                            @Override
+                            public void onMediaSaved(final  Uri uri) {
+                                if (uri != null) {
+                                    mActivity.notifyNewMedia(uri);
+                                    new Thread() {
+                                        public void run() {
+                                            while(mSavedCount < NUM_REQUIRED_IMAGE) {
+                                                try {
+                                                    Thread.sleep(10);
+                                                } catch (Exception e) {
+                                                }
                                             }
+                                            mActivity.runOnUiThread(new Runnable() {
+                                                public void run() {
+                                                    dismissProgressDialog();
+                                                    startBestpictureActivity(uri);
+                                                }
+                                            });
                                         }
-                                        mActivity.runOnUiThread(new Runnable() {
-                                            public void run() {
-                                                dismissProgressDialog();
-                                                startBestpictureActivity(uri);
+                                    }.start();
+    
+                                }
+                            }
+                        }
+                        , mActivity.getContentResolver(), "jpeg");
+            } else {
+                mNamedImages.nameNewImage(captureStartTime);
+                PhotoModule.NamedImages.NamedEntity name = mNamedImages.getNextNameEntity();
+                String title = (name == null) ? null : name.title;
+                long date = (name == null) ? -1 : name.date;
+                mActivity.getMediaSaveService().addImage(
+                        bytes, title, date, null, mWidth, mHeight,
+                        mOrientation, null, new MediaSaveService.OnMediaSavedListener() {
+                            @Override
+                            public void onMediaSaved(final  Uri uri) {
+                                if (uri != null) {
+                                    mActivity.notifyNewMedia(uri);
+                                    new Thread() {
+                                        public void run() {
+                                            while(mSavedCount < NUM_REQUIRED_IMAGE) {
+                                                try {
+                                                    Thread.sleep(10);
+                                                } catch (Exception e) {
+                                                }
                                             }
-                                        });
-                                    }
-                                }.start();
-
+                                            mActivity.runOnUiThread(new Runnable() {
+                                                public void run() {
+                                                    dismissProgressDialog();
+                                                    startBestpictureActivity(uri);
+                                                }
+                                            });
+                                        }
+                                    }.start();
+    
+                                }
                             }
                         }
-                    }
-                    , mActivity.getContentResolver(), "jpeg");
+                        , mActivity.getContentResolver(), "jpeg");
+            }
         }
         byte[] bytes = getYUVBytes(bY, bVU, imageNum);
         saveBestPicture(bytes, imageNum);
diff --git a/src/com/android/camera/tinyplanet/TinyPlanetFragment.java b/src/com/android/camera/tinyplanet/TinyPlanetFragment.java
index 5a9f739..f14b384 100644
--- a/src/com/android/camera/tinyplanet/TinyPlanetFragment.java
+++ b/src/com/android/camera/tinyplanet/TinyPlanetFragment.java
@@ -44,10 +44,12 @@ import com.adobe.xmp.XMPMeta;
 import com.android.camera.CameraActivity;
 import com.android.camera.MediaSaveService;
 import com.android.camera.PhotoModule;
+import com.android.camera.SPhotoModule;
 import com.android.camera.MediaSaveService.OnMediaSavedListener;
 import com.android.camera.exif.ExifInterface;
 import com.android.camera.tinyplanet.TinyPlanetPreview.PreviewSizeListener;
 import com.android.camera.util.XmpUtil;
+import com.android.camera.util.CameraUtil;
 import org.codeaurora.snapcam.R;
 
 import java.io.ByteArrayOutputStream;
@@ -322,7 +324,9 @@ public class TinyPlanetFragment extends DialogFragment implements PreviewSizeLis
                 mediaSaveService.addImage(image.mJpegData, tinyPlanetTitle, (new Date()).getTime(),
                         null,
                         image.mSize, image.mSize, 0, null, doneListener, getActivity()
-                                .getContentResolver(),PhotoModule.PIXEL_FORMAT_JPEG);
+                        .getContentResolver(),
+                        CameraUtil.HAS_EXYNOS5CAMERA ? SPhotoModule.PIXEL_FORMAT_JPEG
+                        : PhotoModule.PIXEL_FORMAT_JPEG);
             }
         }).executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR);
     }
diff --git a/src/com/android/camera/ui/FaceView.java b/src/com/android/camera/ui/FaceView.java
index 04b3664..c6821cb 100644
--- a/src/com/android/camera/ui/FaceView.java
+++ b/src/com/android/camera/ui/FaceView.java
@@ -32,6 +32,7 @@ import android.util.Log;
 import android.view.View;
 
 import com.android.camera.PhotoUI;
+import com.android.camera.SPhotoUI;
 import com.android.camera.util.CameraUtil;
 import com.android.camera.util.PersistUtil;
 import org.codeaurora.snapcam.R;
@@ -39,7 +40,8 @@ import org.codeaurora.snapcam.wrapper.ExtendedFaceWrapper;
 
 public class FaceView extends View
     implements FocusIndicator, Rotatable,
-    PhotoUI.SurfaceTextureSizeChangedListener {
+    PhotoUI.SurfaceTextureSizeChangedListener,
+    SPhotoUI.SurfaceTextureSizeChangedListener {
     protected static final String TAG = "CAM_FaceView";
     protected final boolean LOGV =
             (PersistUtil.getCamera2Debug() == PersistUtil.CAMERA2_DEBUG_DUMP_LOG) ||
diff --git a/src/com/android/camera/ui/FilmStripView.java b/src/com/android/camera/ui/FilmStripView.java
index 6a76786..ba5619a 100644
--- a/src/com/android/camera/ui/FilmStripView.java
+++ b/src/com/android/camera/ui/FilmStripView.java
@@ -39,6 +39,8 @@ import android.widget.Scroller;
 
 import com.android.camera.PhotoMenu;
 import com.android.camera.VideoMenu;
+import com.android.camera.SPhotoMenu;
+import com.android.camera.SVideoMenu;
 import com.android.camera.PreviewGestures;
 import com.android.camera.CameraActivity;
 import com.android.camera.data.LocalData;
@@ -1829,41 +1831,80 @@ public class FilmStripView extends ViewGroup implements BottomControlsListener {
     public boolean checkSendToModeView(MotionEvent ev) {
         if (mSendToPreviewMenu || mSendToMenu || mPreviewGestures == null)
             return true;
-        PhotoMenu pMenu = mPreviewGestures.getPhotoMenu();
-        VideoMenu vMenu = mPreviewGestures.getVideoMenu();
-
-        if (pMenu != null) {
-            if (pMenu.isMenuBeingShown()) {
-                if (pMenu.isMenuBeingAnimated()) {
-                    if (pMenu.isOverMenu(ev)) {
-                        mSendToMenu = true;
+        if(CameraUtil.HAS_EXYNOS5CAMERA) {
+            SPhotoMenu pMenu = mPreviewGestures.getSPhotoMenu();
+            SVideoMenu vMenu = mPreviewGestures.getSVideoMenu();
+            if (pMenu != null) {
+                if (pMenu.isMenuBeingShown()) {
+                    if (pMenu.isMenuBeingAnimated()) {
+                        if (pMenu.isOverMenu(ev)) {
+                            mSendToMenu = true;
+                            return true;
+                        }
+                    }
+                }
+
+                if (pMenu.isPreviewMenuBeingShown()) {
+                    if (pMenu.isOverPreviewMenu(ev)) {
+                        mSendToPreviewMenu = true;
                         return true;
                     }
                 }
             }
 
-            if (pMenu.isPreviewMenuBeingShown()) {
-                if (pMenu.isOverPreviewMenu(ev)) {
-                    mSendToPreviewMenu = true;
-                    return true;
+            if (vMenu != null) {
+                if (vMenu.isMenuBeingShown()) {
+                    if (vMenu.isMenuBeingAnimated()) {
+                        if (vMenu.isOverMenu(ev)) {
+                            mSendToMenu = true;
+                            return true;
+                        }
+                    }
+                }
+
+                if (vMenu.isPreviewMenuBeingShown()) {
+                    if (vMenu.isOverPreviewMenu(ev)) {
+                        mSendToPreviewMenu = true;
+                        return true;
+                    }
                 }
             }
-        }
+        } else {
+            PhotoMenu pMenu = mPreviewGestures.getPhotoMenu();
+            VideoMenu vMenu = mPreviewGestures.getVideoMenu();
+            if (pMenu != null) {
+                if (pMenu.isMenuBeingShown()) {
+                    if (pMenu.isMenuBeingAnimated()) {
+                        if (pMenu.isOverMenu(ev)) {
+                            mSendToMenu = true;
+                            return true;
+                        }
+                    }
+                }
 
-        if (vMenu != null) {
-            if (vMenu.isMenuBeingShown()) {
-                if (vMenu.isMenuBeingAnimated()) {
-                    if (vMenu.isOverMenu(ev)) {
-                        mSendToMenu = true;
+                if (pMenu.isPreviewMenuBeingShown()) {
+                    if (pMenu.isOverPreviewMenu(ev)) {
+                        mSendToPreviewMenu = true;
                         return true;
                     }
                 }
             }
 
-            if (vMenu.isPreviewMenuBeingShown()) {
-                if (vMenu.isOverPreviewMenu(ev)) {
-                    mSendToPreviewMenu = true;
-                    return true;
+            if (vMenu != null) {
+                if (vMenu.isMenuBeingShown()) {
+                    if (vMenu.isMenuBeingAnimated()) {
+                        if (vMenu.isOverMenu(ev)) {
+                            mSendToMenu = true;
+                            return true;
+                        }
+                    }
+                }
+
+                if (vMenu.isPreviewMenuBeingShown()) {
+                    if (vMenu.isOverPreviewMenu(ev)) {
+                        mSendToPreviewMenu = true;
+                        return true;
+                    }
                 }
             }
         }
@@ -1884,33 +1925,63 @@ public class FilmStripView extends ViewGroup implements BottomControlsListener {
                     || MotionEvent.ACTION_CANCEL == ev.getActionMasked())
                 mReset = true;
         }
-        PhotoMenu pMenu = mPreviewGestures.getPhotoMenu();
-        VideoMenu vMenu = mPreviewGestures.getVideoMenu();
-        if (pMenu != null) {
-            if (mSendToPreviewMenu)
-                return pMenu.sendTouchToPreviewMenu(ev);
-            if (mSendToMenu)
-                return pMenu.sendTouchToMenu(ev);
-            if (pMenu.isMenuBeingShown()) {
-                return pMenu.sendTouchToMenu(ev);
+        if(CameraUtil.HAS_EXYNOS5CAMERA) {
+            SPhotoMenu pMenu = mPreviewGestures.getSPhotoMenu();
+            SVideoMenu vMenu = mPreviewGestures.getSVideoMenu();
+            if (pMenu != null) {
+                if (mSendToPreviewMenu)
+                    return pMenu.sendTouchToPreviewMenu(ev);
+                if (mSendToMenu)
+                    return pMenu.sendTouchToMenu(ev);
+                if (pMenu.isMenuBeingShown()) {
+                    return pMenu.sendTouchToMenu(ev);
+                }
+
+                if (pMenu.isPreviewMenuBeingShown()) {
+                    return pMenu.sendTouchToPreviewMenu(ev);
+                }
             }
+            if (vMenu != null) {
+                if (mSendToPreviewMenu)
+                    return vMenu.sendTouchToPreviewMenu(ev);
+                if (mSendToMenu)
+                    return vMenu.sendTouchToMenu(ev);
+                if (vMenu.isMenuBeingShown()) {
+                    return vMenu.sendTouchToMenu(ev);
+                }
 
-            if (pMenu.isPreviewMenuBeingShown()) {
-                return pMenu.sendTouchToPreviewMenu(ev);
+                if (vMenu.isPreviewMenuBeingShown()) {
+                    return vMenu.sendTouchToPreviewMenu(ev);
+                }
             }
-        }
+        } else {
+            PhotoMenu pMenu = mPreviewGestures.getPhotoMenu();
+            VideoMenu vMenu = mPreviewGestures.getVideoMenu();
+            if (pMenu != null) {
+                if (mSendToPreviewMenu)
+                    return pMenu.sendTouchToPreviewMenu(ev);
+                if (mSendToMenu)
+                    return pMenu.sendTouchToMenu(ev);
+                if (pMenu.isMenuBeingShown()) {
+                    return pMenu.sendTouchToMenu(ev);
+                }
 
-        if (vMenu != null) {
-            if (mSendToPreviewMenu)
-                return vMenu.sendTouchToPreviewMenu(ev);
-            if (mSendToMenu)
-                return vMenu.sendTouchToMenu(ev);
-            if (vMenu.isMenuBeingShown()) {
-                return vMenu.sendTouchToMenu(ev);
+                if (pMenu.isPreviewMenuBeingShown()) {
+                    return pMenu.sendTouchToPreviewMenu(ev);
+                }
             }
+            if (vMenu != null) {
+                if (mSendToPreviewMenu)
+                    return vMenu.sendTouchToPreviewMenu(ev);
+                if (mSendToMenu)
+                    return vMenu.sendTouchToMenu(ev);
+                if (vMenu.isMenuBeingShown()) {
+                    return vMenu.sendTouchToMenu(ev);
+                }
 
-            if (vMenu.isPreviewMenuBeingShown()) {
-                return vMenu.sendTouchToPreviewMenu(ev);
+                if (vMenu.isPreviewMenuBeingShown()) {
+                    return vMenu.sendTouchToPreviewMenu(ev);
+                }
             }
         }
         return false;
diff --git a/src/com/android/camera/ui/ModuleSwitcher.java b/src/com/android/camera/ui/ModuleSwitcher.java
index 8b4797f..c1da6de 100644
--- a/src/com/android/camera/ui/ModuleSwitcher.java
+++ b/src/com/android/camera/ui/ModuleSwitcher.java
@@ -48,8 +48,10 @@ public class ModuleSwitcher extends RotateImageView
     private static final String TAG = "CAM_Switcher";
     private static final int SWITCHER_POPUP_ANIM_DURATION = 200;
 
-    public static final int PHOTO_MODULE_INDEX = 0;
-    public static final int VIDEO_MODULE_INDEX = 1;
+    public static final int PHOTO_MODULE_INDEX = 9;
+    public static final int VIDEO_MODULE_INDEX = 8;
+    public static final int SPHOTO_MODULE_INDEX = 0;
+    public static final int SVIDEO_MODULE_INDEX = 1;
     public static final int WIDE_ANGLE_PANO_MODULE_INDEX = 2;
     public static final int QR_MODULE_INDEX = 3;
     public static final int LIGHTCYCLE_MODULE_INDEX = 4;
@@ -118,10 +120,21 @@ public class ModuleSwitcher extends RotateImageView
         // Always decrement one because of GCam.
         --numDrawIds;
 
+        if(CameraUtil.HAS_EXYNOS5CAMERA) {
+            --numDrawIds;
+        }
+
         int[] drawids = new int[numDrawIds];
         int[] moduleids = new int[numDrawIds];
         int ix = 0;
         for (int i = 0; i < DRAW_IDS.length; i++) {
+            if(CameraUtil.HAS_EXYNOS5CAMERA) {
+                if(i == PHOTO_MODULE_INDEX || i == VIDEO_MODULE_INDEX || i == QR_MODULE_INDEX)
+                     continue;
+            } else {
+                if(i == SPHOTO_MODULE_INDEX || i == SVIDEO_MODULE_INDEX)
+                     continue;
+            }
             if (i == LIGHTCYCLE_MODULE_INDEX && !PhotoSphereHelper.hasLightCycleCapture(context)) {
                 continue; // not enabled, so don't add to UI
             }
diff --git a/src/com/android/camera/util/CameraUtil.java b/src/com/android/camera/util/CameraUtil.java
index 7f6e580..157d429 100644
--- a/src/com/android/camera/util/CameraUtil.java
+++ b/src/com/android/camera/util/CameraUtil.java
@@ -103,6 +103,9 @@ import static android.content.Context.MODE_PRIVATE;
 public class CameraUtil {
     private static final String TAG = "Util";
 
+    // To chose samsung camera
+    public static final boolean HAS_EXYNOS5CAMERA = android.os.SystemProperties.getBoolean("persist.snap.exynos5camera", false);
+
     // For calculate the best fps range for still image capture.
     private final static int MAX_PREVIEW_FPS_TIMES_1000 = 400000;
     private final static int PREFERRED_PREVIEW_FPS_TIMES_1000 = 30000;
@@ -153,6 +156,7 @@ public class CameraUtil {
     private static final String MAPS_PACKAGE_NAME = "com.google.android.apps.maps";
     private static final String MAPS_CLASS_NAME = "com.google.android.maps.MapsActivity";
 
+
     /** Has to be in sync with the receiving MovieActivity. */
     public static final String KEY_TREAT_UP_AS_BACK = "treat-up-as-back";
     /** Judge the value whether is from lockscreen come in or not */
-- 
2.7.4

